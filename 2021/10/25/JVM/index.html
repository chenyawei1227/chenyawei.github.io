<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="baidu-site-verification" content="093lY4ziMu" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="description" content="A hexo theme">
    <meta name="keyword"  content="Chenyawei,luke, hexo">
    <link rel="shortcut icon" href="/img/ironman-draw.png">
    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
    <!--<link href='http://fonts.googleapis.com/css?family=Montserrat:400,700' rel='stylesheet' type='text/css'>-->
    <title>
        
          JVM - chenyawei-blog
        
    </title>

    <link rel="canonical" href="https://bytenote.cn/2021/10/25/JVM/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS --> 
    
      
<link rel="stylesheet" href="/css/dusign-light.css">

      <!-- background effects end -->
    
    
    <!-- Pygments Highlight CSS -->
    
<link rel="stylesheet" href="/css/highlight.css">


    
<link rel="stylesheet" href="/css/widget.css">


    
<link rel="stylesheet" href="/css/rocket.css">


    
<link rel="stylesheet" href="/css/signature.css">


    
      
<link rel="stylesheet" href="/css/toc.css">

    

    
<link rel="stylesheet" href="/css/dusign-common.css">

    
<link rel="stylesheet" href="/css/fonts.googleapis.css">


    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <!--<link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    
      
<link rel="stylesheet" href="/css/font-awesome.css">

    

    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    
        <!-- background effects start -->
        
        <!-- background effects end -->
    

	<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        
            background-image: url('')
            /*post*/
        
    }
    
    #signature{
        background-image: url('/img/signature/Just-do-it-white.png');
    }
    
</style>

<header class="intro-header" >
    <!-- Signature -->
    <div id="signature">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                
                    <div class="post-heading">
                        <div class="tags">
                            
                              <a class="tag" href="/tags/#java" title="java">java</a>
                            
                              <a class="tag" href="/tags/#jvm" title="jvm">jvm</a>
                            
                        </div>
                        <h1>JVM</h1>
                        <h2 class="subheading"></h2>
                        <span class="meta">
                            Posted by Chenyawei on
                            2021-10-25
                        </span>

                        
                            <div class="blank_box"></div>
                            <span class="meta">
                                Words <span class="post-count">27.2k</span> and
                                Reading Time <span class="post-count">114</span> Minutes
                            </span>
                            <div class="blank_box"></div>
                            <!-- 不蒜子统计 start -->
                            <span class="meta">
                                Viewed <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span> Times
                            </span>
                            <!-- 不蒜子统计 end -->
                        

                    </div>
                

                </div>
            </div>
        </div>      
    </div>
    <div class="waveWrapper">
        <div class="wave wave_before" style="background-image: url('/img/wave-top80.png')"></div>
        <div class="wave wave_after" style="background-image: url('/img/wave-top80.png')"></div>
    </div>
</header>

	
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Chenyawei&#39;s Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    

                    <li>
                        <a href="https://www.jianshu.com/u/78b636e8a217" target="_blank">Chinese Blog</a>
                    </li>
                    <li>
                        <a href="#" target="_blank">Store</a>
                    </li>
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    <!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h2 id="一、什么是JVM"><a href="#一、什么是JVM" class="headerlink" title="一、什么是JVM"></a>一、什么是JVM</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Java Virtual Machine，JAVA程序的<strong>运行环境</strong>（JAVA二进制字节码的运行环境）</p>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul>
<li>一次编写，到处运行</li>
<li>自动内存管理，垃圾回收机制</li>
<li>数组下标越界检查</li>
<li>多态</li>
</ul>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>JVM JRE JDK的区别</p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150422.png" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvmyeikxypj60wq0jz0v302.jpg" alt="img"></a></p>
<h2 id="二、内存结构"><a href="#二、内存结构" class="headerlink" title="二、内存结构"></a>二、内存结构</h2><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a><strong>整体架构</strong></h3><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150440.png" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvmyegoslxj60xi0ijjtr02.jpg" alt="img"></a></p>
<h3 id="1、程序计数器"><a href="#1、程序计数器" class="headerlink" title="1、程序计数器"></a>1、程序计数器</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvmyeevfuij617u0lawid02.jpg" alt="image-20211021113817807"></p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>用于保存JVM中下一条所要执行的指令的地址</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>线程私有<ul>
<li>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码</li>
<li>程序计数器是<strong>每个线程</strong>所<strong>私有</strong>的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令</li>
</ul>
</li>
<li>不会存在内存溢出</li>
</ul>
<h3 id="2、虚拟机栈"><a href="#2、虚拟机栈" class="headerlink" title="2、虚拟机栈"></a>2、虚拟机栈</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul>
<li>每个<strong>线程</strong>运行需要的内存空间，称为<strong>虚拟机栈</strong></li>
<li>每个栈由多个<strong>栈帧</strong>(栈中的元素)组成，对应着每次调用方法时所占用的内存</li>
<li>每个线程只能有<strong>一个活动栈帧</strong>，对应着<strong>当前正在执行的方法</strong></li>
</ul>
<h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p>代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		method1();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static void method1() &#123;</span><br><span class="line">		method2(1, 2);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static int method2(int a, int b) &#123;</span><br><span class="line">		int c &#x3D; a + b;</span><br><span class="line">		return c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Copy</span><br></pre></td></tr></table></figure>
<p>栈的演示:x</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvmyed5rlaj61du0qedkl02.jpg" alt="image-20211021115009524"></p>
<p>在控制台中可以看到，主类中的方法在进入虚拟机栈的时候，符合栈的特点</p>
<h4 id="问题辨析"><a href="#问题辨析" class="headerlink" title="问题辨析"></a>问题辨析</h4><ul>
<li><p>垃圾回收是否涉及栈内存？</p>
<ul>
<li><strong>不需要</strong>。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</li>
</ul>
</li>
<li><p>栈内存的分配越大越好吗？(可以通过 -Xss size 指定内存大小)</p>
<ul>
<li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。一般采用系统默认大小就行.</li>
</ul>
</li>
<li><p>方法内的局部变量是否是线程安全的？</p>
<p>  <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvmyeazn8yj60dm0acdg802.jpg" alt="image-20211021120130752"></p>
<ul>
<li>如果方法内<strong>局部变量没有逃离方法的作用范围</strong>，则是<strong>线程安全</strong>的 (例如:  int x = 0; 线程私有的)</li>
<li>如果如果<strong>局部变量引用了对象</strong>，并<strong>逃离了方法的作用范围</strong>，则需要考虑线程安全问题 (例如: static int i = i + 1; 线程共享的)</li>
</ul>
</li>
</ul>
<h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4><p><strong>Java.lang.stackOverflowError</strong> 栈内存溢出</p>
<p><strong>发生原因</strong></p>
<ul>
<li>虚拟机栈中，<strong>栈帧过多</strong>（无限递归）</li>
<li>每个栈帧<strong>所占用过大</strong></li>
</ul>
<h4 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h4><p>CPU占用过高</p>
<ul>
<li>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程<ul>
<li><strong>top</strong>命令，查看是哪个<strong>进程</strong>占用CPU过高</li>
<li><strong>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号</strong> 通过ps命令进一步查看是哪个线程占用CPU过高</li>
<li><strong>jstack 进程id</strong> 通过(这个jdk工具)查看进程中的线程的nid，刚才通过ps命令看到的tid(十进制的)来<strong>对比定位</strong>，注意jstack查找出的线程id是<strong>16进制的</strong>，<strong>需要转换</strong></li>
</ul>
</li>
</ul>
<h3 id="3、本地方法栈"><a href="#3、本地方法栈" class="headerlink" title="3、本地方法栈"></a>3、本地方法栈</h3><p>一些带有<strong>native关键字</strong>的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法</p>
<h3 id="4、堆"><a href="#4、堆" class="headerlink" title="4、堆"></a>4、堆</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>通过new关键字<strong>创建的对象</strong>都会被放在堆内存. 可以通过-Xmx512m 设置堆空间大小</p>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li><strong>所有线程共享</strong>，堆内存中的对象都需要<strong>考虑线程安全问题</strong></li>
<li>有垃圾回收机制</li>
</ul>
<h4 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvmye87ofqj60gg0fujsa02.jpg" alt="image-20211021123827778" style="zoom:50%;" /></p>
<p><strong>java.lang.OutofMemoryError</strong> ：java heap space. 堆内存溢出</p>
<h4 id="堆内存诊断工具"><a href="#堆内存诊断工具" class="headerlink" title="堆内存诊断工具"></a>堆内存诊断工具</h4><p><strong>jps</strong>: 查看当前系统中有哪些Java进程 jps</p>
<p><strong>jmap</strong>:查看堆内存占用情况(某一时刻的) jmap heap 进程ID</p>
<p><strong>jconsole</strong>:图形界面,多功能监测工具,可以连续监测</p>
<p><strong>jvirsalvm</strong>:图形界面,可安装多种插件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:  演示堆内存</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"1......"</span>);</span><br><span class="line">    Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">    Byte[] array = <span class="keyword">new</span> Byte[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>]; <span class="comment">// 10M</span></span><br><span class="line">    System.out.println(<span class="string">"2......"</span>);</span><br><span class="line">    Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">    array = <span class="keyword">null</span>;</span><br><span class="line">    System.gc();</span><br><span class="line">    System.out.println(<span class="string">"3......"</span>);</span><br><span class="line">    Thread.sleep(<span class="number">100000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5、方法区"><a href="#5、方法区" class="headerlink" title="5、方法区"></a>5、方法区</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义:"></a>定义:</h4><p>和堆一样也是线程共享的, 存储类相关的一些信息,方法、构造器、成员方法等</p>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5.4" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5.4</a></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvmye4eb89j623a0eeag802.jpg" alt="image-20211021145512190"></p>
<p>Java 虚拟机有一个在所有 Java 虚拟机线程之间共享的方法区。 方法区类似于传统语言的编译代码存储区，或类似于操作系统进程中的“文本”段。 它存储每个类的结构，例如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括在类和实例初始化和接口初始化中使用的特殊方法 (2.9)。</p>
<h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150547.png" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvmye2lorqj60y80medhu02.jpg" alt="img"></a></p>
<h4 id="内存溢出-1"><a href="#内存溢出-1" class="headerlink" title="内存溢出"></a>内存溢出</h4><ul>
<li><p>1.8以前会导致<strong>永久代</strong>内存溢出, 整个方法区在堆内存里.常量次中包括StringTable</p>
</li>
<li><p>1.8以后会导致<strong>元空间</strong>内存溢出, 方法区移到了元空间,元空间在本地内存(系统内存),常量中没有StringTable了,StringTable还在堆内存里</p>
<blockquote>
<p>演示1.8的元空间内存溢出:</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvmydy5ctqj611y0l2q5s02.jpg" alt="image-20211021151449591" style="zoom: 50%;" /></p>
<p><img src="/Users/chenyawei/Library/Application Support/typora-user-images/image-20211021153330031.png" alt="image-20211021153330031" style="zoom:50%;" /></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>演示1.6的永久带内存溢出:</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvmyuilewkj613k0f4jt902.jpg" alt="image-20211021153101130" style="zoom:50%;" /></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvmyvteg84j60om08ggn702.jpg" alt="image-20211021153212984" style="zoom:50%;" /></p>
<h4 id=""><a href="#" class="headerlink" title=" "></a> </h4></blockquote>
<h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>二进制字节码的组成：类的基本信息、常量池、类的方法定义（包含了虚拟机指令）</p>
<p><strong>通过反编译来查看类的信息</strong></p>
<ul>
<li><p>获得对应类的.class文件</p>
<ul>
<li><p>在JDK对应的bin目录下运行cmd，<strong>也可以在IDEA控制台输入</strong></p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150602.png" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn36fap7xj60fq01ba9x02.jpg" alt="img"></a></p>
</li>
<li><p>输入 <strong>javac 对应类的绝对路径</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F:\JAVA\JDK8.0\bin&gt;javac F:\Thread_study\src\com\nyima\JVM\day01\Main.javaCopy</span><br></pre></td></tr></table></figure>
<p>输入完成后，对应的目录下就会出现类的.class文件</p>
</li>
</ul>
</li>
<li><p>在控制台输入 javap -v 类的绝对路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v F:\Thread_study\src\com\nyima\JVM\day01\Main.class</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后能在控制台看到反编译以后类的信息了</p>
<ul>
<li><p>类的基本信息</p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150618.png" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn36cnah2j60v2097myn02.jpg" alt="img"></a></p>
</li>
<li><p>常量池</p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150630.png" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn36arpuoj60v40eztap02.jpg" alt="img"></a></p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150641.png" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn368fdibj60v20bewfx02.jpg" alt="img"></a></p>
</li>
<li><p>虚拟机中执行编译的方法（框内的是真正编译执行的内容，<strong>#号的内容需要在常量池中查找</strong>）</p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150653.png" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn36396wmj60v606kjs602.jpg" alt="img"></a></p>
</li>
</ul>
</li>
</ul>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ul>
<li>常量池<ul>
<li>就是一张表（如上图中的constant pool），虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息</li>
</ul>
</li>
<li>运行时常量池<ul>
<li>常量池是<em>.class文件中的，当该<strong>类被加载以后</strong>，它的常量池信息就会<strong>放入运行时常量池</strong>，并把里面的<em>*符号地址变为真实地址</em></em></li>
</ul>
</li>
</ul>
<h4 id="常量池与字符串池的关系"><a href="#常量池与字符串池的关系" class="headerlink" title="常量池与字符串池的关系"></a>常量池与字符串池的关系</h4><h5 id="字符串串池StringTable"><a href="#字符串串池StringTable" class="headerlink" title="字符串串池StringTable"></a><strong>字符串串池</strong>StringTable</h5><p><strong>特征</strong></p>
<ul>
<li>常量池中的字符串仅是符号，只有<strong>在被用到时才会转化为对象</strong></li>
<li>利用串池的机制，来避免重复创建字符串对象</li>
<li>字符串<strong>变量</strong>拼接的原理是<strong>StringBuilder</strong></li>
<li>字符串<strong>常量</strong>拼接的原理是<strong>编译器优化</strong></li>
<li>可以使用<strong>intern方法</strong>，主动将串池中还没有的字符串对象放入串池中</li>
<li><strong>注意</strong>：无论是串池还是堆里面的字符串，都是对象</li>
</ul>
<p>用来放字符串对象且里面的<strong>元素不重复</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTableStudy</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String a = <span class="string">"a"</span>; </span><br><span class="line">		String b = <span class="string">"b"</span>;</span><br><span class="line">		String ab = <span class="string">"ab"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常量池中的信息，都会被加载到运行时常量池中，但这是a b ab 仅是常量池中的符号，<strong>还没有成为java字符串</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0: ldc           #2                  &#x2F;&#x2F; String a</span><br><span class="line">2: astore_1</span><br><span class="line">3: ldc           #3                  &#x2F;&#x2F; String b</span><br><span class="line">5: astore_2</span><br><span class="line">6: ldc           #4                  &#x2F;&#x2F; String ab</span><br><span class="line">8: astore_3</span><br><span class="line">9: return</span><br></pre></td></tr></table></figure>
<p>当执行到 ldc #2 时，会把符号 a 变为 “a” 字符串对象，<strong>并放入串池中</strong>（hashtable结构 不可扩容）</p>
<p>当执行到 ldc #3 时，会把符号 b 变为 “b” 字符串对象，并放入串池中</p>
<p>当执行到 ldc #4 时，会把符号 ab 变为 “ab” 字符串对象，并放入串池中</p>
<p>最终<strong>StringTable [“a”, “b”, “ab”]</strong></p>
<p><strong>注意</strong>：字符串对象的创建都是<strong>懒惰的</strong>，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2）时，该字符串才会被创建并放入串池中。</p>
<p>使用拼接<strong>字符串变量对象</strong>创建字符串的过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTableStudy</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String a = <span class="string">"a"</span>;</span><br><span class="line">		String b = <span class="string">"b"</span>;</span><br><span class="line">		String ab = <span class="string">"ab"</span>;</span><br><span class="line">		<span class="comment">//拼接字符串对象来创建新的字符串</span></span><br><span class="line">		String ab2 = a+b; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反编译后的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">	 Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;5, args_size&#x3D;1</span><br><span class="line">         0: ldc           #2                  &#x2F;&#x2F; String a</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: ldc           #3                  &#x2F;&#x2F; String b</span><br><span class="line">         5: astore_2</span><br><span class="line">         6: ldc           #4                  &#x2F;&#x2F; String ab</span><br><span class="line">         8: astore_3</span><br><span class="line">         9: new           #5                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;StringBuilder</span><br><span class="line">        12: dup</span><br><span class="line">        13: invokespecial #6                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">        16: aload_1</span><br><span class="line">        17: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String</span><br><span class="line">;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">        20: aload_2</span><br><span class="line">        21: invokevirtual #7                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String</span><br><span class="line">;)Ljava&#x2F;lang&#x2F;StringBuilder;</span><br><span class="line">        24: invokevirtual #8                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;Str</span><br><span class="line">ing;</span><br><span class="line">        27: astore        4</span><br><span class="line">        29: return</span><br></pre></td></tr></table></figure>
<p>通过拼接的方式来创建字符串的<strong>过程</strong>是：StringBuilder().append(“a”).append(“b”).toString()</p>
<p>StringBuilder的toString()方法是返回newString()对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Create a copy, don't share the array</span></span><br><span class="line">       <span class="keyword">return</span> isLatin1() ? StringLatin1.newString(value, <span class="number">0</span>, count)</span><br><span class="line">                         : StringUTF16.newString(value, <span class="number">0</span>, count);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>最后的toString方法的返回值是一个<strong>新的字符串</strong>，但字符串的<strong>值</strong>和拼接的字符串一致，但是两个不同的字符串，<strong>一个存在于串池之中，一个存在于堆内存之中</strong>;</p>
<p>使用<strong>拼接字符串变量</strong>的方法来创建新的字符串时，因为内容是变量，只能<strong>在运行期确定它的值，所以需要使用StringBuilder来创建</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String ab = <span class="string">"ab"</span>;</span><br><span class="line">String ab2 = a+b;</span><br><span class="line"><span class="comment">//结果为false,因为ab是存在于串池之中，ab2是由StringBuffer的toString方法所返回的一个对象，存在于堆内存之中</span></span><br><span class="line">System.out.println(ab == ab2);</span><br></pre></td></tr></table></figure>
<p>使用<strong>拼接字符串常量对象</strong>的方法创建字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTableStudy</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String a = <span class="string">"a"</span>;</span><br><span class="line">		String b = <span class="string">"b"</span>;</span><br><span class="line">		String ab = <span class="string">"ab"</span>;</span><br><span class="line">		<span class="comment">//使用拼接字符串的方法创建字符串</span></span><br><span class="line">		String ab3 = <span class="string">"a"</span> + <span class="string">"b"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反编译后的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">     stack&#x3D;1, locals&#x3D;5, args_size&#x3D;1</span><br><span class="line">        0: ldc           #2                  &#x2F;&#x2F; String a</span><br><span class="line">        2: astore_1</span><br><span class="line">        3: ldc           #3                  &#x2F;&#x2F; String b</span><br><span class="line">        5: astore_2</span><br><span class="line">        6: ldc           #4                  &#x2F;&#x2F; String ab</span><br><span class="line">        8: astore_3</span><br><span class="line">        9: ldc           #4                  &#x2F;&#x2F; String ab</span><br><span class="line">       11: astore        4</span><br><span class="line">       13: return</span><br></pre></td></tr></table></figure>
<p>使用<strong>拼接字符串常量</strong>的方法来创建新的字符串时，因为<strong>内容是常量，javac在编译期会进行优化，结果已在编译期确定为ab</strong>，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接从串池中获取值，所以进行的操作和 ab = “ab” 一致。</p>
<h5 id="intern方法-在JDK1-8"><a href="#intern方法-在JDK1-8" class="headerlink" title="intern方法 在JDK1.8"></a>intern方法 在JDK1.8</h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p>
<ul>
<li>如果串池中没有该字符串对象，则放入成功</li>
<li>如果有该字符串对象，则放入失败</li>
</ul>
<p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p>
<p><strong>注意</strong>：此时如果调用intern方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</p>
<p><strong>例1</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//"a" "b" 被放入串池中，str则存在于堆内存之中</span></span><br><span class="line">		String str = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"b"</span>); <span class="comment">// 执行完这步,常量池中有 StringTable["a","b"]</span></span><br><span class="line">		<span class="comment">//调用str的intern方法，这时串池中没有"ab"，则会将该字符串对象放入到串池中，此时堆内存与串池中的"ab"是同一个对象</span></span><br><span class="line">		String st2 = str.intern();</span><br><span class="line">		<span class="comment">//给str3赋值，因为此时串池中已有"ab"，则直接将串池中的内容返回</span></span><br><span class="line">		String str3 = <span class="string">"ab"</span>;</span><br><span class="line">		<span class="comment">//因为堆内存与串池中的"ab"是同一个对象，所以以下两条语句打印的都为true</span></span><br><span class="line">		System.out.println(str == st2);</span><br><span class="line">		System.out.println(str == str3);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>例2</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//此处创建字符串对象"ab"，因为串池中还没有"ab"，所以将其放入串池中</span></span><br><span class="line">		String str3 = <span class="string">"ab"</span>;</span><br><span class="line">        <span class="comment">//"a" "b" 被放入串池中，str则存在于堆内存之中</span></span><br><span class="line">		String str = <span class="keyword">new</span> String(<span class="string">"a"</span>) + <span class="keyword">new</span> String(<span class="string">"b"</span>);</span><br><span class="line">        <span class="comment">//此时因为在创建str3时，"ab"已存在与串池中，所以放入失败，但是会返回串池中的"ab"</span></span><br><span class="line">		String str2 = str.intern();</span><br><span class="line">        <span class="comment">//false</span></span><br><span class="line">		System.out.println(str == str2);</span><br><span class="line">        <span class="comment">//false</span></span><br><span class="line">		System.out.println(str == str3);</span><br><span class="line">        <span class="comment">//true</span></span><br><span class="line">		System.out.println(str2 == str3);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="intern方法-在JDK1-6"><a href="#intern方法-在JDK1-6" class="headerlink" title="intern方法 在JDK1.6"></a>intern方法 在JDK1.6</h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p>
<ul>
<li>如果串池中没有该字符串对象，会将该字符串对象<strong>复制一份</strong>，再放入到串池中</li>
<li>如果有该字符串对象，则放入失败</li>
</ul>
<p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p>
<p><strong>注意</strong>：此时无论调用intern方法成功与否，串池中的字符串对象和堆内存中的字符串对象<strong>都不是同一个对象</strong></p>
<h4 id="StringTable-垃圾回收"><a href="#StringTable-垃圾回收" class="headerlink" title="StringTable 垃圾回收"></a>StringTable 垃圾回收</h4><p>StringTable在内存紧张时，会发生垃圾回收</p>
<h4 id="StringTable调优"><a href="#StringTable调优" class="headerlink" title="StringTable调优"></a>StringTable调优</h4><ul>
<li><p>因为StringTable是由HashTable实现的，所以可以<strong>适当增加HashTable桶的个数</strong>,来增加hash分布减少hash冲突，来减少字符串放入串池所需要的时间,提升效率.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:StringTableSize&#x3D;xxxx</span><br></pre></td></tr></table></figure>
</li>
<li><p>考虑是否需要将字符串对象入池</p>
<p>可以通过<strong>intern方法减少重复入池</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvn32afelyj61ai0fgdi302.jpg" alt="image-20211021175647538"></p>
</li>
</ul>
<h3 id="6、直接内存"><a href="#6、直接内存" class="headerlink" title="6、直接内存"></a>6、直接内存</h3><ul>
<li>属于操作系统，常见于NIO操作时，<strong>用于数据缓冲区</strong></li>
<li>分配回收成本较高，但读写性能高</li>
<li>不受JVM内存回收管理</li>
</ul>
<h4 id="文件读写流程"><a href="#文件读写流程" class="headerlink" title="文件读写流程"></a>文件读写流程</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150715.png" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn35uni3sj60w00n3gnn02.jpg" alt="img"></a></p>
<p><strong>使用了DirectBuffer</strong></p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150736.png" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvn8tfrkkij60x00ntwgq02.jpg" alt="img"></a></p>
<p>直接内存是操作系统和Java代码<strong>都可以访问的一块区域</strong>，无需将代码从系统内存复制到Java堆内存，从而提高了效率</p>
<h4 id="释放原理"><a href="#释放原理" class="headerlink" title="释放原理"></a>释放原理</h4><p>直接内存的回收不是通过JVM的垃圾回收来释放的，而是通过<strong>unsafe.freeMemory</strong>来手动释放</p>
<p>通过</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过ByteBuffer申请1M的直接内存</span></span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1M);</span><br></pre></td></tr></table></figure>
<p>申请直接内存，但JVM并不能回收直接内存中的内容，它是如何实现回收的呢？</p>
<p><strong>allocateDirect的实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);&#125;</span><br></pre></td></tr></table></figure>
<p>DirectByteBuffer类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DirectByteBuffer(<span class="keyword">int</span> cap) &#123;   <span class="comment">// package-private       super(-1, 0, cap, cap);    boolean pa = VM.isDirectMemoryPageAligned();    int ps = Bits.pageSize();    long size = Math.max(1L, (long)cap + (pa ? ps : 0));    Bits.reserveMemory(size, cap);    long base = 0;    try &#123;        base = unsafe.allocateMemory(size); //申请内存    &#125; catch (OutOfMemoryError x) &#123;        Bits.unreserveMemory(size, cap);        throw x;    &#125;    unsafe.setMemory(base, size, (byte) 0);    if (pa &amp;&amp; (base % ps != 0)) &#123;        // Round up to page boundary        address = base + ps - (base &amp; (ps - 1));    &#125; else &#123;        address = base;    &#125;    cleaner = Cleaner.create(this, new Deallocator(base, size, cap)); //通过虚引用，来实现直接内存的释放，this为虚引用的实际对象    att = null;&#125;</span></span><br></pre></td></tr></table></figure>
<p>这里调用了一个Cleaner的create方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象（这里是DirectByteBuffer）被回收以后，就会调用Cleaner的clean方法，来清除直接内存中占用的内存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span> </span>&#123;       <span class="keyword">if</span> (remove(<span class="keyword">this</span>)) &#123;           <span class="keyword">try</span> &#123;               <span class="keyword">this</span>.thunk.run(); <span class="comment">//调用run方法           &#125; catch (final Throwable var2) &#123;               AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;                   public Void run() &#123;                       if (System.err != null) &#123;                           (new Error("Cleaner terminated abnormally", var2)).printStackTrace();                       &#125;                       System.exit(1);                       return null;                   &#125;               &#125;);           &#125;</span></span><br></pre></td></tr></table></figure>
<p>对应对象的run方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;    <span class="keyword">if</span> (address == <span class="number">0</span>) &#123;        <span class="comment">// Paranoia        return;    &#125;    unsafe.freeMemory(address); //释放直接内存中占用的内存    address = 0;    Bits.unreserveMemory(size, capacity);&#125;</span></span><br></pre></td></tr></table></figure>
<h5 id="直接内存的回收机制总结"><a href="#直接内存的回收机制总结" class="headerlink" title="直接内存的回收机制总结"></a>直接内存的回收机制总结</h5><ul>
<li>使用了Unsafe类来完成直接内存的分配回收，回收需要主动调用freeMemory方法</li>
<li>ByteBuffer的实现内部使用了Cleaner（虚引用）来检测ByteBuffer。一旦ByteBuffer对象被GC 垃圾回收，那么会由ReferenceHandler来调用Cleaner的clean方法调用freeMemory来释放内存</li>
</ul>
<h4 id="禁止显示回收对直接内存的影响"><a href="#禁止显示回收对直接内存的影响" class="headerlink" title="禁止显示回收对直接内存的影响"></a>禁止显示回收对直接内存的影响</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.gc(); <span class="comment">// 显示的垃圾回收 Full GC,导致直接内存被回收</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+DisableExplicitGC 禁止显示回收命令,然后通过手动的 Unsafe.freeMemory(base);释放直接内存</span><br></pre></td></tr></table></figure>
<h2 id="三、垃圾回收"><a href="#三、垃圾回收" class="headerlink" title="三、垃圾回收"></a>三、垃圾回收</h2><h3 id="1、如何判断对象可以回收"><a href="#1、如何判断对象可以回收" class="headerlink" title="1、如何判断对象可以回收"></a>1、如何判断对象可以回收</h3><h4 id="引用计数法-Java没有使用"><a href="#引用计数法-Java没有使用" class="headerlink" title="引用计数法(Java没有使用)"></a>引用计数法(Java没有使用)</h4><p>弊端：循环引用时，两个对象的计数都为1，导致两个对象都无法被释放</p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150750.png" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvn8tbhaqfj60l008ywer02.jpg" alt="img"></a></p>
<h4 id="可达性分析算法-Java使用"><a href="#可达性分析算法-Java使用" class="headerlink" title="可达性分析算法(Java使用)"></a>可达性分析算法(Java使用)</h4><p><strong>Root对象(根对象)</strong>: 肯定不能被当成垃圾被回收的对象</p>
<ul>
<li><p>JVM中的垃圾回收器通过<strong>可达性分析</strong>来探索所有存活的对象</p>
</li>
<li><p>扫描堆中的对象，看能否沿着GC <strong>Root对象</strong>为起点的引用链找到该对象，如果<strong>找不到，则表示可以回收</strong></p>
</li>
<li><p>哪些对象可以作为GC Root的对象?</p>
<ul>
<li><p>System Class 系统类</p>
</li>
<li><p>Native Stack 本地方法栈中JNI（即一般说的Native方法）引用的对象</p>
</li>
<li><p>Thread 活动线程</p>
</li>
<li><p>Busy Monitor (在sychronized锁的引用)</p>
</li>
<li><p>虚拟机栈（栈帧中的本地变量表）中引用的对象。　</p>
</li>
<li><p>方法区中类静态属性引用的对象</p>
</li>
<li><p>方法区中常量引用的对象</p>
</li>
</ul>
</li>
</ul>
<h4 id="通过MAT工具查找根对象"><a href="#通过MAT工具查找根对象" class="headerlink" title="通过MAT工具查找根对象"></a>通过MAT工具查找根对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format&#x3D;b,live,file&#x3D;1.bin 21384 &#x2F;&#x2F; 通过jmap命令保存内存快照dump文件,通过eclipse 提供的MAT工具分析哪些是根对象</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvn5alovgyj60gt06x74u02.jpg" alt="image-20211021191405528"></p>
<h4 id="五种引用"><a href="#五种引用" class="headerlink" title="五种引用"></a>五种引用</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150800.png" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvn8t6vn20j60xo0gswh002.jpg" alt="img"></a></p>
<h5 id="强引用-实线"><a href="#强引用-实线" class="headerlink" title="强引用(实线)"></a>强引用(实线)</h5><ul>
<li><p>只有所有 GC Roots 对象都不通过【强引用】引用该对家，该对象才能被垃圾回收</p>
<p>如上图B、C对象都不引用A1对象时，A1对象才会被回收</p>
</li>
</ul>
<h5 id="软引用-虚线-SofReference"><a href="#软引用-虚线-SofReference" class="headerlink" title="软引用(虚线 ) (SofReference)"></a>软引用(虚线 ) (SofReference)</h5><ul>
<li>仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次触发拉圾回收，回收软引用对象</li>
<li>可以配合引用队列来释放软引用自身</li>
<li>如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收</li>
</ul>
<h6 id="软引用的使用-将jvm内存调小点-Xmx10M-为10M"><a href="#软引用的使用-将jvm内存调小点-Xmx10M-为10M" class="headerlink" title="软引用的使用(将jvm内存调小点: -Xmx10M 为10M)"></a>软引用的使用(将jvm内存调小点: -Xmx10M 为10M)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;		<span class="keyword">final</span> <span class="keyword">int</span> _4M = <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;    <span class="comment">// 软引用 SoftReference&lt;&gt;		List&lt;SoftReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();		for (int i = 0; i &lt; 5; i++)&#123;      SoftReference&lt;byte[]&gt; ref= new SoftReference&lt;&gt;(new byte[_4M]);      System.out.println(ref.get());      list.add(ref);      System.out.println(list.size());    &#125;        for(SoftReference&lt;byte[]&gt; reference : list)&#123;      System.out.println(reference.get());    &#125;	&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p>结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[B@5a39699c1[B@3cb5cdba2[B@56cbfb613[B@1134affc4[B@d041cf5nullnullnullnull[B@d041cf</span><br></pre></td></tr></table></figure>
<p>如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，<strong>软引用本身不会被清理</strong></p>
<p>如果想要<strong>清理软引用</strong>，需要使<strong>用引用队列</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    <span class="keyword">final</span> <span class="keyword">int</span> _4M = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;    List&lt;SoftReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();    <span class="comment">// 使用引用队列，用于移除引用为空的软引用对象    ReferenceQueue&lt;byte[]&gt; queue = new ReferenceQueue&lt;&gt;();    for (int i = 0; i &lt; 5; i++) &#123;      // 关联了引用队列,当软引用所关联的byte[]被回收时,软引用自己会加入到queue中去      SoftReference&lt;byte[]&gt; ref = new SoftReference&lt;&gt;(new byte[_4M], queue);      System.out.println(ref.get());      list.add(ref);      System.out.println(list.size());    &#125;    // 从队列中获取无用的 软引用对象,并移除    Reference&lt;? extends byte[]&gt; poll = queue.poll();    while (poll != null) &#123;      // 引用队列不为空，则从集合中移除该元素      list.remove(poll);      // 移动到引用队列中的下一个元素      poll = queue.poll();    &#125;    for (SoftReference&lt;byte[]&gt; reference : list) &#123;      System.out.println(reference.get());    &#125;  &#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p>结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[B@5a39699c1[B@3cb5cdba2[B@56cbfb613[B@1134affc4[B@d041cf5[B@d041cf</span><br></pre></td></tr></table></figure>
<p><strong>大概思路为：</strong>查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除（这里为一个list集合）</p>
<h5 id="弱引用-WeakReference"><a href="#弱引用-WeakReference" class="headerlink" title="弱引用(WeakReference)"></a>弱引用(WeakReference)</h5><ul>
<li>仅有弱引用引用该对象时，在垃圾回收后，<strong>无论内存是否充足</strong>，都会回收弱引用对象</li>
<li>可以配合引用队列来释放弱引用自身</li>
<li>如上图如果B对象不再引用A3对象，则A3对象会被回收</li>
<li><strong>弱引用的使用和软引用类似</strong>，只是将 <strong>SoftReference 换为了 WeakReference</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;		<span class="keyword">final</span> <span class="keyword">int</span> _4M = <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;    <span class="comment">// 软引用 SoftReference&lt;&gt;		List&lt;WeakReference&lt;byte[]&gt;&gt; list = new ArrayList&lt;&gt;();		for (int i = 0; i &lt; 5; i++)&#123;      WeakReference&lt;byte[]&gt; ref= new WeakReference&lt;&gt;(new byte[_4M]);      System.out.println(ref.get());      list.add(ref);      System.out.println(list.size());    &#125;	&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<h5 id="虚引用-PhantomReference"><a href="#虚引用-PhantomReference" class="headerlink" title="虚引用(PhantomReference)"></a><strong>虚引用</strong>(PhantomReference)</h5><ul>
<li>必须配合引用队列使用，主要配合ByteButfer使用,被引用对象回收时,会将虚引用入队，由Reference Hander 线程调用虛号引用相关方法释放直接内存</li>
<li>当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法</li>
<li>虚引用的一个体现是<strong>释放直接内存所分配的内存</strong>，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li>
<li>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</li>
</ul>
<h5 id="终结器引用-FinalReference"><a href="#终结器引用-FinalReference" class="headerlink" title="终结器引用(FinalReference)"></a>终结器引用(FinalReference)</h5><ul>
<li>无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收）再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 fnalize方法，第二次GC时才能回收被引用对象</li>
<li>所有的类都继承自Object类，Object类有一个finalize方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入引用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize方法。调用以后，该对象就可以被垃圾回收了</li>
<li>如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了</li>
</ul>
<h5 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h5><ul>
<li>软引用和弱引用<strong>可以配合</strong>引用队列<ul>
<li>在<strong>弱引用</strong>和<strong>虚引用</strong>所引用的对象被回收以后，会将这些引用放入引用队列中，方便一起回收这些软/弱引用对象</li>
</ul>
</li>
<li>虚引用和终结器引用<strong>必须配合</strong>引用队列<ul>
<li>虚引用和终结器引用在使用时会关联一个引用队列</li>
</ul>
</li>
</ul>
<h3 id="2、垃圾回收算法-jvm根据不同情况用到如下3种算法"><a href="#2、垃圾回收算法-jvm根据不同情况用到如下3种算法" class="headerlink" title="2、垃圾回收算法(jvm根据不同情况用到如下3种算法)"></a>2、垃圾回收算法(jvm根据不同情况用到如下3种算法)</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><blockquote>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn8swa3haj30cy04mgls.jpg" alt="image-20211021204941025" style="zoom:130%;" /></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvn83d01jbj60c003xq3002.jpg" alt="image-20211021205040430" style="zoom:150%;" /></p>
<p>这时并不会清理内存</p>
</blockquote>
<p><strong>定义</strong>：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间</p>
<ul>
<li>这里的腾出内存空间并不是将内存空间的字节清0，而是记录下这段内存的起始结束地址，下次分配内存的时候，会直接<strong>覆盖</strong>这段内存</li>
</ul>
<p><strong>缺点</strong>：<strong>容易产生大量的内存碎片</strong>，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢</p>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150827.png" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn8squifwj60x00fkwg502.jpg" alt="img"></a></p>
<p>标记-整理 会将不被GC Root引用的对象回收，清楚其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是因为整体需要消耗一定的时间，所以效率较低</p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150842.png" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn8soikitj60wt0h276502.jpg" alt="img"></a></p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150856.png" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn8sm2lxvj60xm0870tk02.jpg" alt="img"></a></p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150907.png" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn8sjsr8fj60xe08n3zb02.jpg" alt="img"></a></p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150919.png" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn8shh16lj60x6087aau02.jpg" alt="img"></a></p>
<p>将内存分为等大小的两个区域，FROM和TO（TO中为空）。先将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。然后交换FROM和TO。这样也可以避免内存碎片的问题，但是会占用双倍的内存空间。</p>
<h3 id="3、分代回收-代指老年代和新生代"><a href="#3、分代回收-代指老年代和新生代" class="headerlink" title="3、分代回收(代指老年代和新生代)"></a>3、分代回收(代指老年代和新生代)</h3><h4 id="堆内存的划分"><a href="#堆内存的划分" class="headerlink" title="堆内存的划分:"></a>堆内存的划分:</h4><p>长时间使用的对象放在老年代,而使用完就可以丢弃的对象放在新生代.</p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150931.png" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn8s9en4zj60xs07ngm602.jpg" alt="img"></a></p>
<h4 id="回收流程"><a href="#回收流程" class="headerlink" title="回收流程"></a>回收流程</h4><p>新创建的对象都被放在了<strong>新生代的伊甸园</strong>中</p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150939.png" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn8s57q6rj60x0080aao02.jpg" alt="img"></a></p>
<p>当伊甸园中的内存不足时，就会进行一次垃圾回收(使用标记算法)，这时的回收叫做 <strong>Minor GC(小的GC)</strong></p>
<p>Minor GC 会将<strong>伊甸园和幸存区FROM</strong>存活的对象<strong>先</strong>复制到 <strong>幸存区 TO</strong>中(使用复制算法)， 并让其<strong>寿命加1</strong>，再<strong>交换两个幸存区</strong></p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150946.png" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn8s3bm7hj60x90chdgx02.jpg" alt="img"></a></p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150955.png" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn8rzovawj30xe0ciwfm.jpg" alt="img"></a></p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151002.png" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn8rxo2plj60xw07taao02.jpg" alt="img"></a></p>
<p>再次创建对象，若新生代的伊甸园又满了，则会<strong>再次触发 Minor GC</strong>（会触发 <strong>stop the world</strong>， 暂停其他用户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾，<strong>还会回收幸存区中的垃圾</strong>，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象<strong>寿命加1</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn8royi24j61850aaq4702.jpg" alt="image-20211021211418679"></p>
<p>如果幸存区中的对象的<strong>寿命超过某个阈值</strong>（最大为15次垃圾回收，4bit）或幸存区空间紧张时，就会被<strong>放入老年代</strong>中</p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151018.png" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvn8upoylcj60xs07vq3k02.jpg" alt="img"></a></p>
<p>如果新生代老年代中的内存都满了，就会先触发Minor GC，如果空间仍不足,那么触发<strong>Full GC</strong>，STW(stop the world)的时间更长.扫描<strong>新生代和老年代中</strong>所有不再使用的对象并回收</p>
<h4 id="相关VM参数"><a href="#相关VM参数" class="headerlink" title="相关VM参数:"></a>相关VM参数:</h4><p><img src="/Users/chenyawei/Library/Application Support/typora-user-images/image-20211021213124900.png" alt="image-20211021213124900" style="zoom:150%;" /></p>
<h4 id="GC-分析和案例"><a href="#GC-分析和案例" class="headerlink" title="GC 分析和案例"></a>GC 分析和案例</h4><p>没有触发GC</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn9fyf2r3j612b0hen1h02.jpg" alt="image-20211021213737783"></p>
<p>触发了GC</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvn9lx09f3j61ei0ml0zg02.jpg" alt="image-20211021214321219"></p>
<h5 id="大对象处理策略"><a href="#大对象处理策略" class="headerlink" title="大对象处理策略"></a>大对象处理策略</h5><p>当遇到一个<strong>较大的对象</strong>时，就算新生代的<strong>伊甸园</strong>为空，也<strong>无法容纳该对象</strong>时，会将该对象<strong>直接晋升为老年代</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvn9r9jtkmj61200lptdz02.jpg" alt="image-20211021214829797"></p>
<h5 id="线程内存溢出"><a href="#线程内存溢出" class="headerlink" title="线程内存溢出"></a>线程内存溢出</h5><p>某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行</p>
<p>这是因为当一个线程<strong>抛出OOM异常后</strong>，<strong>它所占据的内存资源会全部被释放掉</strong>，从而不会影响其他线程的运行，<strong>进程依然正常</strong></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvn9udqytsj616i0nlq9r02.jpg" alt="image-20211021215127593"></p>
<h3 id="4、垃圾回收器"><a href="#4、垃圾回收器" class="headerlink" title="4、垃圾回收器"></a>4、垃圾回收器</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p><strong>并行收集</strong>：指多条垃圾收集线程并行工作，但此时<strong>用户线程仍处于等待状态</strong>。</p>
<p><strong>并发收集</strong>：指用户线程与垃圾收集线程<strong>同时工作</strong>（不一定是并行的可能会交替执行）。<strong>用户程序在继续运行</strong>，而垃圾收集程序运行在另一个CPU上</p>
<p><strong>吞吐量</strong>：即CPU用于<strong>运行用户代码的时间</strong>与CPU<strong>总消耗时间</strong>的比值（吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%</p>
<h4 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h4><blockquote>
<ul>
<li><p>单线程</p>
</li>
<li><p>堆内存较小，适合个人电脑（CPU核数较少）</p>
</li>
<li><p>开启串行垃圾回收器的JVM参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC &#x3D; Serial + SerialOld</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151027.png" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvncozymkwj60wi0b8ta102.jpg" alt="img"></a></p>
<p><strong>安全点</strong>：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象, 因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入<strong>阻塞</strong>状态</p>
<h5 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h5><p>Serial收集器是最基本的、发展历史最悠久的收集器</p>
<p><strong>特点：</strong>单线程、简单高效（与其他收集器的单线程相比），采用<strong>复制算法</strong>。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）</p>
<h5 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h5><p>ParNew收集器其实就是Serial收集器的多线程版本</p>
<p><strong>特点</strong>：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。和Serial收集器一样存在Stop The World问题</p>
<h5 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h5><p>SerialOld是Serial收集器的老年代版本</p>
<p><strong>特点</strong>：同样是单线程收集器，采用<strong>标记-整理算法</strong></p>
</blockquote>
<h4 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h4><blockquote>
<ul>
<li>多线程</li>
<li>堆内存较大，多核CPU</li>
<li><strong>单位时间内</strong>STW（stop the world，停掉其他所有工作线程）时间最短</li>
<li><strong>JDK1.8默认使用</strong>的垃圾回收器</li>
</ul>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151039.png" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvncoycxozj30vt0idq4v.jpg" alt="img"></a></p>
<h5 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h5><p>与吞吐量关系密切，故也称为吞吐量优先收集器</p>
<p><strong>特点</strong>：属于新生代收集器也是采用<strong>复制算法</strong>的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与ParNew收集器类似）</p>
<p>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：<strong>GC自适应调节策略</strong>（与ParNew收集器最重要的一个区别）</p>
<p><strong>GC自适应调节策略</strong>：Parallel Scavenge收集器可设置-XX:+UseAdptiveSizePolicy参数。当开关打开时<strong>不需要</strong>手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。</p>
<p>Parallel Scavenge收集器使用两个参数控制吞吐量：</p>
<ul>
<li>-XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间</li>
<li>-XX:GCTimeRatio 直接设置吞吐量的大小</li>
</ul>
<h5 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a><strong>Parallel Old 收集器</strong></h5><p>是Parallel Scavenge收集器的老年代版本</p>
<p><strong>特点</strong>：多线程，采用<strong>标记-整理算法</strong>（老年代没有幸存区）</p>
</blockquote>
<h4 id="响应时间优先-CMS"><a href="#响应时间优先-CMS" class="headerlink" title="响应时间优先(CMS)"></a>响应时间优先(CMS)</h4><blockquote>
<ul>
<li>多线程</li>
<li>堆内存较大，多核CPU</li>
<li>尽可能让<strong>单次</strong>STW时间最短（尽量不影响其他线程运行）</li>
</ul>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151052.png" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvncpjs5h2j60wf0futau02.jpg" alt="img"></a></p>
<h5 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h5><p>Concurrent Mark Sweep，一种以获取<strong>最短回收停顿时间</strong>为目标的<strong>老年代</strong>收集器</p>
<p><strong>特点</strong>：基于<strong>标记-清除算法</strong>实现。并发收集、低停顿，但是会产生内存碎片</p>
<p><strong>应用场景</strong>：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b/s服务</p>
<p><strong>CMS收集器的运行过程分为下列4步：</strong></p>
<p><strong>初始标记</strong>：标记GC Roots能直接到的对象。速度很快但是<strong>仍存在Stop The World问题</strong></p>
<p><strong>并发标记</strong>：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行</p>
<p><strong>重新标记</strong>：为了<strong>修正并发标记期间</strong>因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题</p>
<p><strong>并发清除</strong>：对标记的对象进行清除回收</p>
<p>CMS收集器的内存回收过程是与用户线程一起<strong>并发执行</strong>的</p>
</blockquote>
<h4 id="G1-Garbage-First"><a href="#G1-Garbage-First" class="headerlink" title="G1(Garbage First)"></a>G1(Garbage First)</h4><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义</strong>：</h5><p>Garbage First (也是一种垃圾回收器)</p>
<p>JDK 9以后默认使用，而且替代了CMS 收集器</p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200909201212.png" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvndk93j23j60fn051dg702.jpg" alt="img"></a></p>
<h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul>
<li>同时注重吞吐量和低延迟（响应时间）</li>
<li>超大堆内存（内存大的），会将堆内存划分为多个<strong>大小相等</strong>的区域</li>
<li>整体上是<strong>标记-整理</strong>算法，两个区域之间是<strong>复制</strong>算法</li>
</ul>
<p><strong>相关参数</strong>：JDK8 并不是默认开启的，所需要参数开启</p>
<p>[<img src="https://tva1.sinaimg.cn/large/008i3skNly1gvndkbryfwj60f808pjrm02.jpg" alt="img"></p>
<h5 id="G1垃圾回收阶段"><a href="#G1垃圾回收阶段" class="headerlink" title="G1垃圾回收阶段"></a>G1垃圾回收阶段</h5><p>[<img src="https://tva1.sinaimg.cn/large/008i3skNly1gvndknbga3j60s50my76g02.jpg" alt="img"></p>
<p>新生代伊甸园垃圾回收—–&gt;内存不足，新生代回收+并发标记—–&gt;混合收集:回收新生代伊甸园、幸存区、老年代内存——&gt;新生代伊甸园垃圾回收(重新开始)</p>
<h5 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a>Young Collection</h5><blockquote>
<p><strong>分区算法region</strong></p>
<p>分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间</p>
<p>E：伊甸园 S：幸存区 O：老年代</p>
<ul>
<li>会STW</li>
</ul>
<p>新生代满了:</p>
<p>[<img src="https://tva1.sinaimg.cn/large/008i3skNly1gvndrsccq7j30ry0kjabi.jpg" alt="img"></p>
<p>新生代晋升到幸存区:</p>
<p>[<img src="https://tva1.sinaimg.cn/large/008i3skNly1gvndszw0msj60rz0l2abl02.jpg" alt="img"></p>
<p>幸存区晋升到老年区:</p>
<p>[<img src="https://tva1.sinaimg.cn/large/008i3skNly1gvndt168y1j60rt0kltaf02.jpg" alt="img"></p>
</blockquote>
<h5 id="Young-Collection-CM"><a href="#Young-Collection-CM" class="headerlink" title="Young Collection + CM"></a>Young Collection + CM</h5><blockquote>
<p>CM：并发标记</p>
<ul>
<li>在 Young GC 时会<strong>对 GC Root 进行初始标记</strong></li>
<li>在老年代<strong>占用堆内存的比例</strong>达到阈值时，对进行并发标记（不会STW），阈值可以根据用户来进行设定</li>
</ul>
<p>[<img src="https://tva1.sinaimg.cn/large/008i3skNly1gvndz8n071j60rg0kewg802.jpg" alt="img"></p>
</blockquote>
<h5 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h5><blockquote>
<p>会对E S O 进行<strong>全面的回收</strong></p>
<ul>
<li>最终标记 会STW</li>
<li><strong>拷贝</strong>存活 会STW</li>
</ul>
<p>-XX:MaxGCPauseMills:xxx 用于指定最长的停顿时间</p>
<p><strong>问</strong>：为什么有的老年代被拷贝了，有的没拷贝？</p>
<p>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会<strong>回收最有价值的老年代</strong>（回收后，能够得到更多内存）</p>
<p>[<img src="https://tva1.sinaimg.cn/large/008i3skNly1gvne04hyrrj60rj0mc40v02.jpg" alt="img"></p>
</blockquote>
<h5 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h5><blockquote>
<ul>
<li>G1在老年代内存不足时（老年代所占内存超过阈值）</li>
<li>如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理</li>
<li>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC</li>
</ul>
</blockquote>
<h5 id="Young-Collection-跨代引用"><a href="#Young-Collection-跨代引用" class="headerlink" title="Young Collection 跨代引用"></a>Young Collection 跨代引用</h5><blockquote>
<ul>
<li>新生代回收的跨代引用（老年代引用新生代）问题</li>
</ul>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151211.png" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvnejhpso7j30y10gfabz.jpg" alt="img"></a></p>
<ul>
<li>卡表与Remembered Set<ul>
<li>Remembered Set 存在于E中，用于保存新生代对象对应的脏卡<ul>
<li>脏卡：O被划分为多个区域（一个区域512K），如果该区域引用了新生代对象，则该区域被称为脏卡</li>
</ul>
</li>
</ul>
</li>
<li>在引用变更时通过post-write barried + dirty card queue</li>
<li>concurrent refinement threads 更新 Remembered Set</li>
</ul>
<p>[<img src="https://tva1.sinaimg.cn/large/008i3skNly1gvnejjewrpj60wo0j441302.jpg" alt="img"></p>
<h5 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h5></blockquote>
<h4 id="Remark"><a href="#Remark" class="headerlink" title="Remark"></a>Remark</h4><p>重新标记阶段</p>
<p>在垃圾回收时，收集器处理对象的过程中</p>
<p>黑色：已被处理，需要保留的 灰色：正在处理中的 白色：还未处理的</p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151229.png" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvntvzlovij60tr0em0tm02.jpg" alt="img"></a></p>
<p>但是在<strong>并发标记过程中</strong>，有可能A被处理了以后未引用C，但该处理过程还未结束，在处理过程结束之前A引用了C，这时就会用到remark</p>
<p>过程如下</p>
<ul>
<li>之前C未被引用，这时A引用了C，就会给C加一个写屏障，写屏障的指令会被执行，将C放入一个队列当中，并将C变为 处理中 状态</li>
<li>在<strong>并发标记</strong>阶段结束以后，重新标记阶段会STW，然后将放在该队列中的对象重新处理，发现有强引用引用它，就会处理它</li>
</ul>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151239.png" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvntvwdyqnj60v60j4abb02.jpg" alt="img"></a></p>
<h5 id="JDK-8u20-字符串去重"><a href="#JDK-8u20-字符串去重" class="headerlink" title="JDK 8u20 字符串去重"></a>JDK 8u20 字符串去重</h5><p>过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"hello"</span>); <span class="comment">// char["h","e","l","l","o"]String s2 = new String("hello"); // char["h","e","l","l","o"]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseStringDeduplication</span><br></pre></td></tr></table></figure>
<ul>
<li>将所有新分配的字符串（底层是char[]）放入一个队列</li>
<li>当新生代回收时，G1并发检查是否有重复的字符串</li>
<li>如果字符串的值一样，就让他们<strong>引用同一个字符串对象</strong></li>
<li>注意，其与String.intern()的区别<ul>
<li>intern()关注的是字符串对象</li>
<li>字符串去重关注的是char[]数组</li>
<li>在JVM内部，使用了不同的字符串标</li>
</ul>
</li>
</ul>
<p>优点与缺点</p>
<ul>
<li>节省了大量内存</li>
<li>新生代回收时间略微增加，导致略微多占用CPU</li>
</ul>
<h5 id="JDK-8u40-并发标记类卸载"><a href="#JDK-8u40-并发标记类卸载" class="headerlink" title="JDK 8u40 并发标记类卸载"></a>JDK 8u40 并发标记类卸载</h5><p>在并发标记阶段结束以后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所加载的所有类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+ClassUnloadingWithConcurrentMart 默认启用</span><br></pre></td></tr></table></figure>
<h5 id="JDK-8u60-回收巨型对象"><a href="#JDK-8u60-回收巨型对象" class="headerlink" title="JDK 8u60 回收巨型对象"></a>JDK 8u60 回收巨型对象</h5><ul>
<li>一个对象大于region的一半时，就称为巨型对象</li>
<li>G1不会对巨型对象进行拷贝</li>
<li>回收时被优先考虑</li>
<li>G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉</li>
</ul>
<p>[<img src="https://tva1.sinaimg.cn/large/008i3skNly1gvnufqyn7lj60wt0hngo102.jpg" alt="img"></p>
<h4 id="JDK-9-并发标记起始时间的调整"><a href="#JDK-9-并发标记起始时间的调整" class="headerlink" title="JDK 9 并发标记起始时间的调整"></a>JDK 9 并发标记起始时间的调整</h4><ul>
<li><p>并发标记必须在堆空间占满前完成,否则退化为FullGC</p>
</li>
<li><p>JDK 9 之前需要使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:InitiatingHeapOccupancyPercent  &#x2F;&#x2F;默认为45% ,超过这个阈值的时候并发回收就开始</span><br></pre></td></tr></table></figure>
</li>
<li><p>JDK 9 可以动态调整(避免并发的垃圾回收退化为FullGC)</p>
<blockquote>
<p>-XX:InitiatingHeapOccupancyPercent 用来设置初始值</p>
<p>进行数据采样并动态调整</p>
<p>总会添加一个安全的空档空间 </p>
</blockquote>
</li>
</ul>
<p>G1官方调优指南:  <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/</a></p>
<h3 id="5、GC-调优"><a href="#5、GC-调优" class="headerlink" title="5、GC 调优"></a>5、GC 调优</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvnvvyq1o2j60br03dq2y02.jpg" alt="image-20211022103412095"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;docs.oracle.com&#x2F;en&#x2F;java&#x2F;javase&#x2F;11&#x2F;tools&#x2F;java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE 官方文档</span><br></pre></td></tr></table></figure>
<p>查看虚拟机运行参数命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;F:\JAVA\JDK8.0\bin\java&quot; -XX:+PrintFlagsFinal -version | findstr &quot;GC&quot;  &#x2F;&#x2F; windows</span><br><span class="line">java -XX:+PrintFlagsFinal -version |grep &quot;GC&quot;                           &#x2F;&#x2F; linux</span><br></pre></td></tr></table></figure>
<p>可以根据参数去查询具体的信息</p>
<h4 id="调优领域"><a href="#调优领域" class="headerlink" title="调优领域"></a>调优领域</h4><ul>
<li>内存</li>
<li>锁竞争</li>
<li>CPU占用</li>
<li>IO</li>
<li>GC</li>
</ul>
<h4 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h4><p>低延迟/高吞吐量？ 选择合适的GC</p>
<ul>
<li>CMS, G1, ZGC (低延时)</li>
<li>ParallelGC (高吞吐量)</li>
<li>Zing</li>
</ul>
<h4 id="最快的GC是不发生GC"><a href="#最快的GC是不发生GC" class="headerlink" title="最快的GC是不发生GC"></a>最快的GC是不发生GC</h4><p>首先排除减少因为自身编写的代码而引发的内存问题</p>
<ul>
<li>查看Full GC前后的内存占用，考虑以下几个问题<ul>
<li>数据是不是太多？</li>
<li>数据表示是否太臃肿<ul>
<li>对象图</li>
<li>对象大小</li>
</ul>
</li>
<li>是否存在内存泄漏</li>
</ul>
</li>
</ul>
<h4 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a>新生代调优</h4><ul>
<li><p>新生代的特点</p>
<ul>
<li>所有的new操作分配内存都是非常廉价的<ul>
<li>TLAB thread-local allocation buffer</li>
</ul>
</li>
<li>死亡对象回收零代价</li>
<li>大部分对象用过即死（朝生夕死）</li>
<li>MInor GC 所用时间远小于Full GC</li>
</ul>
</li>
<li><p>新生代内存越大越好么？</p>
<p>  -Xmn </p>
<ul>
<li>不是<ul>
<li>新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降</li>
<li>新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长</li>
</ul>
</li>
<li>新生代内存设置为内容纳[并发量*(请求-响应)]的数据为宜,官方建议新时代占有整个堆[25%到50%]</li>
</ul>
</li>
</ul>
<h4 id="幸存区调优"><a href="#幸存区调优" class="headerlink" title="幸存区调优"></a>幸存区调优</h4><ul>
<li><p>幸存区需要能够保存 <strong>当前活跃对象</strong>+<strong>需要晋升的对象</strong></p>
</li>
<li><p>晋升阈值配置得当，让长时间存活的对象尽快晋升</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxTenuringThreshold&#x3D;threshold  &#x2F;&#x2F;最大晋升阈值,适当的调小点-XX:+PrintTenuringDisTribution &#x2F;&#x2F; 打印不同空间内存占用情况</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="老年代调优"><a href="#老年代调优" class="headerlink" title="老年代调优"></a>老年代调优</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvnx263ajvj60ci03waa902.jpg" alt="image-20211022111446451"></p>
<h4 id="案例1-Full-GC-和-Minor-GC频繁"><a href="#案例1-Full-GC-和-Minor-GC频繁" class="headerlink" title="案例1: Full GC 和 Minor GC频繁"></a>案例1: Full GC 和 Minor GC频繁</h4><p>频繁GC说明空间紧张, 伊甸园和幸存空间小,导致频繁晋升到老年代; 先增大新生代内存,增大幸存区空间和调大晋升阈值,让生命周期较短的对象尽可能的留在新生代,而不要晋升到老年代.</p>
<h4 id="案例2-请求高峰期发生Full-GC-单次暂停时间特别长-CMS"><a href="#案例2-请求高峰期发生Full-GC-单次暂停时间特别长-CMS" class="headerlink" title="案例2: 请求高峰期发生Full GC,单次暂停时间特别长(CMS)"></a>案例2: 请求高峰期发生Full GC,单次暂停时间特别长(CMS)</h4><p>因为要求低延迟,选择了CMS垃圾回收器. 比较慢的重新标记会扫描新生代和老年代,如果对象比较多消耗cup就高.可以在重新标记前先做一次新生代的垃圾回收,减少新生代的数量,从而减少重新标记的数量.</p>
<p>通过设置参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+CMSScavengeBeforeRemark &#x2F;&#x2F; 开关打开</span><br></pre></td></tr></table></figure>
<h4 id="案例3-老年代充裕情况下-发生Full-GC-CMS-jdk1-7"><a href="#案例3-老年代充裕情况下-发生Full-GC-CMS-jdk1-7" class="headerlink" title="案例3: 老年代充裕情况下,发生Full GC(CMS jdk1.7)"></a>案例3: 老年代充裕情况下,发生Full GC(CMS jdk1.7)</h4><p>jdk1.7的方法区采用的是永久代,永久代的空间不足也会导致Full GC</p>
<h2 id="四、类加载与字节码技术"><a href="#四、类加载与字节码技术" class="headerlink" title="四、类加载与字节码技术"></a>四、类加载与字节码技术</h2><p>[<img src="https://tva1.sinaimg.cn/large/008i3skNly1gvnxtftqs5j60wv0fswg702.jpg" alt="img"></p>
<h3 id="1、类文件结构"><a href="#1、类文件结构" class="headerlink" title="1、类文件结构"></a>1、类文件结构</h3><p>首先获得.class字节码文件</p>
<p>方法：</p>
<ul>
<li><p>实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HelloWorld 示例public class HelloWorld &#123;  public static void main(String[] args) &#123;    System.out.println("hello world");  &#125;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>java终端中，执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -parameters -d . Helloworld.java   &#x2F;&#x2F; 编译为.class文件</span><br></pre></td></tr></table></figure>
<p>-parameters 打印出方法的参数</p>
</li>
<li><p>以下是字节码文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">od -t xC Helloworld.class  &#x2F;&#x2F; 查看二进制文件</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000000    ca  fe  ba  be  00  00  00  37  00  1f  0a  00  06  00  11  090000020    00  12  00  13  08  00  14  0a  00  15  00  16  07  00  17  070000040    00  18  01  00  06  3c  69  6e  69  74  3e  01  00  03  28  290000060    56  01  00  04  43  6f  64  65  01  00  0f  4c  69  6e  65  4e0000100    75  6d  62  65  72  54  61  62  6c  65  01  00  04  6d  61  690000120    6e  01  00  16  28  5b  4c  6a  61  76  61  2f  6c  61  6e  670000140    2f  53  74  72  69  6e  67  3b  29  56  01  00  10  4d  65  740000160    68  6f  64  50  61  72  61  6d  65  74  65  72  73  01  00  040000200    61  72  67  73  01  00  0a  53  6f  75  72  63  65  46  69  6c0000220    65  01  00  0f  48  65  6c  6c  6f  77  6f  72  6c  64  2e  6a0000240    61  76  61  0c  00  07  00  08  07  00  19  0c  00  1a  00  1b0000260    01  00  0b  68  65  6c  6c  6f  20  77  6f  72  6c  64  07  000000300    1c  0c  00  1d  00  1e  01  00  0a  48  65  6c  6c  6f  77  6f0000320    72  6c  64  01  00  10  6a  61  76  61  2f  6c  61  6e  67  2f0000340    4f  62  6a  65  63  74  01  00  10  6a  61  76  61  2f  6c  610000360    6e  67  2f  53  79  73  74  65  6d  01  00  03  6f  75  74  010000400    00  15  4c  6a  61  76  61  2f  69  6f  2f  50  72  69  6e  740000420    53  74  72  65  61  6d  3b  01  00  13  6a  61  76  61  2f  690000440    6f  2f  50  72  69  6e  74  53  74  72  65  61  6d  01  00  070000460    70  72  69  6e  74  6c  6e  01  00  15  28  4c  6a  61  76  610000500    2f  6c  61  6e  67  2f  53  74  72  69  6e  67  3b  29  56  000000520    21  00  05  00  06  00  00  00  00  00  02  00  01  00  07  000000540    08  00  01  00  09  00  00  00  1d  00  01  00  01  00  00  000000560    05  2a  b7  00  01  b1  00  00  00  01  00  0a  00  00  00  060000600    00  01  00  00  00  08  00  09  00  0b  00  0c  00  02  00  090000620    00  00  00  25  00  02  00  01  00  00  00  09  b2  00  02  120000640    03  b6  00  04  b1  00  00  00  01  00  0a  00  00  00  0a  000000660    02  00  00  00  0a  00  08  00  0b  00  0d  00  00  00  05  010000700    00  0e  00  00  00  01  00  0f  00  00  00  02  00  100000716</span><br></pre></td></tr></table></figure>
<p>根据 JVM 规范，<strong>类文件结构</strong>如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u4 			 magicu2             minor_version;    u2             major_version;    u2             constant_pool_count;    cp_info        constant_pool[constant_pool_count-1];    u2             access_flags;    u2             this_class;    u2             super_class;   u2             interfaces_count;    u2             interfaces[interfaces_count];   u2             fields_count;    field_info     fields[fields_count];   u2             methods_count;    method_info    methods[methods_count];    u2             attributes_count;    attribute_info attributes[attributes_count];</span><br></pre></td></tr></table></figure>
<h4 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h4><p>u4 magic</p>
<p>对应字节码文件的0~3个字节</p>
<p>0000000 <strong>ca fe ba be</strong> 00 00 00 34 00 23 0a 00 06 00 15 09</p>
<h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>u2 minor_version;</p>
<p>u2 major_version;</p>
<p>0000000 ca fe ba be <strong>00 00 00 34</strong> 00 23 0a 00 06 00 15 09</p>
<p>16进制:  00 00 00 34 = 52，代表JDK8</p>
<h4 id="常量池-1"><a href="#常量池-1" class="headerlink" title="常量池"></a>常量池</h4><p>见资料文件 </p>
<p> <a href="../资料 解密JVM/笔记/3_类加载与字节码技术.pdf">3_类加载与字节码技术.pdf</a> </p>
<h3 id="2、字节码指令"><a href="#2、字节码指令" class="headerlink" title="2、字节码指令"></a>2、字节码指令</h3><p>可参考:</p>
<p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5</a></p>
<h4 id="javap工具"><a href="#javap工具" class="headerlink" title="javap工具"></a>javap工具</h4><p>Oracle 提供了 <strong>javap</strong> 工具来反编译 class 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v F:\Thread_study\src\com\nyima\JVM\day01\Main.classCopyF:\Thread_study&gt;javap -v F:\Thread_study\src\com\nyima\JVM\day5\Demo1.classClassfile &#x2F;F:&#x2F;Thread_study&#x2F;src&#x2F;com&#x2F;nyima&#x2F;JVM&#x2F;day5&#x2F;Demo1.class  Last modified 2020-6-6; size 434 bytes  MD5 checksum df1dce65bf6fb0b4c1de318051f4a67e  Compiled from &quot;Demo1.java&quot;public class com.nyima.JVM.day5.Demo1  minor version: 0  major version: 52  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #1 &#x3D; Methodref          #6.#15         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V   #2 &#x3D; Fieldref           #16.#17        &#x2F;&#x2F; java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;   #3 &#x3D; String             #18            &#x2F;&#x2F; hello world   #4 &#x3D; Methodref          #19.#20        &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V   #5 &#x3D; Class              #21            &#x2F;&#x2F; com&#x2F;nyima&#x2F;JVM&#x2F;day5&#x2F;Demo1   #6 &#x3D; Class              #22            &#x2F;&#x2F; java&#x2F;lang&#x2F;Object   #7 &#x3D; Utf8               &lt;init&gt;   #8 &#x3D; Utf8               ()V   #9 &#x3D; Utf8               Code  #10 &#x3D; Utf8               LineNumberTable  #11 &#x3D; Utf8               main  #12 &#x3D; Utf8               ([Ljava&#x2F;lang&#x2F;String;)V  #13 &#x3D; Utf8               SourceFile  #14 &#x3D; Utf8               Demo1.java  #15 &#x3D; NameAndType        #7:#8          &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:()V  #16 &#x3D; Class              #23            &#x2F;&#x2F; java&#x2F;lang&#x2F;System  #17 &#x3D; NameAndType        #24:#25        &#x2F;&#x2F; out:Ljava&#x2F;io&#x2F;PrintStream;  #18 &#x3D; Utf8               hello world  #19 &#x3D; Class              #26            &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream  #20 &#x3D; NameAndType        #27:#28        &#x2F;&#x2F; println:(Ljava&#x2F;lang&#x2F;String;)V  #21 &#x3D; Utf8               com&#x2F;nyima&#x2F;JVM&#x2F;day5&#x2F;Demo1  #22 &#x3D; Utf8               java&#x2F;lang&#x2F;Object  #23 &#x3D; Utf8               java&#x2F;lang&#x2F;System  #24 &#x3D; Utf8               out  #25 &#x3D; Utf8               Ljava&#x2F;io&#x2F;PrintStream;  #26 &#x3D; Utf8               java&#x2F;io&#x2F;PrintStream  #27 &#x3D; Utf8               println  #28 &#x3D; Utf8               (Ljava&#x2F;lang&#x2F;String;)V&#123;  public com.nyima.JVM.day5.Demo1();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack&#x3D;1, locals&#x3D;1, args_size&#x3D;1         0: aload_0         1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V         4: return      LineNumberTable:        line 7: 0  public static void main(java.lang.String[]);    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack&#x3D;2, locals&#x3D;1, args_size&#x3D;1         0: getstatic     #2                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;         3: ldc           #3                  &#x2F;&#x2F; String hello world         5: invokevirtual #4                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V         8: return      LineNumberTable:        line 9: 0        line 10: 8&#125;</span><br></pre></td></tr></table></figure>
<h4 id="图解方法执行流程"><a href="#图解方法执行流程" class="headerlink" title="图解方法执行流程"></a>图解方法执行流程</h4><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3_1</span> </span>&#123;    	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        		<span class="keyword">int</span> a = <span class="number">10</span>;        		<span class="keyword">int</span> b = Short.MAX_VALUE + <span class="number">1</span>;        		<span class="keyword">int</span> c = a + b;        		System.out.println(c);       &#125; &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Classfile &#x2F;Users&#x2F;chenyawei&#x2F;Demo3_1.class  Last modified 2021年10月22日; size 469 bytes  MD5 checksum a77f40aa3caa0f068113c409b9e85e60  Compiled from &quot;Demo3_1.java&quot;public class Demo3_1  minor version: 0  major version: 55  flags: (0x0021) ACC_PUBLIC, ACC_SUPER  this_class: #6                          &#x2F;&#x2F; Demo3_1  super_class: #7                         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object  interfaces: 0, fields: 0, methods: 2, attributes: 1Constant pool:   #1 &#x3D; Methodref          #7.#18         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V   #2 &#x3D; Class              #19            &#x2F;&#x2F; java&#x2F;lang&#x2F;Short   #3 &#x3D; Integer            32768   #4 &#x3D; Fieldref           #20.#21        &#x2F;&#x2F; java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;   #5 &#x3D; Methodref          #22.#23        &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream.println:(I)V   #6 &#x3D; Class              #24            &#x2F;&#x2F; Demo3_1   #7 &#x3D; Class              #25            &#x2F;&#x2F; java&#x2F;lang&#x2F;Object   #8 &#x3D; Utf8               &lt;init&gt;   #9 &#x3D; Utf8               ()V  #10 &#x3D; Utf8               Code  #11 &#x3D; Utf8               LineNumberTable  #12 &#x3D; Utf8               main  #13 &#x3D; Utf8               ([Ljava&#x2F;lang&#x2F;String;)V  #14 &#x3D; Utf8               MethodParameters  #15 &#x3D; Utf8               args  #16 &#x3D; Utf8               SourceFile  #17 &#x3D; Utf8               Demo3_1.java  #18 &#x3D; NameAndType        #8:#9          &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:()V  #19 &#x3D; Utf8               java&#x2F;lang&#x2F;Short  #20 &#x3D; Class              #26            &#x2F;&#x2F; java&#x2F;lang&#x2F;System  #21 &#x3D; NameAndType        #27:#28        &#x2F;&#x2F; out:Ljava&#x2F;io&#x2F;PrintStream;  #22 &#x3D; Class              #29            &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream  #23 &#x3D; NameAndType        #30:#31        &#x2F;&#x2F; println:(I)V  #24 &#x3D; Utf8               Demo3_1  #25 &#x3D; Utf8               java&#x2F;lang&#x2F;Object  #26 &#x3D; Utf8               java&#x2F;lang&#x2F;System  #27 &#x3D; Utf8               out  #28 &#x3D; Utf8               Ljava&#x2F;io&#x2F;PrintStream;  #29 &#x3D; Utf8               java&#x2F;io&#x2F;PrintStream  #30 &#x3D; Utf8               println  #31 &#x3D; Utf8               (I)V&#123;  public Demo3_1();    descriptor: ()V    flags: (0x0001) ACC_PUBLIC    Code:      stack&#x3D;1, locals&#x3D;1, args_size&#x3D;1         0: aload_0         1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V         4: return      LineNumberTable:        line 1: 0  public static void main(java.lang.String[]);    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V    flags: (0x0009) ACC_PUBLIC, ACC_STATIC    Code:      stack&#x3D;2, locals&#x3D;4, args_size&#x3D;1         0: bipush        10         2: istore_1         3: ldc           #3                  &#x2F;&#x2F; int 32768         5: istore_2         6: iload_1         7: iload_2         8: iadd         9: istore_3        10: getstatic     #4                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;        13: iload_3        14: invokevirtual #5                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(I)V        17: return      LineNumberTable:        line 3: 0        line 4: 3        line 5: 6        line 6: 10        line 7: 17    MethodParameters:      Name                           Flags      args&#125;SourceFile: &quot;Demo3_1.java&quot;</span><br></pre></td></tr></table></figure>
<p><strong>常量池载入运行时常量池</strong></p>
<p>常量池也属于方法区，只不过这里单独提出来了</p>
<p>[<img src="https://tva1.sinaimg.cn/large/008i3skNly1gvo3n7rpcdj60x00dcaar02.jpg" alt="img"></p>
<p><strong>方法字节码载入方法区</strong></p>
<p>（stack=2，locals=4） 对应操作数栈有2个空间（每个空间4个字节），局部变量表中有4个槽位</p>
<p>[<img src="https://tva1.sinaimg.cn/large/008i3skNly1gvo3navd7wj60x20cvjsi02.jpg" alt="img"></p>
<p><strong>执行引擎开始执行字节码</strong></p>
<p><strong>bipush 10</strong></p>
<ul>
<li><p>将一个 byte 压入操作数栈</p>
<p>（其长度会补齐 4 个字节），类似的指令还有</p>
<ul>
<li>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</li>
<li>ldc 将一个 int 压入操作数栈</li>
<li>ldc2_w 将一个 long 压入操作数栈（<strong>分两次压入</strong>，因为 long 是 8 个字节）</li>
<li>这里小的数字都是和字节码指令存在一起，<strong>超过 short 范围的数字存入了常量池</strong></li>
</ul>
</li>
</ul>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151336.png" target="_blank" rel="noopener"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151336.png" alt="img"></a></p>
<p><strong>istore 1</strong></p>
<p>将操作数栈栈顶元素弹出，放入局部变量表的slot 1中</p>
<p>对应代码中的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; 10</span><br></pre></td></tr></table></figure>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151346.png" target="_blank" rel="noopener"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151346.png" alt="img"></a></p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151412.png" target="_blank" rel="noopener"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151412.png" alt="img"></a></p>
<p><strong>ldc #3</strong></p>
<p>读取运行时常量池中#3，即32768(超过short最大值范围的数会被放到运行时常量池中)，将其加载到操作数栈中</p>
<p>注意 Short.MAX_VALUE 是 32767，所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算好的</p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151421.png" target="_blank" rel="noopener"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151421.png" alt="img"></a></p>
<p><strong>istore 2</strong></p>
<p>将操作数栈中的元素弹出，放到局部变量表的2号位置</p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151432.png" target="_blank" rel="noopener"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151432.png" alt="img"></a></p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151441.png" target="_blank" rel="noopener"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151441.png" alt="img"></a></p>
<p><strong>iload1 iload2</strong></p>
<p>将局部变量表中1号位置和2号位置的元素放入操作数栈中</p>
<ul>
<li>因为只能在操作数栈中执行运算操作</li>
</ul>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151450.png" target="_blank" rel="noopener"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151450.png" alt="img"></a></p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151459.png" target="_blank" rel="noopener"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151459.png" alt="img"></a></p>
<p><strong>iadd</strong></p>
<p>将操作数栈中的两个元素<strong>弹出栈</strong>并相加，结果在压入操作数栈中</p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151508.png" target="_blank" rel="noopener"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151508.png" alt="img"></a></p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151523.png" target="_blank" rel="noopener"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151523.png" alt="img"></a></p>
<p><strong>istore 3</strong></p>
<p>将操作数栈中的元素弹出，放入局部变量表的3号位置</p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151547.png" target="_blank" rel="noopener"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151547.png" alt="img"></a></p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151555.png" target="_blank" rel="noopener"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151555.png" alt="img"></a></p>
<p><strong>getstatic #4</strong></p>
<p>在运行时常量池中找到#4，发现是一个对象</p>
<p>在堆内存中找到该对象，并将其<strong>引用</strong>放入操作数栈中</p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151605.png" target="_blank" rel="noopener"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151605.png" alt="img"></a></p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151613.png" target="_blank" rel="noopener"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151613.png" alt="img"></a></p>
<p><strong>iload 3</strong></p>
<p>将局部变量表中3号位置的元素压入操作数栈中</p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151624.png" target="_blank" rel="noopener"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151624.png" alt="img"></a></p>
<p><strong>invokevirtual 5</strong></p>
<p>找到常量池 #5 项，定位到方法区 java/io/PrintStream.println:(I)V 方法</p>
<p>生成新的栈帧（分配 locals、stack等）</p>
<p>传递参数，执行新栈帧中的字节码</p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151632.png" target="_blank" rel="noopener"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151632.png" alt="img"></a></p>
<p>执行完毕，弹出栈帧</p>
<p>清除 main 操作数栈内容</p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151640.png" target="_blank" rel="noopener"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151640.png" alt="img"></a></p>
<p><strong>return</strong><br>完成 main 方法调用，弹出 main 栈帧，程序结束</p>
<h4 id="通过字节码指令来分析问题"><a href="#通过字节码指令来分析问题" class="headerlink" title="通过字节码指令来分析问题"></a>通过字节码指令来分析问题</h4><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;		<span class="keyword">int</span> i=<span class="number">0</span>;		<span class="keyword">int</span> x=<span class="number">0</span>;		<span class="keyword">while</span>(i&lt;<span class="number">10</span>) &#123;			x = x++;			i++;		&#125;		System.out.println(x); <span class="comment">//接过为0	&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p>为什么最终的x结果为0呢？ 通过分析字节码指令即可知晓</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Code:     stack&#x3D;2, locals&#x3D;3, args_size&#x3D;1	&#x2F;&#x2F;操作数栈分配2个空间，局部变量表分配3个空间        0: iconst_0	&#x2F;&#x2F;准备一个常数0        1: istore_1	&#x2F;&#x2F;将常数0放入局部变量表的1号槽位 i&#x3D;0        2: iconst_0	&#x2F;&#x2F;准备一个常数0        3: istore_2	&#x2F;&#x2F;将常数0放入局部变量的2号槽位 x&#x3D;0	        4: iload_1		&#x2F;&#x2F;将局部变量表1号槽位的数放入操作数栈中        5: bipush        10	&#x2F;&#x2F;将数字10放入操作数栈中，此时操作数栈中有2个数        7: if_icmpge     21	&#x2F;&#x2F;比较操作数栈中的两个数，如果下面的数大于上面的数，就跳转到21。这里的比较是将两个数做减法。因为涉及运算操作，所以会将两个数弹出操作数栈来进行运算。运算结束后操作数栈为空       10: iload_2		&#x2F;&#x2F;将局部变量2号槽位的数放入操作数栈中，放入的值是0       11: iinc          2, 1	&#x2F;&#x2F;将局部变量2号槽位的数加1，自增后，槽位中的值为1       14: istore_2	&#x2F;&#x2F;将操作数栈中的数放入到局部变量表的2号槽位，2号槽位的值又变为了0       15: iinc          1, 1 &#x2F;&#x2F;1号槽位的值自增1       18: goto          4 &#x2F;&#x2F;跳转到第4条指令       21: getstatic     #2                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;       24: iload_2       25: invokevirtual #3                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(I)V       28: return</span><br></pre></td></tr></table></figure>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><h5 id="cinit-V"><a href="#cinit-V" class="headerlink" title="cinit()V"></a>cinit()V</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;	<span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">10</span>;	<span class="keyword">static</span> &#123;		i = <span class="number">20</span>;	&#125;	<span class="keyword">static</span> &#123;		i = <span class="number">30</span>;	&#125;	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;		System.out.println(i); <span class="comment">//结果为30	&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p>编译器会按<strong>从上至下</strong>的顺序，收集所有 static 静态代码块和静态成员赋值的代码，<strong>合并</strong>为一个特殊的方法 cinit()V ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack&#x3D;1, locals&#x3D;0, args_size&#x3D;0         0: bipush        10         2: putstatic     #3                  &#x2F;&#x2F; Field i:I         5: bipush        20         7: putstatic     #3                  &#x2F;&#x2F; Field i:I        10: bipush        30        12: putstatic     #3                  &#x2F;&#x2F; Field i:I        15: return</span><br></pre></td></tr></table></figure>
<h5 id="init-V"><a href="#init-V" class="headerlink" title="init()V"></a>init()V</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;	<span class="keyword">private</span> String a = <span class="string">"s1"</span>;	&#123;		b = <span class="number">20</span>;	&#125;	<span class="keyword">private</span> <span class="keyword">int</span> b = <span class="number">10</span>;	&#123;		a = <span class="string">"s2"</span>;	&#125;	<span class="function"><span class="keyword">public</span> <span class="title">Demo4</span><span class="params">(String a, <span class="keyword">int</span> b)</span> </span>&#123;		<span class="keyword">this</span>.a = a;		<span class="keyword">this</span>.b = b;	&#125;	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;		Demo4 d = <span class="keyword">new</span> Demo4(<span class="string">"s3"</span>, <span class="number">30</span>);		System.out.println(d.a);		System.out.println(d.b);	&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>编译器会按<strong>从上至下</strong>的顺序，收集所有 {} 代码块和成员变量赋值的代码，<strong>形成新的构造方法</strong>，但<strong>原始构造方法</strong>内的代码<strong>总是在后</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Code:     stack&#x3D;2, locals&#x3D;3, args_size&#x3D;3        0: aload_0        1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V        4: aload_0        5: ldc           #2                  &#x2F;&#x2F; String s1        7: putfield      #3                  &#x2F;&#x2F; Field a:Ljava&#x2F;lang&#x2F;String;       10: aload_0       11: bipush        20       13: putfield      #4                  &#x2F;&#x2F; Field b:I       16: aload_0       17: bipush        10       19: putfield      #4                  &#x2F;&#x2F; Field b:I       22: aload_0       23: ldc           #5                  &#x2F;&#x2F; String s2       25: putfield      #3                  &#x2F;&#x2F; Field a:Ljava&#x2F;lang&#x2F;String;       &#x2F;&#x2F;原始构造方法在最后执行       28: aload_0       29: aload_1       30: putfield      #3                  &#x2F;&#x2F; Field a:Ljava&#x2F;lang&#x2F;String;       33: aload_0       34: iload_2       35: putfield      #4                  &#x2F;&#x2F; Field b:I       38: return</span><br></pre></td></tr></table></figure>
<h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;	<span class="function"><span class="keyword">public</span> <span class="title">Demo5</span><span class="params">()</span> </span>&#123;	&#125;	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;	&#125;	<span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;	&#125;	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;	&#125;	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;	&#125;	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;		Demo5 demo5 = <span class="keyword">new</span> Demo5();		demo5.test1();		demo5.test2();		demo5.test3();		Demo5.test4();	&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>不同方法在调用时，对应的虚拟机指令有所区别</p>
<ul>
<li>私有、构造、被final修饰的方法，在调用时都使用<strong>invokespecial</strong>指令</li>
<li>普通成员方法在调用时，使用invokespecial指令。因为编译期间无法确定该方法的内容，只有在运行期间才能确定</li>
<li>静态方法在调用时使用invokestatic指令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Code:      stack&#x3D;2, locals&#x3D;2, args_size&#x3D;1         0: new           #2                  &#x2F;&#x2F; class com&#x2F;nyima&#x2F;JVM&#x2F;day5&#x2F;Demo5          3: dup         4: invokespecial #3                  &#x2F;&#x2F; Method &quot;&lt;init&gt;&quot;:()V         7: astore_1         8: aload_1         9: invokespecial #4                  &#x2F;&#x2F; Method test1:()V        12: aload_1        13: invokespecial #5                  &#x2F;&#x2F; Method test2:()V        16: aload_1        17: invokevirtual #6                  &#x2F;&#x2F; Method test3:()V        20: invokestatic  #7                  &#x2F;&#x2F; Method test4:()V        23: return</span><br></pre></td></tr></table></figure>
<ul>
<li>new 是创建【对象】，给对象分配堆内存，执行成功会将【<strong>对象引用</strong>】压入操作数栈</li>
<li>dup 是赋值操作数栈栈顶的内容，本例即为【<strong>对象引用</strong>】，为什么需要两份引用呢，一个是要配合 invokespecial 调用该对象的构造方法 “init”:()V （会消耗掉栈顶一个引用），另一个要 配合 astore_1 赋值给局部变量</li>
<li>终方法（ﬁnal），私有方法（private），构造方法都是由 invokespecial 指令来调用，属于静态绑定</li>
<li>普通成员方法是由 invokevirtual 调用，属于<strong>动态绑定</strong>，即支持多态 成员方法与静态方法调用的另一个区别是，执行方法前是否需要【对象引用】</li>
</ul>
<h4 id="多态原理"><a href="#多态原理" class="headerlink" title="多态原理"></a>多态原理</h4><p>运行HSDB工具:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp .&#x2F;lib&#x2F;sa-jdi.jar sun.jvm.hotspot.HSDB  &#x2F;&#x2F; jdk8进入“jdk\bin ”这个目录，运行“jhsdb hsdb”  &#x2F;&#x2F; jdk11</span><br></pre></td></tr></table></figure>
<p>因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用<strong>invokevirtual</strong>指令</p>
<p>在执行invokevirtual指令时，经历了以下几个步骤</p>
<ul>
<li>先通过栈帧中对象的引用找到对象</li>
<li>分析对象头，找到对象实际的Class</li>
<li>Class结构中有<strong>vtable</strong></li>
<li>查询vtable找到方法的具体地址</li>
<li>执行方法的字节码</li>
</ul>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><h5 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;		<span class="keyword">int</span> i = <span class="number">0</span>;		<span class="keyword">try</span> &#123;			i = <span class="number">10</span>;		&#125;<span class="keyword">catch</span> (Exception e) &#123;			i = <span class="number">20</span>;		&#125;	&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>对应字节码指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Code:     stack&#x3D;1, locals&#x3D;3, args_size&#x3D;1        0: iconst_0        1: istore_1        2: bipush        10        4: istore_1        5: goto          12        8: astore_2        9: bipush        20       11: istore_1       12: return     &#x2F;&#x2F;多出来一个异常表     Exception table:        from    to  target type            2     5     8   Class java&#x2F;lang&#x2F;Exception</span><br></pre></td></tr></table></figure>
<ul>
<li>可以看到多出来一个 Exception table 的结构，[from, to) 是<strong>前闭后开</strong>（也就是检测2~4行）的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号</li>
<li>8行的字节码指令 astore_2 是将异常对象引用存入局部变量表的2号位置（为e）</li>
</ul>
<h5 id="多个single-catch"><a href="#多个single-catch" class="headerlink" title="多个single-catch"></a>多个single-catch</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Demo1 &#123;	public static void main(String[] args) &#123;		int i &#x3D; 0;		try &#123;			i &#x3D; 10;		&#125;catch (ArithmeticException e) &#123;			i &#x3D; 20;		&#125;catch (Exception e) &#123;			i &#x3D; 30;		&#125;	&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>对应的字节码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Code:     stack&#x3D;1, locals&#x3D;3, args_size&#x3D;1        0: iconst_0        1: istore_1        2: bipush        10        4: istore_1        5: goto          19        8: astore_2        9: bipush        20       11: istore_1       12: goto          19       15: astore_2       16: bipush        30       18: istore_1       19: return     Exception table:        from    to  target type            2     5     8   Class java&#x2F;lang&#x2F;ArithmeticException            2     5    15   Class java&#x2F;lang&#x2F;Exception</span><br></pre></td></tr></table></figure>
<ul>
<li>因为异常出现时，<strong>只能进入</strong> Exception table 中<strong>一个分支</strong>，所以局部变量表 slot 2 位置<strong>被共用</strong></li>
</ul>
<h5 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Demo2 &#123;	public static void main(String[] args) &#123;		int i &#x3D; 0;		try &#123;			i &#x3D; 10;		&#125; catch (Exception e) &#123;			i &#x3D; 20;		&#125; finally &#123;			i &#x3D; 30;		&#125;	&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>对应字节码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Code:     stack&#x3D;1, locals&#x3D;4, args_size&#x3D;1        0: iconst_0        1: istore_1        &#x2F;&#x2F;try块        2: bipush        10        4: istore_1        &#x2F;&#x2F;try块执行完后，会执行finally            5: bipush        30        7: istore_1        8: goto          27       &#x2F;&#x2F;catch块            11: astore_2 &#x2F;&#x2F;异常信息放入局部变量表的2号槽位       12: bipush        20       14: istore_1       &#x2F;&#x2F;catch块执行完后，会执行finally               15: bipush        30       17: istore_1       18: goto          27       &#x2F;&#x2F;出现异常，但未被Exception捕获，会抛出其他异常，这时也需要执行finally块中的代码          21: astore_3       22: bipush        30       24: istore_1       25: aload_3       26: athrow  &#x2F;&#x2F;抛出异常       27: return     Exception table:        from    to  target type            2     5    11   Class java&#x2F;lang&#x2F;Exception            2     5    21   any &#x2F;&#x2F; 剩余的异常类型,比如Error           11    15    21   any &#x2F;&#x2F; 剩余的异常类型,比如Error</span><br></pre></td></tr></table></figure>
<p>可以看到 ﬁnally 中的代码被<strong>复制了 3 份</strong>，分别放入 try 流程，catch 流程以及 catch剩余的异常类型流程</p>
<p><strong>注意</strong>：虽然从字节码指令看来，每个块中都有finally块，但是finally块中的代码<strong>只会被执行一次</strong></p>
<h5 id="finally中的return"><a href="#finally中的return" class="headerlink" title="finally中的return"></a>finally中的return</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;		<span class="keyword">int</span> i = Demo3.test();        <span class="comment">//结果为20		System.out.println(i);	&#125;	public static int test() &#123;		int i;		try &#123;			i = 10;			return i;		&#125; finally &#123;			i = 20;			return i;		&#125;	&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p>对应字节码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Code:     stack&#x3D;1, locals&#x3D;3, args_size&#x3D;0        0: bipush        10        2: istore_0        3: iload_0        4: istore_1  &#x2F;&#x2F;暂存返回值        5: bipush        20        7: istore_0        8: iload_0        9: ireturn	&#x2F;&#x2F;ireturn会返回操作数栈顶的整型值20       &#x2F;&#x2F;如果出现异常，还是会执行finally块中的内容，没有抛出异常       10: astore_2       11: bipush        20       13: istore_0       14: iload_0       15: ireturn	&#x2F;&#x2F;这里没有athrow了，也就是如果在finally块中如果有返回操作的话，且try块中出现异常，会吞掉异常！     Exception table:        from    to  target type            0     5    10   any</span><br></pre></td></tr></table></figure>
<ul>
<li>由于 ﬁnally 中的 <strong>ireturn</strong> 被插入了所有可能的流程，因此返回结果肯定以ﬁnally的为准</li>
<li>至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子</li>
<li>跟上例中的 ﬁnally 相比，发现<strong>没有 athrow 了</strong>，这告诉我们：如果在 ﬁnally 中出现了 return，会<strong>吞掉异常</strong></li>
<li>所以<strong>不要在finally中进行返回操作</strong></li>
</ul>
<h5 id="被吞掉的异常"><a href="#被吞掉的异常" class="headerlink" title="被吞掉的异常"></a>被吞掉的异常</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Demo3 &#123;   public static void main(String[] args) &#123;      int i &#x3D; Demo3.test();      &#x2F;&#x2F;最终结果为20      System.out.println(i);   &#125;   public static int test() &#123;      int i;      try &#123;         i &#x3D; 10;         &#x2F;&#x2F;这里应该会抛出异常         i &#x3D; i&#x2F;0;         return i;      &#125; finally &#123;         i &#x3D; 20;         return i;      &#125;   &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>会发现打印结果为20，并未抛出异常</p>
<h5 id="finally不带return-打印10"><a href="#finally不带return-打印10" class="headerlink" title="finally不带return: 打印10"></a>finally不带return: 打印10</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Demo4 &#123;	public static void main(String[] args) &#123;		int i &#x3D; Demo4.test();		System.out.println(i);	&#125;	public static int test() &#123;		int i &#x3D; 10;		try &#123;			return i;		&#125; finally &#123;			i &#x3D; 20;		&#125;	&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>对应字节码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Code:     stack&#x3D;1, locals&#x3D;3, args_size&#x3D;0        0: bipush        10        2: istore_0 &#x2F;&#x2F;赋值给i 10        3: iload_0	&#x2F;&#x2F;加载到操作数栈顶        4: istore_1 &#x2F;&#x2F;加载到局部变量表的1号位置        5: bipush        20        7: istore_0 &#x2F;&#x2F;赋值给i 20        8: iload_1 &#x2F;&#x2F;加载局部变量表1号位置的数10到操作数栈        9: ireturn &#x2F;&#x2F;返回操作数栈顶元素 10       10: astore_2       11: bipush        20       13: istore_0       14: aload_2 &#x2F;&#x2F;加载异常       15: athrow &#x2F;&#x2F;抛出异常     Exception table:        from    to  target type            3     5    10   any</span><br></pre></td></tr></table></figure>
<h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Demo5 &#123;	public static void main(String[] args) &#123;		int i &#x3D; 10;		Lock lock &#x3D; new Lock();		synchronized (lock) &#123;			System.out.println(i);		&#125;	&#125;&#125;class Lock&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>对应字节码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Code:     stack&#x3D;2, locals&#x3D;5, args_size&#x3D;1        0: bipush        10        2: istore_1        3: new           #2                  &#x2F;&#x2F; class com&#x2F;nyima&#x2F;JVM&#x2F;day06&#x2F;Lock        6: dup &#x2F;&#x2F;复制一份，放到操作数栈顶，用于构造函数消耗        7: invokespecial #3                  &#x2F;&#x2F; Method com&#x2F;nyima&#x2F;JVM&#x2F;day06&#x2F;Lock.&quot;&lt;init&gt;&quot;:()V       10: astore_2 &#x2F;&#x2F;剩下的一份放到局部变量表的2号位置       11: aload_2 &#x2F;&#x2F;加载到操作数栈       12: dup &#x2F;&#x2F;复制一份，放到操作数栈，用于加锁时消耗       13: astore_3 &#x2F;&#x2F;将操作数栈顶元素弹出，暂存到局部变量表的三号槽位。这时操作数栈中有一份对象的引用       14: monitorenter &#x2F;&#x2F;加锁       &#x2F;&#x2F;锁住后代码块中的操作           15: getstatic     #4                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;       18: iload_1       19: invokevirtual #5                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(I)V       &#x2F;&#x2F;加载局部变量表中三号槽位对象的引用，用于解锁           22: aload_3           23: monitorexit &#x2F;&#x2F;解锁       24: goto          34       &#x2F;&#x2F;异常操作           27: astore        4       29: aload_3       30: monitorexit &#x2F;&#x2F;解锁       31: aload         4       33: athrow       34: return     &#x2F;&#x2F;可以看出，无论何时出现异常，都会跳转到27行，将异常放入局部变量中，并进行解锁操作，然后加载异常并抛出异常。           Exception table:        from    to  target type           15    24    27   any           27    31    27   any</span><br></pre></td></tr></table></figure>
<h3 id="3、编译期处理-语法糖"><a href="#3、编译期处理-语法糖" class="headerlink" title="3、编译期处理(语法糖)"></a>3、编译期处理(语法糖)</h3><p>所谓的 <strong>语法糖</strong> ，其实就是指 java 编译器把 <em>.java 源码编译为 \</em>.class 字节码的过程中，<strong>自动生成</strong>和<strong>转换</strong>的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利</p>
<p><strong>注意</strong>，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的<strong>结果直接就是 class 字节码</strong>，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。</p>
<h4 id="语法糖-默认构造函数"><a href="#语法糖-默认构造函数" class="headerlink" title="语法糖: 默认构造函数"></a>语法糖: 默认构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Candy1 &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>经过编译期优化后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Candy1 &#123;   &#x2F;&#x2F;这个无参构造器是java编译器帮我们加上的   public Candy1() &#123;      &#x2F;&#x2F;即调用父类 Object 的无参构造方法，即调用 java&#x2F;lang&#x2F;Object.&quot; &lt;init&gt;&quot;:()V      super();   &#125;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="语法糖-自动拆装箱"><a href="#语法糖-自动拆装箱" class="headerlink" title="语法糖: 自动拆装箱"></a>语法糖: 自动拆装箱</h4><p>基本类型和其包装类型的相互转换过程，称为拆装箱</p>
<p>在JDK 5以后，它们的转换可以在编译期自动完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Demo2 &#123;   public static void main(String[] args) &#123;      Integer x &#x3D; 1;      int y &#x3D; x;   &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>转换过程如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;      <span class="comment">//基本类型赋值给包装类型，称为装箱      Integer x = Integer.valueOf(1);      //包装类型赋值给基本类型，称谓拆箱      int y = x.intValue();   &#125;&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="语法糖-泛型集合取值"><a href="#语法糖-泛型集合取值" class="headerlink" title="语法糖: 泛型集合取值"></a>语法糖: 泛型集合取值</h4><p>泛型也是在 JDK 5 开始加入的特性，但 java 在<strong>编译泛型代码后</strong>会执行 <strong>泛型擦除</strong> 的动作，即泛型信息在编译为字节码之后就<strong>丢失</strong>了，实际的类型都当做了 <strong>Object</strong> 类型来处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;      List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();      list.add(<span class="number">10</span>);      Integer x = list.get(<span class="number">0</span>);   &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>对应字节码</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Code:    stack=2, locals=3, args_size=1       0: new           #2                  // class java/util/ArrayList       3: dup       4: invokespecial #3                  // Method java/util/ArrayList."&lt;init&gt;":()V       7: astore_1       8: aload_1       9: bipush        10      11: invokestatic  #4                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;      //这里进行了泛型擦除，实际调用的是add(Objcet o)      14: invokeinterface #5,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z      19: pop      20: aload_1      21: iconst_0      //这里也进行了泛型擦除，实际调用的是get(Object o)         22: invokeinterface #6,  2            // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;//这里进行了类型转换，将Object转换成了Integer      27: checkcast     #7                  // class java/lang/Integer      30: astore_2      31: return</span><br></pre></td></tr></table></figure>
<p>所以调用get函数取值时，有一个类型转换的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer x = (Integer) list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>如果要将返回结果赋值给一个int类型的变量，则还有<strong>自动拆箱</strong>的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = (Integer) list.get(<span class="number">0</span>).intValue();</span><br></pre></td></tr></table></figure>
<h4 id="语法糖-可变参数"><a href="#语法糖-可变参数" class="headerlink" title="语法糖: 可变参数"></a>语法糖: 可变参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(String... args)</span> </span>&#123;      <span class="comment">//将args赋值给arr，可以看出String...实际就是String[]       String[] arr = args;      System.out.println(arr.length);   &#125;   public static void main(String[] args) &#123;      foo("hello", "world");   &#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p>可变参数 <strong>String…</strong> args 其实是一个 <strong>String[]</strong> args ，从代码中的赋值语句中就可以看出来。 同 样 java 编译器会在编译期间将上述代码变换为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;   <span class="keyword">public</span> Demo4 &#123;&#125;       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(String[] args)</span> </span>&#123;      String[] arr = args;      System.out.println(arr.length);   &#125;   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;      foo(<span class="keyword">new</span> String[]&#123;<span class="string">"hello"</span>, <span class="string">"world"</span>&#125;);   &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>注意，如果调用的是foo()，即未传递参数时，等价代码为foo(new String[]{})，<strong>创建了一个空数组</strong>，而不是直接传递的null</p>
<h4 id="语法糖-foreach"><a href="#语法糖-foreach" class="headerlink" title="语法糖: foreach"></a>语法糖: foreach</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        <span class="comment">//数组赋初值的简化写法也是一种语法糖。		int[] arr = &#123;1, 2, 3, 4, 5&#125;;		for(int x : arr) &#123;			System.out.println(x);		&#125;	&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p>编译器会帮我们转换为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;    <span class="keyword">public</span> Demo5 &#123;&#125;	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;		<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; ++i) &#123;			<span class="keyword">int</span> x = arr[i];			System.out.println(x);		&#125;	&#125;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>如果是集合使用foreach</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;      List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);      <span class="keyword">for</span> (Integer x : list) &#123;         System.out.println(x);      &#125;   &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>集合要使用foreach，需要该集合类实现了<strong>Iterable接口</strong>，因为集合的遍历需要用到<strong>迭代器Iterator</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;    <span class="keyword">public</span> Demo5 &#123;&#125;       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;      List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);      <span class="comment">//获得该集合的迭代器      Iterator&lt;Integer&gt; iterator = list.iterator();      while(iterator.hasNext()) &#123;         Integer x = iterator.next();         System.out.println(x);      &#125;   &#125;&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="语法糖-switch字符串"><a href="#语法糖-switch字符串" class="headerlink" title="语法糖: switch字符串"></a>语法糖: switch字符串</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo6</span> </span>&#123;   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;      String str = <span class="string">"hello"</span>;      <span class="keyword">switch</span> (str) &#123;         <span class="keyword">case</span> <span class="string">"hello"</span> :            System.out.println(<span class="string">"h"</span>);            <span class="keyword">break</span>;         <span class="keyword">case</span> <span class="string">"world"</span> :            System.out.println(<span class="string">"w"</span>);            <span class="keyword">break</span>;         <span class="keyword">default</span>:            <span class="keyword">break</span>;      &#125;   &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>在编译器中执行的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo6</span> </span>&#123;   <span class="function"><span class="keyword">public</span> <span class="title">Demo6</span><span class="params">()</span> </span>&#123;         &#125;   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;      String str = <span class="string">"hello"</span>;      <span class="keyword">int</span> x = -<span class="number">1</span>;      <span class="comment">//通过字符串的hashCode+value来判断是否匹配      switch (str.hashCode()) &#123;         //hello的hashCode         case 99162322 :            //再次比较，因为字符串的hashCode有可能相等            if(str.equals("hello")) &#123;               x = 0;            &#125;            break;         //world的hashCode         case 11331880 :            if(str.equals("world")) &#123;               x = 1;            &#125;            break;         default:            break;      &#125;      //用第二个switch在进行输出判断      switch (x) &#123;         case 0:            System.out.println("h");            break;         case 1:            System.out.println("w");            break;         default:            break;      &#125;   &#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p>过程说明：</p>
<p>可以看到，执行了两遍 switch，第一遍是根据字符串的 hashCode 和 equals 将字符串的转换为相应 byte 类<br>型，第二遍才是利用 byte 执行进行比较。<br>为什么第一遍时必须既比较 hashcode，又利用 equals 比较呢？ hashcode 是为了提高效率，减少可能的比较：而equals 是为了防止hashCode冲突，例如 BM和C 这两个字符串的hashcode自都是 2123，如果有如下代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Candy6_2</span></span>&#123;	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">choose</span><span class="params">(String str)</span></span>&#123;		<span class="keyword">switch</span>(str)&#123;			<span class="keyword">case</span> <span class="string">"BM"</span>:&#123;				System.out.println(<span class="string">"h"</span>);        <span class="keyword">break</span>;			&#125;      <span class="keyword">case</span> <span class="string">"C"</span>:&#123;				System.out.println(<span class="string">"w"</span>);        <span class="keyword">break</span>;			&#125; 		&#125;	&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>会被编译器转换为:</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvo7nwqc5ij60cn0bsgm202.jpg" alt="image-20211022172139192"></p>
<h4 id="语法糖-switch枚举"><a href="#语法糖-switch枚举" class="headerlink" title="语法糖: switch枚举"></a>语法糖: switch枚举</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;      SEX sex = SEX.MALE;      <span class="keyword">switch</span> (sex) &#123;         <span class="keyword">case</span> MALE:            System.out.println(<span class="string">"man"</span>);            <span class="keyword">break</span>;         <span class="keyword">case</span> FEMALE:            System.out.println(<span class="string">"woman"</span>);            <span class="keyword">break</span>;         <span class="keyword">default</span>:            <span class="keyword">break</span>;      &#125;   &#125;&#125;<span class="keyword">enum</span> SEX &#123;   MALE, FEMALE;&#125;</span><br></pre></td></tr></table></figure>
<p>编译器中执行的代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;   <span class="comment">/**         * 定义一个合成类（仅 jvm 使用，对我们不可见）         * 用来映射枚举的 ordinal 与数组元素的关系         * 枚举的 ordinal 表示枚举对象的序号，从 0 开始         * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1         */</span>    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> $<span class="title">MAP</span> </span>&#123;      <span class="comment">//数组大小即为枚举元素个数，里面存放了case用于比较的数字      static int[] map = new int[2];      static &#123;         //ordinal即枚举元素对应所在的位置，MALE为0，FEMALE为1         map[SEX.MALE.ordinal()] = 1;         map[SEX.FEMALE.ordinal()] = 2;      &#125;   &#125;   public static void main(String[] args) &#123;      SEX sex = SEX.MALE;      //将对应位置枚举元素的值赋给x，用于case操作      int x = $MAP.map[sex.ordinal()];      switch (x) &#123;         case 1:            System.out.println("man");            break;         case 2:            System.out.println("woman");            break;         default:            break;      &#125;   &#125;&#125;enum SEX &#123;   MALE, FEMALE;&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="语法糖-枚举类的转换"><a href="#语法糖-枚举类的转换" class="headerlink" title="语法糖: 枚举类的转换"></a>语法糖: 枚举类的转换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> SEX &#123;   MALE, FEMALE;&#125;</span><br></pre></td></tr></table></figure>
<p>转换后的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sex</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">Sex</span>&gt; </span>&#123;      <span class="comment">//对应枚举类中的元素   public static final Sex MALE;       public static final Sex FEMALE;       private static final Sex[] $VALUES;       static &#123;           	//调用构造函数，传入枚举元素的值及ordinal    	MALE = new Sex("MALE", 0);            FEMALE = new Sex("FEMALE", 1);           $VALUES = new Sex[]&#123;MALE, FEMALE&#125;;    &#125; 	   //调用父类中的方法    private Sex(String name, int ordinal) &#123;             super(name, ordinal);        &#125;       public static Sex[] values() &#123;          return $VALUES.clone();      &#125;    public static Sex valueOf(String name) &#123;         return Enum.valueOf(Sex.class, name);      &#125;    &#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="语法糖-try-with-resources"><a href="#语法糖-try-with-resources" class="headerlink" title="语法糖: try-with-resources"></a>语法糖: try-with-resources</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvo83hu1qlj60ib0bkab102.jpg" alt="image-20211022173637931"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo9</span></span>&#123;	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  	<span class="keyword">try</span>&#123;      InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">"d:\\1.txt"</span>);      Throwable t = <span class="keyword">null</span>;      <span class="keyword">try</span>&#123;        System.out.println(is);      &#125;<span class="keyword">catch</span>(Throwable e1)&#123;        t = e1;        <span class="keyword">throw</span> e1;      &#125;<span class="keyword">finally</span>&#123;        <span class="comment">//判断了资源不为空        if(is != null)&#123;          try&#123;            is.close();          &#125;catch(Throwable e2)&#123;            // 如果close出现异常,作为被压制异常添加            t.addSuppressed(e2);          &#125;        &#125;else&#123;          // 如果我们代码没有异常,close出现的异常就是最后catch块中的e          is.close();        &#125;      &#125;    &#125; catch (IOException e)&#123;      e.printStackTrace();    &#125;  &#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvo8h92z24j60i909e3z702.jpg" alt="image-20211022174948252"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvo8i3x13tj60h105ajrk02.jpg" alt="image-20211022175040397"></p>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo8</span> </span>&#123;   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;      Runnable runnable = <span class="keyword">new</span> Runnable() &#123;         <span class="meta">@Override</span>         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;            System.out.println(<span class="string">"running..."</span>);         &#125;      &#125;;   &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>转换后的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo8</span> </span>&#123;   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;      <span class="comment">//用额外创建的类来创建匿名内部类对象      Runnable runnable = new Demo8$1();   &#125;&#125;//创建了一个额外的类，实现了Runnable接口final class Demo8$1 implements Runnable &#123;   public Demo8$1() &#123;&#125;   @Override   public void run() &#123;      System.out.println("running...");   &#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果匿名内部类中引用了<strong>局部变量</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo8</span> </span>&#123;   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;      <span class="keyword">int</span> x = <span class="number">1</span>;      Runnable runnable = <span class="keyword">new</span> Runnable() &#123;         <span class="meta">@Override</span>         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;            System.out.println(x);         &#125;      &#125;;   &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>转化后代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo8</span> </span>&#123;   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;      <span class="keyword">int</span> x = <span class="number">1</span>;      Runnable runnable = <span class="keyword">new</span> Runnable() &#123;         <span class="meta">@Override</span>         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;            System.out.println(x);         &#125;      &#125;;   &#125;&#125;<span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo8</span>$1 <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;   <span class="comment">//多创建了一个变量   int val$x;   //变为了有参构造器   public Demo8$1(int x) &#123;      this.val$x = x;   &#125;   @Override   public void run() &#123;      System.out.println(val$x);   &#125;&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvo8oikpkbj60gr02h3yq02.jpg" alt="image-20211022175644582"></h3><h3 id="4、类加载阶段"><a href="#4、类加载阶段" class="headerlink" title="4、类加载阶段"></a>4、类加载阶段</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ul>
<li><p>将类的字节码载入</p>
<p>方法区</p>
<p>（1.8后为元空间，在本地内存中）中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 ﬁeld 有：</p>
<ul>
<li>_java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用</li>
<li>_super 即父类</li>
<li>_ﬁelds 即成员变量</li>
<li>_methods 即方法</li>
<li>_constants 即常量池</li>
<li>_class_loader 即类加载器</li>
<li>_vtable 虚方法表</li>
<li>_itable 接口方法</li>
</ul>
</li>
<li><p>如果这个类还有父类没有加载，<strong>先加载父类</strong></p>
</li>
<li><p>加载和链接可能是<strong>交替运行</strong>的</p>
</li>
</ul>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611205050.png" target="_blank" rel="noopener"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611205050.png" alt="img"></a></p>
<ul>
<li>instanceKlass保存在<strong>方法区</strong>。JDK 8以后，方法区位于元空间中，而元空间又位于本地内存中</li>
<li>_java_mirror则是保存在<strong>堆内存</strong>中</li>
<li>InstanceKlass和*.class(JAVA镜像类)互相保存了对方的地址</li>
<li>类的对象在对象头中保存了*.class的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息</li>
</ul>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>验证类是否符合 JVM规范，安全性检查</p>
<h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>为 static 变量分配空间，设置默认值</p>
<ul>
<li>static变量在JDK 7以前是存储与instanceKlass末尾。但在JDK 7以后就存储在_java_mirror末尾了</li>
<li>static变量在分配空间和赋值是在两个阶段完成的。分配空间在准备阶段完成，赋值在初始化阶段完成</li>
<li>如果 static 变量是 ﬁnal 的<strong>基本类型</strong>，以及<strong>字符串常量</strong>，那么编译阶段值就确定了，<strong>赋值在准备阶段完成</strong></li>
<li>如果 static 变量是 ﬁnal 的，但属于<strong>引用类型</strong>，那么赋值也会在<strong>初始化阶段完成</strong></li>
</ul>
<h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p><strong>HSDB的使用</strong></p>
<ul>
<li>先获得要查看的进程ID</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps</span><br></pre></td></tr></table></figure>
<ul>
<li>打开HSDB</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp F:\JAVA\JDK8.0\lib\sa-jdi.jar sun.jvm.hotspot.HSDB</span><br></pre></td></tr></table></figure>
<ul>
<li>运行时可能会报错，是因为<strong>缺少一个.dll的文件</strong>，我们在JDK的安装目录中找到该文件，复制到缺失的文件下即可</li>
</ul>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611221703.png" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvp1sk5cfkj61fo0co43o02.jpg" alt="img"></a></p>
<ul>
<li>定位需要的进程</li>
</ul>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611221857.png" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvp1shrlcdj60tk0maq3o02.jpg" alt="img"></a></p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611222029.png" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvp1sfk9ujj60tk0mawgr02.jpg" alt="img"></a></p>
<p><strong>解析的含义</strong></p>
<p>将常量池中的符号引用解析为直接引用</p>
<ul>
<li>未解析时，常量池中的看到的对象仅是符号，未真正的存在于内存中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;      ClassLoader loader = Demo1<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;      <span class="comment">//只加载不解析      Class&lt;?&gt; c = loader.loadClass("com.nyima.JVM.day8.C");      //用于阻塞主线程      System.in.read();   &#125;&#125;class C &#123;   D d = new D();&#125;class D &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>打开HSDB<ul>
<li>可以看到此时只加载了类C</li>
</ul>
</li>
</ul>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223153.png" target="_blank" rel="noopener"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223153.png" alt="img"></a></p>
<p>查看类C的常量池，可以看到类D<strong>未被解析</strong>，只是存在于常量池中的符号</p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611230658.png" target="_blank" rel="noopener"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611230658.png" alt="img"></a></p>
<ul>
<li><p>解析以后，会将常量池中的符号引用解析为直接引用</p>
<ul>
<li>可以看到，此时已加载并解析了类C和类D</li>
</ul>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223441.png" target="_blank" rel="noopener"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223441.png" alt="img"></a></p>
</li>
</ul>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200613104723.png" target="_blank" rel="noopener"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200613104723.png" alt="img"></a></p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化阶段就是<strong>执行类构造器clinit()方法的过程</strong>，虚拟机会保证这个类的『构造方法』的线程安全</p>
<ul>
<li>clinit()方法是由编译器自动收集类中的所有类变量的<strong>赋值动作和静态语句块</strong>（static{}块）中的语句合并产生的</li>
</ul>
<p><strong>注意</strong></p>
<p>编译器收集的顺序是由语句在源文件中<strong>出现的顺序决定</strong>的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它<strong>之后</strong>的变量，在前面的静态语句块<strong>可以赋值，但是不能访问</strong>，如</p>
<p><a href="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201118204542.png" target="_blank" rel="noopener"><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20201118204542.png" alt="img"></a></p>
<h5 id="发生时机"><a href="#发生时机" class="headerlink" title="发生时机"></a>发生时机</h5><p><strong>类的初始化是懒惰的</strong>，</p>
<p>以下情况会初始化</p>
<ul>
<li>main 方法所在的类，总会被首先初始化</li>
<li>首次访问这个类的静态变量或静态方法时</li>
<li>子类初始化，如果父类还没初始化，会引发</li>
<li>子类访问父类的静态变量，只会触发父类的初始化</li>
<li>Class.forName</li>
<li>new 会导致初始化</li>
</ul>
<p>以下情况不会初始化</p>
<ul>
<li>访问类的 static ﬁnal 静态常量（基本类型和字符串）</li>
<li>类对象.class 不会触发初始化</li>
<li>创建该类对象的数组</li>
<li>类加载器的.loadClass方法</li>
<li>Class.forNamed的参数2为false时</li>
</ul>
<p>验证实例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo6</span> </span>&#123;  <span class="keyword">static</span> &#123;    <span class="comment">// main方法所在的类总是会被初始化    System.out.println("main init");  &#125;  public static void main(String[] args) throws ClassNotFoundException &#123;    /** 不会初始化但5种情况 */    // 1.静态常量不会触发初始化(因为B中但静态代码块没有执行)    // System.out.println(B.b);    // 2。类对象.class 不会被初始化(因为B中但静态代码块没有执行)    // System.out.println(B.class);    // 3.创建该类的数组不会初始化    //  System.out.println(new B[0]);    // 4.不会初始化类B,但会加载B、A    //  ClassLoader c1 = Thread.currentThread().getContextClassLoader();    //   c1.loadClass("com.kuang.hello.B");    // 5.不会初始化类B，但会加载B、A    //  ClassLoader c2 = Thread.currentThread().getContextClassLoader();    //  Class.forName("com.kuang.hello.B", false, c2);    /** 会初始化的5种情况 */    // 1.首次访问这个类的静态变量或静态方法时    //    System.out.println(A.a);    // 2.子类初始化，如果父类还没初始化，会引发    //    System.out.println(B.c);    // 3.子类访问父类静态变量，只触发父类初始化    //    System.out.println(B.a);    // 会初始化B,并先初始化A    //    Class.forName("com.kuang.hello.B");  &#125;&#125;class A &#123;  static int a = 0;  static &#123;    System.out.println("a init");  &#125;&#125;class B extends A &#123;  static final double b = 5.0;  static boolean c = false;  static &#123;    System.out.println("b init");  &#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>验证类是否被初始化，可以看改类的静态代码块是否被执行</strong></p>
<h3 id="5、类加载器"><a href="#5、类加载器" class="headerlink" title="5、类加载器"></a>5、类加载器</h3><p>Java虚拟机设计团队有意把类加载阶段中的<strong>“通过一个类的全限定名来获取描述该类的二进制字节流”</strong>这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为<strong>“类加载器”</strong>（ClassLoader）</p>
<h4 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h4><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段</p>
<p>对于任意一个类，都必须由加载它的<strong>类加载器</strong>和这个<strong>类本身</strong>一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：<strong>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义</strong>，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等</p>
<p>以JDK 8为例</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>加载的类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bootstrap ClassLoader（启动类加载器）</td>
<td>JAVA_HOME/jre/lib</td>
<td>无法直接访问(是C++代码写的)</td>
</tr>
<tr>
<td>Extension ClassLoader(拓展类加载器)</td>
<td>JAVA_HOME/jre/lib/ext</td>
<td>上级为Bootstrap，<strong>getParent时候显示为null,因为上级是C++写的</strong></td>
</tr>
<tr>
<td>Application ClassLoader(应用程序类加载器)</td>
<td>classpath</td>
<td>上级为Extension</td>
</tr>
<tr>
<td>自定义类加载器</td>
<td>自定义</td>
<td>上级为Application</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvplxaoli4j610h0u0jvj02.jpg" alt="image-20211023222037642"></p>
<p>从上图中我们就更容易理解了，当一个Hello.class这样的文件要被加载时。不考虑我们自定义类加载器，首先AppClassLoader会委托父类ExtClassLoader加载器有没有加载过,没有加载在上级找Bootstrap classLoader是否, 直到BootstrapClassLoader，都是在检查是否加载过，并不会选择自己去加载。已经没有父加载器了，这时候开始考虑自己是否能加载了，如果自己无法加载，会下沉到子加载器去加载，一直到最底层，如果没有任何加载器能加载，就会抛ClassNotFoundException</p>
<p>为什么要使用这种方式？这个是为了保证 如果加载的类是一个系统类，那么会优先由Bootstrap ClassLoader 、Extension ClassLoader先去加载，而不是使用我们自定义的ClassLoader去加载，保证系统的安全！</p>
<h4 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h4><p>可通过在控制台输入指令，使得类被启动类加器加载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.jvm.t3.load;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">F</span> </span>&#123;	<span class="keyword">static</span> &#123;    Systom.out.pringln(<span class="string">"bootstrap F init"</span>);  &#125;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.jvm.t3.load;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">load5</span></span>&#123;  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException</span>&#123;    Class&lt;?&gt; aClass = Class.forName(<span class="string">"cn.itcast.jvm.t3.load.F"</span>);    Systom.out.pringln(aClass.getClassLoader());  &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xbootclasspath&#x2F;a:. cn.itcast.jvm.t3.load.load5bootstrap F initnul</span><br></pre></td></tr></table></figure>
<p><strong>打印出为null说明是启动类加载器</strong></p>
<blockquote>
<ul>
<li>-Xbootclasspath 表示设置bootclasspath</li>
<li>其中 /a:. 表示将当前目录追加至bootclasspath之后; /p:. 表示追加到之前</li>
<li>可以使用这个办法代替核心类<ul>
<li>java -Xbootclasspath:<new bootclasspath></li>
<li>java -Xbootclasspath/a:&lt;追加路径&gt;</li>
<li>java -Xbootclasspath/p:&lt;追加路径&gt;</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="拓展类加载器"><a href="#拓展类加载器" class="headerlink" title="拓展类加载器"></a>拓展类加载器</h4><p>如果classpath和JAVA_HOME/jre/lib/ext 下有同名类，加载时会使用<strong>拓展类加载器</strong>加载。当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvpme6fnkrj60r80i3abh02.jpg" alt="image-20211023223650973"></p>
<h4 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h4><p>双亲委派模式，即调用类加载器ClassLoader 的 loadClass 方法时，查找类的规则</p>
<p>loadClass源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)    <span class="keyword">throws</span> ClassNotFoundException&#123;    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;        <span class="comment">// 首先查找该类是否已经被该类加载器加载过了        Class&lt;?&gt; c = findLoadedClass(name);        //如果没有被加载过        if (c == null) &#123;            long t0 = System.nanoTime();            try &#123;                //看是否被它的上级加载器加载过了 Extension的上级是Bootstarp，但它显示为null                if (parent != null) &#123;                    c = parent.loadClass(name, false);                &#125; else &#123;                    //看是否被启动类加载器加载过                    c = findBootstrapClassOrNull(name);                &#125;            &#125; catch (ClassNotFoundException e) &#123;                // ClassNotFoundException thrown if class not found                // from the non-null parent class loader                //捕获异常，但不做任何处理            &#125;            if (c == null) &#123;                //如果还是没有找到，先让拓展类加载器调用findClass方法去找到该类，如果还是没找到，就抛出异常                //然后让应用类加载器去找classpath下找该类                long t1 = System.nanoTime();                c = findClass(name);                // 记录时间                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                sun.misc.PerfCounter.getFindClasses().increment();            &#125;        &#125;        if (resolve) &#123;            resolveClass(c);        &#125;        return c;    &#125;&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ul>
<li>想加载非 classpath 随意路径中的类文件</li>
<li>通过接口来使用实现，希望解耦时，常用在框架设计</li>
<li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li>
</ul>
<h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul>
<li>继承ClassLoader父类</li>
<li>要遵从双亲委派机制，重写 ﬁndClass 方法<ul>
<li>注意不是重写loadClass方法，否则不会走双亲委派机制</li>
</ul>
</li>
<li>读取类文件的字节码</li>
<li>调用父类的 deﬁneClass 方法来加载类</li>
<li>使用者调用该类加载器的 loadClass 方法</li>
<li>举例 : <a href="https://blog.csdn.net/huazai30000/article/details/85296671" target="_blank" rel="noopener">https://blog.csdn.net/huazai30000/article/details/85296671</a></li>
</ul>
<h4 id="破坏双亲委派模式"><a href="#破坏双亲委派模式" class="headerlink" title="破坏双亲委派模式"></a>破坏双亲委派模式</h4><ul>
<li>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2面世以前的“远古”时代<ul>
<li>建议用户重写findClass()方法，在类加载器中的loadClass()方法中也会调用该方法</li>
</ul>
</li>
<li>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的<ul>
<li>如果有基础类型又要调用回用户的代码，此时也会破坏双亲委派模式</li>
</ul>
</li>
<li>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的<ul>
<li>这里所说的“动态性”指的是一些非常“热”门的名词：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等</li>
</ul>
</li>
</ul>
<h3 id="6、运行期优化"><a href="#6、运行期优化" class="headerlink" title="6、运行期优化"></a>6、运行期优化</h3><h4 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h4><p>JVM 将执行状态分成了 5 个层次：</p>
<ul>
<li>0层：解释执行(Interpreter)，用解释器将字节码翻译为机器码</li>
<li>1层：使用 C1 <strong>即时编译器</strong>编译执行（不带 proﬁling）</li>
<li>2层：使用 C1 即时编译器编译执行（带基本的profiling）</li>
<li>3层：使用 C1 即时编译器编译执行（带完全的profiling）</li>
<li>4层：使用 C2 即时编译器编译执行</li>
</ul>
<p>proﬁling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的 回边次数】等</p>
<h5 id="即时编译器（JIT）与解释器的区别"><a href="#即时编译器（JIT）与解释器的区别" class="headerlink" title="即时编译器（JIT）与解释器的区别"></a>即时编译器（JIT）与解释器的区别</h5><ul>
<li>解释器<ul>
<li>将字节码<strong>解释</strong>为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li>
<li>是将字节码解释为针对所有平台都通用的机器码</li>
</ul>
</li>
<li>即时编译器<ul>
<li>将一些字节码<strong>编译</strong>为机器码，<strong>并存入 Code Cache</strong>，下次遇到相同的代码，直接执行，无需再编译</li>
<li>根据平台类型，生成平台特定的机器码</li>
</ul>
</li>
</ul>
<p>对于大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter &lt; C1 &lt; C2，总的目标是发现热点代码（hotspot名称的由 来），并优化这些热点代码</p>
<h5 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h5><p>逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术</p>
<p>逃逸分析的 JVM 参数如下：</p>
<ul>
<li>开启逃逸分析：-XX:+DoEscapeAnalysis</li>
<li>关闭逃逸分析：-XX:-DoEscapeAnalysis</li>
<li>显示分析结果：-XX:+PrintEscapeAnalysis</li>
</ul>
<p>逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数</p>
<p><strong>对象逃逸状态</strong></p>
<p><strong>全局逃逸（GlobalEscape）</strong></p>
<ul>
<li>即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：<ul>
<li>对象是一个静态变量</li>
<li>对象是一个已经发生逃逸的对象</li>
<li>对象作为当前方法的返回值</li>
</ul>
</li>
</ul>
<p><strong>参数逃逸（ArgEscape）</strong></p>
<ul>
<li>即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的</li>
</ul>
<p><strong>没有逃逸</strong></p>
<ul>
<li>即方法中的对象没有发生逃逸</li>
</ul>
<p><strong>逃逸分析优化</strong></p>
<p>针对上面第三点，当一个对象<strong>没有逃逸</strong>时，可以得到以下几个虚拟机的优化</p>
<p><strong>锁消除</strong></p>
<p>我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁</p>
<p>例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作</p>
<p>锁消除的 JVM 参数如下：</p>
<ul>
<li>开启锁消除：-XX:+EliminateLocks</li>
<li>关闭锁消除：-XX:-EliminateLocks</li>
</ul>
<p>锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上</p>
<p><strong>标量替换</strong></p>
<p>首先要明白标量和聚合量，<strong>基础类型</strong>和<strong>对象的引用</strong>可以理解为<strong>标量</strong>，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做<strong>标量替换</strong>。</p>
<p>这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能</p>
<p>标量替换的 JVM 参数如下：</p>
<ul>
<li>开启标量替换：-XX:+EliminateAllocations</li>
<li>关闭标量替换：-XX:-EliminateAllocations</li>
<li>显示标量替换详情：-XX:+PrintEliminateAllocations</li>
</ul>
<p>标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上</p>
<p><strong>栈上分配</strong></p>
<p>当对象没有发生逃逸时，该<strong>对象</strong>就可以通过标量替换分解成成员标量分配在<strong>栈内存</strong>中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能</p>
<h4 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h4><h5 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a><strong>内联函数</strong></h5><p>内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换</p>
<h5 id="JVM内联函数"><a href="#JVM内联函数" class="headerlink" title="JVM内联函数"></a><strong>JVM内联函数</strong></h5><p>C++是否为内联函数由自己决定，Java由<strong>编译器决定</strong>。Java不支持直接声明为内联函数的，如果想让他内联，你只能够向编译器提出请求: 关键字<strong>final修饰</strong> 用来指明那个函数是希望被JVM内联的，如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// to do something  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总的来说，一般的函数都不会被当做内联函数，只有声明了final后，编译器才会考虑是不是要把你的函数变成内联函数</p>
<p>JVM内建有许多运行时优化。首先<strong>短方法</strong>更利于JVM推断。流程更明显，作用域更短，副作用也更明显。如果是长方法JVM可能直接就跪了。</p>
<p>第二个原因则更重要：<strong>方法内联</strong></p>
<p>如果JVM监测到一些<strong>小方法被频繁的执行</strong>，它会把方法的调用替换成方法体本身，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">add4</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> x3, <span class="keyword">int</span> x4)</span> </span>&#123; </span><br><span class="line">		<span class="comment">//这里调用了add2方法</span></span><br><span class="line">        <span class="keyword">return</span> add2(x1, x2) + add2(x3, x4);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> x2)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> x1 + x2;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>方法调用被替换后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">add4</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> x3, <span class="keyword">int</span> x4)</span> </span>&#123;  </span><br><span class="line">    	<span class="comment">//被替换为了方法本身</span></span><br><span class="line">        <span class="keyword">return</span> x1 + x2 + x3 + x4;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="反射优化"><a href="#反射优化" class="headerlink" title="反射优化"></a>反射优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reflect1</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"foo..."</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">      Method foo = Demo3.class.getMethod("foo");</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;=<span class="number">16</span>; i++) &#123;</span><br><span class="line">         foo.invoke(<span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>foo.invoke 前面 0 ~ 15 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现</p>
<p>invoke方法源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span></span><br><span class="line"><span class="function">       InvocationTargetException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!override) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class="line">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">            checkAccess(caller, clazz, obj, modifiers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//MethodAccessor是一个接口，有3个实现类，其中有一个是抽象类</span></span><br><span class="line">    MethodAccessor ma = methodAccessor;             <span class="comment">// read volatile</span></span><br><span class="line">    <span class="keyword">if</span> (ma == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ma = acquireMethodAccessor();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[<img src="https://tva1.sinaimg.cn/large/008i3skNly1gvqcsmak6yj60r60663zq02.jpg" alt="img"></p>
<p>会由DelegatingMehodAccessorImpl去调用NativeMethodAccessorImpl</p>
<p>NativeMethodAccessorImpl源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NativeMethodAccessorImpl</span> <span class="keyword">extends</span> <span class="title">MethodAccessorImpl</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line">    <span class="keyword">private</span> DelegatingMethodAccessorImpl parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numInvocations;</span><br><span class="line"></span><br><span class="line">    NativeMethodAccessorImpl(Method var1) &#123;</span><br><span class="line">        <span class="keyword">this</span>.method = var1;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//每次进行反射调用，会让numInvocation与ReflectionFactory.inflationThreshold的值（15）进行比较，并使使得numInvocation的值加一</span></span><br><span class="line">	<span class="comment">//如果numInvocation&gt;ReflectionFactory.inflationThreshold，则会调用本地方法invoke0方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object var1, Object[] var2)</span> <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (++<span class="keyword">this</span>.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(<span class="keyword">this</span>.method.getDeclaringClass())) &#123;</span><br><span class="line">            MethodAccessorImpl var3 = (MethodAccessorImpl)(<span class="keyword">new</span> MethodAccessorGenerator()).generateMethod(<span class="keyword">this</span>.method.getDeclaringClass(), <span class="keyword">this</span>.method.getName(), <span class="keyword">this</span>.method.getParameterTypes(), <span class="keyword">this</span>.method.getReturnType(), <span class="keyword">this</span>.method.getExceptionTypes(), <span class="keyword">this</span>.method.getModifiers());</span><br><span class="line">            <span class="keyword">this</span>.parent.setDelegate(var3);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> invoke0(<span class="keyword">this</span>.method, var1, var2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParent</span><span class="params">(DelegatingMethodAccessorImpl var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Object <span class="title">invoke0</span><span class="params">(Method var0, Object var1, Object[] var2)</span></span>;</span><br><span class="line">&#125;Copy</span><br><span class="line"><span class="comment">//ReflectionFactory.inflationThreshold()方法的返回值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> inflationThreshold = <span class="number">15</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>一开始if条件不满足，就会调用本地方法invoke0</li>
<li>随着numInvocation的增大，当它大于ReflectionFactory.inflationThreshold的值16时，就会本地方法访问器替换为一个运行时动态生成的访问器，来提高效率<ul>
<li>这时会从反射调用变为<strong>正常调用</strong>，即直接调用 Reflect1.foo()</li>
</ul>
</li>
</ul>
<p>[<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvmron44b8j60u80ld77302.jpg" alt="img"></p>
<h3 id="7、内存模型"><a href="#7、内存模型" class="headerlink" title="7、内存模型"></a>7、内存模型</h3><h4 id="1、Java内存模型"><a href="#1、Java内存模型" class="headerlink" title="1、Java内存模型"></a>1、Java内存模型</h4><p>很多人将【java 内存结构】与【java 内存模型】傻傻分不清，【java 内存模型】是 Java MemoryModel（JMM）的意思。</p>
<p>关于它的权威解释，请参考 <a href="https://download.oracle.com/otn-pub/jcp/memory_model-1.0-pfdspec-oth-JSpec/memory_model-1_0-pfd-spec.pdf?AuthParam=1562811549_4d4994cbd5b59d964cd2907ea22ca08b" target="_blank" rel="noopener">https://download.oracle.com/otn-pub/jcp/memory_model-1.0-pfdspec-oth-JSpec/memory_model-1_0-pfd-spec.pdf?AuthParam=1562811549_4d4994cbd5b59d964cd2907ea22ca08b</a></p>
<p>简单的说，JMM 定义了一套在多线程读写共享数据时（成员变量、数组）时，对数据的可见性、有序性、和原子性的规则和保障</p>
<h5 id="1-1原子性"><a href="#1-1原子性" class="headerlink" title="1.1原子性"></a>1.1原子性</h5><p>原子性在学习线程时讲过，下面来个例子简单回顾一下：问题提出，两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread1 =</span><br><span class="line">        <span class="keyword">new</span> Thread(</span><br><span class="line">            () -&gt; &#123;</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                a++;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    Thread thread2 =</span><br><span class="line">        <span class="keyword">new</span> Thread(</span><br><span class="line">            () -&gt; &#123;</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                a--;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line"></span><br><span class="line">    thread1.join();</span><br><span class="line">    thread2.join();</span><br><span class="line">    System.out.println(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-2问题分析"><a href="#1-2问题分析" class="headerlink" title="1.2问题分析"></a>1.2问题分析</h5><p>以上的结果可能是正数、负数、零。为什么呢？因为 Java 中对静态变量的自增，自减并不是原子操作。</p>
<p>例如对于 i++ 而言（i 为静态变量），实际会产生如下的 JVM 字节码指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getstatic i &#x2F;&#x2F; 获取静态变量i的值 </span><br><span class="line">iconst_1 &#x2F;&#x2F; 准备常量1 </span><br><span class="line">iadd &#x2F;&#x2F; 加法 </span><br><span class="line">putstatic i &#x2F;&#x2F; 将修改后的值存入静态变量i</span><br></pre></td></tr></table></figure>
<p>而对应i—也是类似:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getstatic i &#x2F;&#x2F; 获取静态变量i的值 </span><br><span class="line">iconst_1 &#x2F;&#x2F; 准备常量1 </span><br><span class="line">isub &#x2F;&#x2F; 减法 </span><br><span class="line">putstatic i &#x2F;&#x2F; 将修改后的值存入静态变量i</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvqf55fb45j60tc0bsdgs02.jpg" alt="image-20211024151132892"></p>
<p>如果是单线程以上 8 行代码是顺序执行（不会交错）没有问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 假设i的初始值为0 </span><br><span class="line">getstatic i   &#x2F;&#x2F; 线程1-获取静态变量i的值 线程内i&#x3D;0 </span><br><span class="line">iconst_1     &#x2F;&#x2F; 线程1-准备常量1 </span><br><span class="line">iadd        &#x2F;&#x2F; 线程1-自增 线程内i&#x3D;1 </span><br><span class="line">putstatic i &#x2F;&#x2F; 线程1-将修改后的值存入静态变量i 静态变量i&#x3D;1 </span><br><span class="line">getstatic i &#x2F;&#x2F; 线程1-获取静态变量i的值 线程内i&#x3D;1 </span><br><span class="line">iconst_1    &#x2F;&#x2F; 线程1-准备常量1 </span><br><span class="line">isub        &#x2F;&#x2F; 线程1-自减 线程内i&#x3D;0 </span><br><span class="line">putstatic i &#x2F;&#x2F; 线程1-将修改后的值存入静态变量i 静态变量i&#x3D;0</span><br></pre></td></tr></table></figure>
<p>但多线程下这 8 行代码可能交错运行（为什么会交错？思考一下）： 出现负数的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 假设i的初始值为0 </span><br><span class="line">getstatic i &#x2F;&#x2F; 线程1-获取静态变量i的值 线程内i&#x3D;0 </span><br><span class="line">getstatic i &#x2F;&#x2F; 线程2-获取静态变量i的值 线程内i&#x3D;0 </span><br><span class="line">iconst_1 &#x2F;&#x2F; 线程1-准备常量1 </span><br><span class="line">iadd &#x2F;&#x2F; 线程1-自增 线程内i&#x3D;1 </span><br><span class="line">putstatic i &#x2F;&#x2F; 线程1-将修改后的值存入静态变量i 静态变量i&#x3D;1 </span><br><span class="line">iconst_1 &#x2F;&#x2F; 线程2-准备常量1 isub &#x2F;&#x2F; 线程2-自减 线程内i&#x3D;-1 </span><br><span class="line">putstatic i &#x2F;&#x2F; 线程2-将修改后的值存入静态变量i 静态变量i&#x3D;-1</span><br></pre></td></tr></table></figure>
<p>出现正数的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 假设i的初始值为0 </span><br><span class="line">getstatic i &#x2F;&#x2F; 线程1-获取静态变量i的值 线程内i&#x3D;0 </span><br><span class="line">getstatic i &#x2F;&#x2F; 线程2-获取静态变量i的值 线程内i&#x3D;0 </span><br><span class="line">iconst_1 &#x2F;&#x2F; 线程1-准备常量1 </span><br><span class="line">iadd &#x2F;&#x2F; 线程1-自增 线程内i&#x3D;1 </span><br><span class="line">iconst_1 &#x2F;&#x2F; 线程2-准备常量1 </span><br><span class="line">isub &#x2F;&#x2F; 线程2-自减 线程内i&#x3D;-1 </span><br><span class="line">putstatic i &#x2F;&#x2F; 线程2-将修改后的值存入静态变量i 静态变量i&#x3D;-1 </span><br><span class="line">putstatic i &#x2F;&#x2F; 线程1-将修改后的值存入静态变量i 静态变量i&#x3D;1</span><br></pre></td></tr></table></figure>
<h5 id="1-3解决方法"><a href="#1-3解决方法" class="headerlink" title="1.3解决方法"></a>1.3解决方法</h5><p>语法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line">		要作为原子操作的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用 synchronized 解决并发问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo7_2</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread1 =</span><br><span class="line">        <span class="keyword">new</span> Thread(</span><br><span class="line">            () -&gt; &#123;</span><br><span class="line">              <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                  a++;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    Thread thread2 =</span><br><span class="line">        <span class="keyword">new</span> Thread(</span><br><span class="line">            () -&gt; &#123;</span><br><span class="line">              <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">                  a--;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">    </span><br><span class="line">    thread1.join();</span><br><span class="line">    thread2.join();</span><br><span class="line">    System.out.println(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何理解呢：你可以把 obj 想象成一个房间，线程 t1，t2 想象成两个人。</p>
<p>当线程 t1 执行到 synchronized(obj) 时就好比 t1 进入了这个房间，并反手锁住了门，在门内执行count++ 代码。</p>
<p>这时候如果 t2 也运行到了 synchronized(obj) 时，它发现门被锁住了，只能在门外等待。</p>
<p>当 t1 执行完 synchronized{} 块内的代码，这时候才会解开门上的锁，从 obj 房间出来。t2 线程这时才可以进入 obj 房间，反锁住门，执行它的 count— 代码。</p>
<blockquote>
<p>注意：上例中 t1 和 t2 线程必须用 synchronized 锁住同一个 obj 对象，如果 t1 锁住的是 m1 对象，t2 锁住的是 m2 对象，就好比两个人分别进入了两个不同的房间，没法起到同步的效果。</p>
</blockquote>
<h2 id="2、可见性"><a href="#2、可见性" class="headerlink" title="2、可见性"></a>2、可见性</h2><h3 id="2-1-退出不循环"><a href="#2-1-退出不循环" class="headerlink" title="2.1 退出不循环"></a>2.1 退出不循环</h3><p>先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvqgexl4cej60sk0djwfk02.jpg" alt="image-20211024155531484"></p>
<p>为什么呢？分析一下：</p>
<blockquote>
<ol>
<li><p>初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvqgg1u6o6j60uq0fsmyf02.jpg" alt="image-20211024155620843"></p>
</li>
<li><p>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvqggtrnr7j60vv0bpjss02.jpg" alt="image-20211024155720898"></p>
</li>
<li><p>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvqghnxi2vj60wa0ckmyz02.jpg" alt="image-20211024155809408"></p>
</li>
</ol>
</blockquote>
<h3 id="2-2-解决方法"><a href="#2-2-解决方法" class="headerlink" title="2.2 解决方法"></a>2.2 解决方法</h3><p>volatile（易变关键字）</p>
<p>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存</p>
<h3 id="2-3-可见性"><a href="#2-3-可见性" class="headerlink" title="2.3 可见性"></a>2.3 可见性</h3><p>前面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线程可见， 不能保证原子性，仅用在一个写线程，多个读线程的情况： 上例从字节码理解是这样的：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvqgkl5nj7j60th06n75002.jpg" alt="image-20211024160058661"></p>
<p>比较一下之前我们将线程安全时举的例子：两个线程一个 i++ 一个 i— ，只能保证看到最新值，不能解决指令交错</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvqgl75kfpj60s807vwfj02.jpg" alt="image-20211024160133816"></p>
<blockquote>
<p><strong>注意</strong> synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是synchronized是属于重量级操作，性能相对更低</p>
<p>如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到对 run 变量的修改了，想一想为什么？ 因为pringtln()方法里面加了对象锁</p>
</blockquote>
<h2 id="3、有序性"><a href="#3、有序性" class="headerlink" title="3、有序性"></a>3、有序性</h2><h3 id="3-1-诡异的结果"><a href="#3-1-诡异的结果" class="headerlink" title="3.1 诡异的结果"></a>3.1 诡异的结果</h3><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvqgnz0cwxj60kg0h1jsc02.jpg" alt="image-20211024160413434"></p>
<p>I_Result 是一个对象，有一个属性 r1 用来保存结果，问，可能的结果有几种？</p>
<p>有同学这么分析</p>
<ul>
<li>情况1：线程1 先执行，这时 ready = false，所以进入 else 分支结果为 1</li>
<li>情况2：线程2 先执行 num = 2，但没来得及执行 ready = true，线程1 执行，还是进入 else 分支，结果为1</li>
<li>情况3：线程2 执行到 ready = true，线程1 执行，这回进入 if 分支，结果为 4（因为 num 已经执行过了）</li>
<li>但我告诉你，结果还有可能是 0 ，信不信吧！</li>
</ul>
<p>这种现象叫做指令重排，是 JIT 编译器在运行时的一些优化，这个现象需要通过大量测试才能复现：借助 java 并发压测工具 jcstress <a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/CodeTools/jcstress</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DinteractiveMode=false - DarchetypeGroupId=org.openjdk.jcstress -DarchetypeArtifactId=jcstress-java-test- archetype -DgroupId=org.sample -DartifactId=test -Dversion=1.0</span><br></pre></td></tr></table></figure>
<p>创建maven项目,提供如下测试类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JCStressTest</span> </span><br><span class="line"><span class="meta">@Outcome</span>(id = &#123;<span class="string">"1"</span>, <span class="string">"4"</span>&#125;, expect = Expect.ACCEPTABLE, desc = <span class="string">"ok"</span>) </span><br><span class="line"><span class="meta">@Outcome</span>(id = <span class="string">"0"</span>, expect = Expect.ACCEPTABLE_INTERESTING, desc = <span class="string">"!!!!"</span>) </span><br><span class="line"><span class="meta">@State</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrencyTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">boolean</span> ready = <span class="keyword">false</span>; </span><br><span class="line">  <span class="meta">@Actor</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">      r.r1 = num + num; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      r.r1 = <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Actor</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123; </span><br><span class="line">    num = <span class="number">2</span>; ready = <span class="keyword">true</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install java -jar target/jcstress.jar</span><br></pre></td></tr></table></figure>
<p>会输出我们感兴趣的结果，摘录其中一次结果：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvqgwhjdljj60t906xq3m02.jpg" alt="image-20211024161225204"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvqgwlssbjj60sr08k74w02.jpg" alt="image-20211024161209984"></p>
<p>可以看到，出现结果为 0 的情况有 638 次，虽然次数相对很少，但毕竟是出现了。</p>
<h3 id="3-2-解决办法"><a href="#3-2-解决办法" class="headerlink" title="3.2 解决办法"></a>3.2 解决办法</h3><p>volatile 修饰的变量，可以禁用指令重排</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JCStressTest</span> </span><br><span class="line"><span class="meta">@Outcome</span>(id = &#123;<span class="string">"1"</span>, <span class="string">"4"</span>&#125;, expect = Expect.ACCEPTABLE, desc = <span class="string">"ok"</span>) </span><br><span class="line"><span class="meta">@Outcome</span>(id = <span class="string">"0"</span>, expect = Expect.ACCEPTABLE_INTERESTING, desc = <span class="string">"!!!!"</span>) </span><br><span class="line"><span class="meta">@State</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrencyTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">boolean</span> ready = <span class="keyword">false</span>; </span><br><span class="line">  <span class="meta">@Actor</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">      r.r1 = num + num; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      r.r1 = <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Actor</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123; </span><br><span class="line">    num = <span class="number">2</span>; ready = <span class="keyword">true</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*** INTERESTING tests </span><br><span class="line">    Some interesting behaviors observed. This is for the plain curiosity.</span><br><span class="line">    0 matching test results.</span><br></pre></td></tr></table></figure>
<p>3.3 有序性理解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i; </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> j; </span><br><span class="line"><span class="comment">// 在某个线程内执行如下赋值操作 </span></span><br><span class="line">i = ...; <span class="comment">// 较为耗时的操作 </span></span><br><span class="line">j = ...;</span><br></pre></td></tr></table></figure>
<p>可以看到，至于是先执行 i 还是 先执行 j ，对最终的结果不会产生影响。所以，上面代码真正执行时，既可以是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = ...; <span class="comment">// 较为耗时的操作 </span></span><br><span class="line">j = ...;</span><br></pre></td></tr></table></figure>
<p>也可以是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = ...; </span><br><span class="line">j = ...;<span class="comment">// 较为耗时的操作</span></span><br></pre></td></tr></table></figure>
<p>这种特性称之为『指令重排』，多线程下『指令重排』会影响正确性，例如著名的 double-checkedlocking 模式实现单例</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvqh2zs6o7j60oy0fx40d02.jpg" alt="image-20211024161839007"></p>
<p>以上的实现特点是：</p>
<ul>
<li>懒惰实例化</li>
<li>首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁</li>
</ul>
<p>但在多线程环境下，上面的代码是有问题的， INSTANCE = new Singleton() 对应的字节码为：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvqh3t5wosj60tn05i0t302.jpg" alt="image-20211024161926679"></p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvqh486b7vj60vh067gmn02.jpg" alt="image-20211024161950912"></p>
<p>这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初始化完毕的单例</p>
<p>对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 volatile 才会真正有效</p>
<h3 id="3-4-happens-before"><a href="#3-4-happens-before" class="headerlink" title="3.4 happens-before"></a>3.4 happens-before</h3><p>happens-before 规定了哪些写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结, 抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见</p>
<ul>
<li><p>线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x; </span><br><span class="line"><span class="keyword">static</span> Object m = <span class="keyword">new</span> Object(); </span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123; <span class="keyword">synchronized</span>(m) &#123; x = <span class="number">10</span>; &#125; &#125;,<span class="string">"t1"</span>).start(); </span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123; <span class="keyword">synchronized</span>(m) &#123; System.out.println(x); &#125; &#125;,<span class="string">"t2"</span>).start();</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程对 volatile 变量的写，对接下来其它线程对该变量的读可见</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> x; </span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123; x = <span class="number">10</span>; &#125;,<span class="string">"t1"</span>).start();</span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123; System.out.println(x); &#125;,<span class="string">"t2"</span>).start();</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或t1.join()等待它结束）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x; </span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123; x = <span class="number">10</span>; &#125;,<span class="string">"t1"</span>); </span><br><span class="line">t1.start(); </span><br><span class="line"></span><br><span class="line">t1.join(); </span><br><span class="line">System.out.println(x);</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过t2.interrupted 或 t2.isInterrupted） </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">  Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123; </span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123; </span><br><span class="line">      <span class="keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">        System.out.println(x); </span><br><span class="line">        <span class="keyword">break</span>; &#125; &#125; </span><br><span class="line">  &#125;,<span class="string">"t2"</span>); </span><br><span class="line">  t2.start();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">new</span> Thread(()-&gt;&#123; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">1000</span>); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; </span><br><span class="line">      e.printStackTrace(); </span><br><span class="line">    &#125;</span><br><span class="line">    x = <span class="number">10</span>; </span><br><span class="line">    t2.interrupt(); </span><br><span class="line">  &#125;,<span class="string">"t1"</span>).start();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(!t2.isInterrupted()) &#123; </span><br><span class="line">    Thread.yield(); </span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对变量默认值（0，false，null）的写，对其它线程对该变量的读可见</p>
</li>
<li><p>具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z</p>
<blockquote>
<p>变量都是指成员变量或静态成员变量</p>
</blockquote>
</li>
</ul>
<h2 id="4、CAS与原子类"><a href="#4、CAS与原子类" class="headerlink" title="4、CAS与原子类"></a>4、CAS与原子类</h2><h3 id="4-1-CAS"><a href="#4-1-CAS" class="headerlink" title="4.1 CAS"></a>4.1 CAS</h3><p>CAS 即 Compare and Swap ，它体现的一种乐观锁的思想，比如多个线程要对一个共享的整型变量执行 +1 操作：</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvqjqznfzyj60sj0e60uu02.jpg" alt="image-20211024175054154"></p>
<p>获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。结合 CAS 和 volatile 可以实现无锁并发，适用于竞争不激烈、多核 CPU 的场景下。</p>
<ul>
<li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li>
<li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li>
</ul>
<p>CAS 底层依赖于一个 Unsafe 类来直接调用操作系统底层的 CAS 指令，下面是直接使用 Unsafe 对象进行线程安全保护的一个例子:</p>
<p>底层实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCAS</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      DataContainer dc = <span class="keyword">new</span> DataContainer(); </span><br><span class="line">      <span class="keyword">int</span> count = <span class="number">5</span>;</span><br><span class="line">      Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">              dc.increase();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      thread.start();</span><br><span class="line">      thread.join();</span><br><span class="line">    System.out.println(dc.getData());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataContainer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> data; </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe; </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DATA_OFFSET;</span><br><span class="line">    <span class="keyword">static</span> &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Unsafe 对象不能直接调用，只能通过反射获得 </span></span><br><span class="line">            Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe"); </span><br><span class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>); </span><br><span class="line">            unsafe = (Unsafe) theUnsafe.get(<span class="keyword">null</span>); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123; </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// data 属性在 DataContainer 对象中的偏移量，用于 Unsafe 直接访问该属性 </span></span><br><span class="line">            DATA_OFFSET = unsafe.objectFieldOffset(DataContainer.class.getDeclaredField("data"));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123; </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> oldValue; </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123; </span><br><span class="line">            <span class="comment">// 获取共享变量旧值，可以在这一行加入断点，修改 data 调试来加深理解 </span></span><br><span class="line">            oldValue = data; </span><br><span class="line">            <span class="comment">// cas 尝试修改 data 为 旧值 + 1，如果期间旧值被别的线程改了，返回 false </span></span><br><span class="line">            <span class="keyword">if</span> (unsafe.compareAndSwapInt(<span class="keyword">this</span>, DATA_OFFSET, oldValue, oldValue + <span class="number">1</span>)) &#123; </span><br><span class="line">                <span class="keyword">return</span>; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrease</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldValue;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            oldValue = data;</span><br><span class="line">            <span class="keyword">if</span> (unsafe.compareAndSwapInt(<span class="keyword">this</span>,DATA_OFFSET,oldValue, oldValue-<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-悲观锁和乐观锁"><a href="#4-2-悲观锁和乐观锁" class="headerlink" title="4.2 悲观锁和乐观锁"></a>4.2 悲观锁和乐观锁</h3><ul>
<li>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</li>
<li>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</li>
</ul>
<h3 id="4-3-原子操作类"><a href="#4-3-原子操作类" class="headerlink" title="4.3 原子操作类"></a>4.3 原子操作类</h3><p>juc（java.util.concurrent）中提供了原子操作类，可以提供线程安全的操作，例如：AtomicInteger、AtomicBoolean等，它们底层就是采用 CAS 技术 + volatile 来实现的。</p>
<p>可以使用 AtomicInteger 改写之前的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAtomic</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread1 =</span><br><span class="line">        <span class="keyword">new</span> Thread(</span><br><span class="line">            () -&gt; &#123;</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5000</span>; j++) &#123;</span><br><span class="line">                i.getAndIncrement();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">      Thread thread2 =</span><br><span class="line">              <span class="keyword">new</span> Thread(</span><br><span class="line">                      () -&gt; &#123;</span><br><span class="line">                          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5000</span>; j++) &#123;</span><br><span class="line">                              i.getAndDecrement();</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">    thread1.join();</span><br><span class="line">    thread2.join();</span><br><span class="line">    System.out.println(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5、synchronized优化"><a href="#5、synchronized优化" class="headerlink" title="5、synchronized优化"></a>5、synchronized优化</h2><p>Java HotSpot 虚拟机中，每个对象都有对象头（包括 class 指针和 Mark Word）。Mark Word 平时存储这个对象的 哈希码 、 分代年龄 ，当加锁时，这些信息就根据情况被替换为标记位 、 线程锁记录指针 、 重量级锁指针 、 线程ID 等内容</p>
<h3 id="5-1-轻量级锁"><a href="#5-1-轻量级锁" class="headerlink" title="5.1 轻量级锁"></a>5.1 轻量级锁</h3><p>如果一个对象虽然有多线程访问，但多线程访问的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。这就好比：</p>
<p>学生（线程 A）用课本占座，上了半节课，出门了（CPU时间到），回来一看，发现课本没变，说明没有竞争，继续上他的课。 如果这期间有其它学生（线程 B）来了，会告知（线程A）有并发访问，线程A 随即升级为重量级锁，进入重量级锁的流程。</p>
<p>而重量级锁就不是那么用课本占座那么简单了，可以想象线程 A 走之前，把座位用一个铁栅栏围起来假设有两个方法同步块，利用同一个对象加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object(); </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  <span class="keyword">synchronized</span>( obj ) &#123; </span><br><span class="line">    <span class="comment">// 同步块 A method2(); </span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">    <span class="comment">// 同步块 B </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的 Mark Word </p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvqkotnz63j60hv0o8ac202.jpg" alt="image-20211024182326356"></p>
<h3 id="5-2-锁膨胀"><a href="#5-2-锁膨胀" class="headerlink" title="5.2 锁膨胀"></a><strong>5.2</strong> 锁膨胀</h3><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvqkqx33tdj60i10mqaby02.jpg" alt="image-20211024182527323"></p>
<h3 id="5-3-重量锁"><a href="#5-3-重量锁" class="headerlink" title="5.3 重量锁"></a>5.3 重量锁</h3><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。</p>
<p>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。待时间长了划算）</p>
<p>Java 7 之后不能控制是否开启自旋功能</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvqku6jqtwj60h00o476h02.jpg" alt="image-20211024182835332"></p>
<h3 id="5-4-偏向锁-不推荐使用"><a href="#5-4-偏向锁-不推荐使用" class="headerlink" title="5.4 偏向锁(不推荐使用)"></a>5.4 偏向锁(不推荐使用)</h3><p>是自己的就表示没有竞争，不用重新 CAS.</p>
<ul>
<li>撤销偏向需要将持锁线程升级为轻量级锁，这个过程中所有线程需要暂停（STW）</li>
<li>访问对象的 hashCode 也会撤销偏向锁</li>
<li>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，</li>
<li>重偏向会重置对象的 Thread ID</li>
<li>撤销偏向和重偏向都是批量进行的，以类为单位</li>
<li>如果撤销偏向到达某个阈值，整个类的所有对象都会变为不可偏向的</li>
<li>可以主动使用 -XX:-UseBiasedLocking 禁用偏向锁</li>
</ul>
<p>可以参考这篇论文：<a href="https://www.oracle.com/technetwork/java/biasedlocking-oopsla2006-wp-149958.pdf" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/biasedlocking-oopsla2006-wp-149958.pdf</a></p>
<p>假设有两个方法同步块，利用同一个对象加锁</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gvqkxgzeefj60h80h3ta602.jpg" alt="image-20211024183145222"></p>
<h3 id="5-5-其它优化"><a href="#5-5-其它优化" class="headerlink" title="5.5 其它优化"></a>5.5 其它优化</h3><p><strong>1.</strong> <strong>减少上锁时间</strong></p>
<p>同步代码块中尽量短</p>
<p><strong>2.</strong> <strong>减少锁的粒度</strong></p>
<p>将一个锁拆分为多个锁提高并发度，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object(); </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  <span class="keyword">synchronized</span>( obj ) &#123; </span><br><span class="line">    <span class="comment">// 同步块 A </span></span><br><span class="line">    method2(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  <span class="keyword">synchronized</span>( obj ) &#123; </span><br><span class="line">  	<span class="comment">// 同步块 B </span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ConcurrentHashMap</li>
<li>LongAdder 分为 base 和 cells 两部分。没有并发争用的时候或者是 cells 数组正在初始化的时候，会使用 CAS 来累加值到 base，有并发争用，会初始化 cells 数组，数组有多少个 cell，就允许有多少线程并行修改，最后将数组中每个 cell 累加，再加上 base 就是最终的值</li>
<li>LinkedBlockingQueue 入队和出队使用不同的锁，相对于LinkedBlockingArray只有一个锁效率要高</li>
</ul>
<p><strong>3.</strong> <strong>锁粗化</strong></p>
<p>多次循环进入同步块不如同步块内多次循环另外 JVM 可能会做如下优化，把多次 append 的加锁操作粗化为一次（因为都是对同一个对象加锁，没必要重入多次）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new StringBuffer().append(&quot;a&quot;).append(&quot;b&quot;).append(&quot;c&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>4.</strong> <strong>锁消除</strong></p>
<p>JVM 会进行代码的逃逸分析，例如某个加锁对象是方法内局部变量，不会被其它线程所访问到，这时候就会被即时编译器忽略掉所有同步操作。</p>
<p><strong>5.</strong> <strong>读写分离</strong></p>
<p>CopyOnWriteArrayList ConyOnWriteSet</p>
<p>参考：</p>
<p><a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/HotSpot/Synchronization</a></p>
<p><a href="http://luojinping.com/2015/07/09/java锁优化/" target="_blank" rel="noopener">http://luojinping.com/2015/07/09/java锁优化/</a></p>
<p><a href="https://www.infoq.cn/article/java-se-16-synchronized" target="_blank" rel="noopener">https://www.infoq.cn/article/java-se-16-synchronized</a></p>
<p><a href="https://www.jianshu.com/p/9932047a89be" target="_blank" rel="noopener">https://www.jianshu.com/p/9932047a89be</a></p>
<p><a href="https://www.cnblogs.com/sheeva/p/6366782.html" target="_blank" rel="noopener">https://www.cnblogs.com/sheeva/p/6366782.html</a></p>
<p><a href="https://stackoverflflow.com/questions/46312817/does-java-ever-rebias-an-individual-lock" target="_blank" rel="noopener">https://stackoverflflow.com/questions/46312817/does-java-ever-rebias-an-individual-lock</a></p>

                
                <hr>
                <!-- Pager -->
                <ul class="pager">
                    
                    
                        <li class="next">
                            <a href="/2021/09/16/缓存和分布式锁/" data-toggle="tooltip" data-placement="top" title="缓存和分布式锁">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                <div class="comment_notes_blank"></div>

                <!-- tip start -->
                
                <div class="visitor_notice">
                    <img 
                        src="/img/notice.png" 
                        alt="notice"
                        title="notice"/>
                    <p class="notice">
                        欢迎访问 <a href="https://www.bytenote.cn" target="bytenote">chenyawei</a> 的博客, 若有问题或者有好的建议欢迎留言，笔者看到之后会及时回复。 评论点赞需要github账号登录，如果没有账号的话请点击 <a href="https://github.com" target="view_window" > github </a> 注册， 谢谢 !
                    </p>
                </div>
                <div class="comment_notes">
                    <p>
                        If you like this blog or find it useful for you, you are welcome to comment on it. 
                        You are also welcome to share this blog, so that more people can participate in it.
                        If the images used in the blog infringe your copyright, please contact the author to delete them. Thank you !
                    </p>
                </div>
                
                <!-- tip end -->

                <!--分享-->
                
                <!--分享-->

                <!-- require APlayer start --><!--
                
                <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
                <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script>
                <script src="https://cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js"></script>

                <div class="aplayer"
                    data-id="undefined"
                    data-server="undefined"
                    data-type="undefined"
                    data-fixed="undefined" >
                </div>
                -->
                <!-- require APlayer end -->

                <!-- gitment start -->
                
                <hr>
                <div id="blog_comments"></div>


<!-- <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script> -->


<link rel="stylesheet" href="https://billts.site/extra_css/gitment.css">
<script src="https://billts.site/js/gitment.js"></script>


<!-- <link rel="stylesheet" href="/css/gitment.css">
<script type="text/javascript" src="/js/gitment.js"></script> -->


<!-- <script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.css"/> -->

<!--
<link rel="stylesheet" href="https://billts.site/extra_css/gitment.css">
<script src="https://billts.site/js/gitment.js"></script>
-->

<script>
const myTheme = {
  render(state, instance) {
    const container = document.createElement('div')
    container.lang = "en-US"
    container.className = 'gitment-container gitment-root-container'
    
     // your custom component
    container.appendChild(instance.renderSomething(state, instance))
    
    container.appendChild(instance.renderHeader(state, instance))
    container.appendChild(instance.renderComments(state, instance))
    container.appendChild(instance.renderEditor(state, instance))
    //container.appendChild(instance.renderFooter(state, instance))
    return container
  },
  renderSomething(state, instance) {
    const container = document.createElement('div')
    container.lang = "en-US"
    container.className = 'hello_visitor'
    if (state.user.login) {
      container.innerText = `Hello ${state.user.login}, Welcome to comment system`
    }
    return container
  }
}


const gitment = new Gitment({
    id: 'Mon Oct 25 2021 09:09:52 GMT+0800', // optional
    owner: "chenyawei1227",
    repo: "comments",
    oauth: {
      client_id: "6a6df0d17c78f49f9e9c",
      client_secret: "0d8968f17d43240fa2a0364955d823f615f067f8",
    },
    theme: myTheme,
    // ...
    // For more available options, check out the documentation below
  })
  
  gitment.render('blog_comments')
  // or
  // gitment.render(document.getElementById('comments'))
  // or
  // document.body.appendChild(gitment.render())
</script>
                
                <!-- gitment end -->

                <!-- 来必力City版安装代码 -->
                
                <!-- City版安装代码已完成 -->

                <!-- disqus comment start -->
                
                <!-- disqus comment end -->
            </div>
            
            <!-- Tabe of Content -->
            <!-- Table of Contents -->

                
            <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#java" title="java">java</a>
                        
                          <a class="tag" href="/tags/#jvm" title="jvm">jvm</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="https://www.jianshu.com/u/78b636e8a217" target="_blank">Luke&#39;s Blog</a></li>
                    
                        <li><a href="#" target="_blank">Luke&#39;s Web</a></li>
                    
                        <li><a href="https://github.com/chenyawei1227" target="_blank">Luke&#39;s Github</a></li>
                    
                        <li><a href="#" target="_blank">Other</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'left',
          icon: 'ℬ'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>


    <style  type="text/css">
        .notice {
            color:rgba(51,51,51,0.9);
            margin:0px;
            padding:0px;
        }

        .visitor_notice a {
            text-decoration:none;
            color:rgba(51,51,51,0.9);
            font-weight:normal;
            font-style:italic;
        }

        .visitor_notice a:hover {
            text-decoration:none;
            color:rgba(51,51,51,0.9);
            font-weight:bolder;
            font-style:italic;
        }
    </style>


<style  type="text/css">
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }

        .comment_notes_blank {
            height:100px;
        }
        
        .comment_notes {
            color:rgba(51,51,51,0.9);
            text-align:left;
            font-style:italic;
        }

        .visitor_notice {
            border:1px solid rgba(209,216,220,0.9);
            padding:20px 20px 20px 20px;
            border-radius:10px;
        }

        .visitor_notice img{
            height:40px;
            width:40px;
            float:left;
            position:relative;
            margin:0px 10px 0px 0px;
            padding:0px;
            top:0px;
            left:0px;
        }
    }

    .comment_notes_blank {
        height:100px;
    }
    
    .comment_notes {
        color:rgba(51,51,51,0.9);
        text-align:left;
        font-style:italic;
    }

    .visitor_notice {
        border:1px solid rgba(209,216,220,0.9);
        padding:20px 20px 20px 20px;
        border-radius:10px;
    }

    .visitor_notice img{
        height:40px;
        width:40px;
        float:left;
        position:relative;
        margin:0px 10px 0px 0px;
        padding:0px;
        top:0px;
        left:0px;
    }

</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">

                
                    <li>
                        <a target="_blank"  href="https://github.com/chenyawei1227">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="https://twitter.com/cyw119900">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="https://www.facebook.com/profile.php?id=100011498883719">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/cyw1227">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Chenyawei 个人博客   豫ICP备19044156号
                    <br>
                    Powered by 
                    <a href="https://github.com/chenyawei1227/hexo-theme-snail" target="_blank" rel="noopener">
                        <i>hexo-theme-snail</i>
                    </a> | 
                    <iframe style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0"
                        width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=dusign&repo=hexo-theme-snail&type=star&count=true">
                    </iframe>
                </p>
            </div>
        </div>
    </div>

</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/hux-blog.min.js"></script>


<!-- Search -->

<script src="/js/search.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://bytenote.cn/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-XXXXXXXX-X';
    var _gaDomain = 'yoursite';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->


<!-- Search -->

    <script type="text/javascript">      
        var search_path = "search.xml";
        if (search_path.length == 0) {
            search_path = "search.xml";
        }
    var path = "/" + search_path;
    searchFunc(path, 'local-search-input', 'local-search-result');
    </script>


<!-- busuanzi -->
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





	<a id="rocket" href="#top" class=""></a>
	<script type="text/javascript" src="/js/totop.js?v=1.0.0" async=""></script>
    <script type="text/javascript" src="/js/toc.js?v=1.0.0" async=""></script>

    
        <!-- background effects start -->
        

        
            <script type="text/javascript" src="/js/mouse-click.js" content='[&quot;🌱&quot;,&quot;just do it&quot;,&quot;🌾&quot;,&quot;🍀&quot;,&quot;don&#39;t give up&quot;,&quot;🍂&quot;,&quot;🌻&quot;,&quot;try it again&quot;,&quot;🍃&quot;,&quot;never say die&quot;,&quot;🌵&quot;,&quot;🌿&quot;,&quot;🌴&quot;]' color='[&quot;rgb(121,93,179)&quot; ,&quot;rgb(76,180,231)&quot; ,&quot;rgb(184,90,154)&quot; ,&quot;rgb(157,211,250)&quot; ,&quot;rgb(255,0,0)&quot; ,&quot;rgb(242,153,29)&quot; ,&quot;rgb(23,204,16)&quot; ,&quot;rgb(222,0,0)&quot; ,&quot;rgb(22,36,92)&quot; ,&quot;rgb(127,24,116)&quot; ,&quot;rgb(119,195,79)&quot; ,&quot;rgb(4,77,34)&quot; ,&quot;rgb(122,2,60)&quot;]'></script>
        

        <!-- background effects end -->
    

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!-- <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>

</html>
