<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>springMVC配置form支持PUT和DELETE方法</title>
      <link href="/2019/12/10/springMVC%E9%85%8D%E7%BD%AEform%E6%94%AF%E6%8C%81PUT%E5%92%8CDELETE%E6%96%B9%E6%B3%95/"/>
      <url>/2019/12/10/springMVC%E9%85%8D%E7%BD%AEform%E6%94%AF%E6%8C%81PUT%E5%92%8CDELETE%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 操作记录 </tag>
            
            <tag> java </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java泛型</title>
      <link href="/2019/12/09/java%E6%B3%9B%E5%9E%8B/"/>
      <url>/2019/12/09/java%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="一-、提出背景"><a href="#一-、提出背景" class="headerlink" title="一.、提出背景"></a>一.、提出背景</h2><p>泛型在java中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用。</p><p>在<a href="https://baike.baidu.com/item/Java SE/4662159" target="_blank" rel="noopener">Java SE</a> 1.5之前，没有泛型（Generics）的情况下，通过对类型Object的引用来实现参数的“任意化”，“任意化”带来的缺点是要作显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以在预知的情况下进行的。对于强制类型转换错误的情况，<a href="https://baike.baidu.com/item/编译器/8853067" target="_blank" rel="noopener">编译器</a>可能不提示错误，在运行的时候才出现异常，这是一个安全隐患。</p><p>SE1.5中引入的一个新特性，其本质是参数化类型。参数类型可以用在<a href="https://baike.baidu.com/item/类/6824577" target="_blank" rel="noopener">类</a>、<a href="https://baike.baidu.com/item/接口/15422203" target="_blank" rel="noopener">接口</a>和方法的创建中，分别称为泛型类、泛型接口、泛型方法。Java允许程序员构建一个元素类型为Object的Collection，其中的元素可以是任何类型。</p><blockquote><p>假定我们有这样一个需求：写一个排序方法，能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，该如何实现？</p><p>答案是可以使用 <strong>Java 泛型</strong>。使用 Java 泛型的概念，我们可以写一个泛型方法来对一个对象数组排序。然后，调用该泛型方法来对整型数组、浮点数数组、字符串数组等进行排序。</p><p>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p><p>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p></blockquote><p>不使用泛型式，容易引起的运行时错误</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">arrayList.add(<span class="string">"aaaa"</span>);</span><br><span class="line">arrayList.add(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; arrayList.size();i++)&#123;</span><br><span class="line">    String item = (String)arrayList.get(i);</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"item = "</span> + item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>毫无疑问，程序的运行结果会以崩溃结束：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span><br></pre></td></tr></table></figure><p>ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。</p><p>我们将第一行声明初始化list的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">...</span><br><span class="line"><span class="comment">//arrayList.add(100); 在编译阶段，编译器就会报错。避免了运行时错误</span></span><br></pre></td></tr></table></figure><h2 id="二、泛型类"><a href="#二、泛型类" class="headerlink" title="二、泛型类"></a>二、泛型类</h2><p>泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。在类名后面添加了类型参数声明部分。</p><p>和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。</p><p>如下实例演示了我们如何定义一个泛型类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;  </span><br><span class="line">  <span class="keyword">private</span> T t;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.t = t;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Box&lt;Integer&gt; integerBox = <span class="keyword">new</span> Box&lt;Integer&gt;();</span><br><span class="line">    Box&lt;String&gt; stringBox = <span class="keyword">new</span> Box&lt;String&gt;();</span><br><span class="line"> </span><br><span class="line">    integerBox.add(<span class="keyword">new</span> Integer(<span class="number">10</span>));</span><br><span class="line">    stringBox.add(<span class="keyword">new</span> String(<span class="string">"菜鸟教程"</span>));</span><br><span class="line"> </span><br><span class="line">    System.out.printf(<span class="string">"整型值为 :%d\n\n"</span>, integerBox.get());</span><br><span class="line">    System.out.printf(<span class="string">"字符串为 :%s\n"</span>, stringBox.get());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">整型值为 :<span class="number">10</span></span><br><span class="line">字符串为 :菜鸟教程</span><br></pre></td></tr></table></figure><p>定义的泛型类，就一定要传入泛型类型实参么？并不是这样，在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Generic generic = <span class="keyword">new</span> Generic(<span class="string">"111111"</span>);</span><br><span class="line">Generic generic1 = <span class="keyword">new</span> Generic(<span class="number">4444</span>);</span><br><span class="line">Generic generic2 = <span class="keyword">new</span> Generic(<span class="number">55.55</span>);</span><br><span class="line">Generic generic3 = <span class="keyword">new</span> Generic(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic.getKey());</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic1.getKey());</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic2.getKey());</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic3.getKey());</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">D/泛型测试: key is <span class="number">111111</span></span><br><span class="line">D/泛型测试: key is <span class="number">4444</span></span><br><span class="line">D/泛型测试: key is <span class="number">55.55</span></span><br><span class="line">D/泛型测试: key is <span class="keyword">false</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li><ol><li>泛型的类型参数只能是类类型，不能是简单类型。即类型参数必须为引用类型，不能是基本类型。</li></ol></li><li><ol><li><p>不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(ex_num <span class="keyword">instanceof</span> Generic&lt;Number&gt;)&#123;   </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><blockquote><p>　　instanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例，用法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span>` `result = obj ``<span class="keyword">instanceof</span>` `Class</span><br></pre></td></tr></table></figure><p>其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。</p><p>　　注意：编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。　　</p></blockquote></li></ol></li></ul></blockquote><h2 id="四、泛型接口"><a href="#四、泛型接口" class="headerlink" title="四、泛型接口"></a>四、泛型接口</h2><p>泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当实现泛型接口的类，未传入泛型实参时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</span></span><br><span class="line"><span class="comment"> * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</span></span><br><span class="line"><span class="comment"> * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错："Unknown class"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当实现泛型接口的类，传入泛型实参时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入泛型实参时：</span></span><br><span class="line"><span class="comment"> * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt;</span></span><br><span class="line"><span class="comment"> * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。</span></span><br><span class="line"><span class="comment"> * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型</span></span><br><span class="line"><span class="comment"> * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] fruits = <span class="keyword">new</span> String[]&#123;<span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Pear"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">return</span> fruits[rand.nextInt(<span class="number">3</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、泛型通配符"><a href="#三、泛型通配符" class="headerlink" title="三、泛型通配符"></a>三、泛型通配符</h2><p>1、类型通配符一般是使用<strong>?</strong>代替具体的类型参数。</p><p>我们知道Ingeter是Number的一个子类，同时在特性章节中我们也验证过Generic<Ingeter>与Generic<Number>实际上是相同的一种基本类型。那么问题来了，在使用Generic<Number>作为形参的方法中，能否使用Generic<Ingeter>的实例传入呢？在逻辑上类似于Generic<Number>和Generic<Ingeter>是否可以看成具有父子关系的泛型类型呢？</p><p>为了弄清楚这个问题，我们使用<code>Generic</code>这个泛型类继续看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue</span><span class="params">(Generic&lt;Number&gt; obj)</span></span>&#123;</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Generic&lt;Integer&gt; gInteger = <span class="keyword">new</span> Generic&lt;Integer&gt;(<span class="number">123</span>);</span><br><span class="line">Generic&lt;Number&gt; gNumber = <span class="keyword">new</span> Generic&lt;Number&gt;(<span class="number">456</span>);</span><br><span class="line"></span><br><span class="line">showKeyValue(gNumber);</span><br><span class="line"></span><br><span class="line"><span class="comment">// showKeyValue这个方法编译器会为我们报错：Generic&lt;java.lang.Integer&gt; </span></span><br><span class="line"><span class="comment">// cannot be applied to Generic&lt;java.lang.Number&gt;</span></span><br><span class="line"><span class="comment">// showKeyValue(gInteger);</span></span><br></pre></td></tr></table></figure><p>通过提示信息我们可以看到Generic<Integer>不能被看作为`Generic<Number>的子类。由此可以看出:同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。</p><p>回到上面的例子，如何解决上面的问题？总不能为了定义一个新的方法来处理Generic<Integer>类型的类，这显然与java中的多台理念相违背。因此我们需要一个在逻辑上可以表示同时是Generic<Integer>和Generic<Number>父类的引用类型。由此类型通配符应运而生。</p><p>我们可以将上面的方法改一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue1</span><span class="params">(Generic&lt;?&gt; obj)</span></span>&#123;</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型通配符一般是使用？代替具体的类型实参，注意了，此处’？’是类型实参，而不是类型形参 。重要说三遍！此处’？’是类型实参，而不是类型形参 ！ 此处’？’是类型实参，而不是类型形参 ！再直白点的意思就是，此处的？和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。可以解决当具体类型不确定的时候，这个通配符就是 ?  ；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。</p><p>例如 <strong>List</strong> 在逻辑上是<strong>List,List</strong> 等所有List&lt;具体类型实参&gt;的父类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; name = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        List&lt;Integer&gt; age = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        List&lt;Number&gt; number = <span class="keyword">new</span> ArrayList&lt;Number&gt;();  </span><br><span class="line">        name.add(<span class="string">"icon"</span>);</span><br><span class="line">        age.add(<span class="number">18</span>);</span><br><span class="line">        number.add(<span class="number">314</span>);</span><br><span class="line"> </span><br><span class="line">        getData(name);</span><br><span class="line">        getData(age);</span><br><span class="line">        getData(number);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">(List&lt;?&gt; data)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"data :"</span> + data.get(<span class="number">0</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">data :icon</span><br><span class="line">data :<span class="number">18</span></span><br><span class="line">data :<span class="number">314</span></span><br></pre></td></tr></table></figure><p><strong>解析：</strong> 因为getData()方法的参数是List类型的，所以name，age，number都可以作为这个方法的实参，这就是通配符的作用</p><p>2、类型通配符上限通过形如List来定义，</p><p>如此定义就是通配符泛型值接受Number及其下层子类类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; name = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        List&lt;Integer&gt; age = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        List&lt;Number&gt; number = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br><span class="line">        </span><br><span class="line">        name.add(<span class="string">"icon"</span>);</span><br><span class="line">        age.add(<span class="number">18</span>);</span><br><span class="line">        number.add(<span class="number">314</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//getUperNumber(name);//1</span></span><br><span class="line">        getUperNumber(age);<span class="comment">//2</span></span><br><span class="line">        getUperNumber(number);<span class="comment">//3</span></span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">(List&lt;?&gt; data)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"data :"</span> + data.get(<span class="number">0</span>));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getUperNumber</span><span class="params">(List&lt;? extends Number&gt; data)</span> </span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"data :"</span> + data.get(<span class="number">0</span>));</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">data :<span class="number">18</span></span><br><span class="line">data :<span class="number">314</span></span><br></pre></td></tr></table></figure><p><strong>解析：</strong> 在(//1)处会出现错误，因为getUperNumber()方法中的参数已经限定了参数泛型上限为Number，所以泛型为String是不在这个范围之内，所以会报错</p><p>3、类型通配符下限通过形如 <strong>List</strong>来定义，表示类型只能接受Number及其三层父类类型，如 Object 类型的实例。</p><h2 id="五、泛型方法"><a href="#五、泛型方法" class="headerlink" title="五、泛型方法"></a>五、泛型方法</h2><p>你可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。</p><p>下面是定义泛型方法的规则：</p><ul><li>所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的<E>）。</li><li>每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。</li><li>类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。</li><li>泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（像int,double,char的等）。</li></ul><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例 1"></a>实例 1</h3><p>下面的例子演示了如何使用泛型方法打印不同字符串的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethodTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="comment">// 泛型方法 printArray                         </span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; <span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">( E[] inputArray )</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="comment">// 输出数组元素            </span></span><br><span class="line">         <span class="keyword">for</span> ( E element : inputArray )&#123;        </span><br><span class="line">            System.out.printf( <span class="string">"%s "</span>, element );</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String args[] )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 创建不同类型数组： Integer, Double 和 Character</span></span><br><span class="line">        Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">        Double[] doubleArray = &#123; <span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span> &#125;;</span><br><span class="line">        Character[] charArray = &#123; <span class="string">'H'</span>, <span class="string">'E'</span>, <span class="string">'L'</span>, <span class="string">'L'</span>, <span class="string">'O'</span> &#125;;</span><br><span class="line"> </span><br><span class="line">        System.out.println( <span class="string">"整型数组元素为:"</span> );</span><br><span class="line">        printArray( intArray  ); <span class="comment">// 传递一个整型数组</span></span><br><span class="line"> </span><br><span class="line">        System.out.println( <span class="string">"\n双精度型数组元素为:"</span> );</span><br><span class="line">        printArray( doubleArray ); <span class="comment">// 传递一个双精度型数组</span></span><br><span class="line"> </span><br><span class="line">        System.out.println( <span class="string">"\n字符型数组元素为:"</span> );</span><br><span class="line">        printArray( charArray ); <span class="comment">// 传递一个字符型数组</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">整型数组元素为:</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> </span><br><span class="line">双精度型数组元素为:</span><br><span class="line"><span class="number">1.1</span> <span class="number">2.2</span> <span class="number">3.3</span> <span class="number">4.4</span> </span><br><span class="line">字符型数组元素为:</span><br><span class="line">H E L L O</span><br></pre></td></tr></table></figure><p>在java中,泛型类的定义非常简单，但是泛型方法就比较复杂了。尤其是我们见到的大多数泛型类中的成员方法也都使用了泛型，有的甚至泛型类中也包含着泛型方法，这样在初学者中非常容易将泛型方法理解错了。</p><p><strong>泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型</strong> 。</p><h3 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型方法的基本介绍</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tClass 传入的泛型实参</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> T 返回值为T类型</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> *     1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。</span></span><br><span class="line"><span class="comment"> *     2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</span></span><br><span class="line"><span class="comment"> *     3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</span></span><br><span class="line"><span class="comment"> *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">genericMethod</span><span class="params">(Class&lt;T&gt; tClass)</span><span class="keyword">throws</span> InstantiationException ,</span></span><br><span class="line"><span class="function">  IllegalAccessException</span>&#123;</span><br><span class="line">        T instance = tClass.newInstance();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = genericMethod(Class.forName(<span class="string">"com.test.test"</span>));</span><br></pre></td></tr></table></figure><h3 id="5-1-泛型方法的基本用法"><a href="#5-1-泛型方法的基本用法" class="headerlink" title="5.1 泛型方法的基本用法"></a>5.1 泛型方法的基本用法</h3><p>光看上面的例子有的同学可能依然会非常迷糊，我们再通过一个例子，把我泛型方法再总结一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">   <span class="comment">//这个类是个泛型类，在上面已经介绍过</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123;     </span><br><span class="line">        <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。</span></span><br><span class="line">        <span class="comment">//这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。</span></span><br><span class="line">        <span class="comment">//所以在这个方法中才可以继续使用 T 这个泛型。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息"cannot reslove symbol E"</span></span><br><span class="line"><span class="comment">         * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。</span></span><br><span class="line"><span class="comment">        public E setKey(E key)&#123;</span></span><br><span class="line"><span class="comment">             this.key = keu</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 这才是一个真正的泛型方法。</span></span><br><span class="line"><span class="comment">     * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T</span></span><br><span class="line"><span class="comment">     * 这个T可以出现在这个泛型方法的任意位置.</span></span><br><span class="line"><span class="comment">     * 泛型的数量也可以为任意多个 </span></span><br><span class="line"><span class="comment">     *    如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123;</span></span><br><span class="line"><span class="comment">     *        ...</span></span><br><span class="line"><span class="comment">     *        &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">showKeyName</span><span class="params">(Generic&lt;T&gt; container)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"container key :"</span> + container.getKey());</span><br><span class="line">        <span class="comment">//当然这个例子举的不太合适，只是为了说明泛型方法的特性。</span></span><br><span class="line">        T test = container.getKey();</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue1</span><span class="params">(Generic&lt;Number&gt; obj)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符?</span></span><br><span class="line">    <span class="comment">//同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue2</span><span class="params">(Generic&lt;?&gt; obj)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法是有问题的，编译器会为我们提示错误信息："UnKnown class 'E' "</span></span><br><span class="line"><span class="comment">     * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。</span></span><br><span class="line"><span class="comment">     * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。</span></span><br><span class="line"><span class="comment">    public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123;</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">    &#125;  </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法也是有问题的，编译器会为我们提示错误信息："UnKnown class 'T' "</span></span><br><span class="line"><span class="comment">     * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。</span></span><br><span class="line"><span class="comment">     * 所以这也不是一个正确的泛型方法声明。</span></span><br><span class="line"><span class="comment">    public void showkey(T genericObj)&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-类中的泛型方法"><a href="#5-2-类中的泛型方法" class="headerlink" title="5. 2 类中的泛型方法"></a>5. 2 类中的泛型方法</h3><p>当然这并不是泛型方法的全部，泛型方法可以出现在任何地方和任何场景中使用。但是有一种情况是非常特殊的，当泛型方法出现在泛型类中时，我们再通过一个例子看一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericFruit</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"fruit"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"apple"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Person"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">GenerateTest</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show_1</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。</span></span><br><span class="line">        <span class="comment">//由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。</span></span><br><span class="line">        <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_3</span><span class="params">(E t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_2</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Apple apple = <span class="keyword">new</span> Apple();</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">        GenerateTest&lt;Fruit&gt; generateTest = <span class="keyword">new</span> GenerateTest&lt;Fruit&gt;();</span><br><span class="line">        <span class="comment">//apple是Fruit的子类，所以这里可以</span></span><br><span class="line">        generateTest.show_1(apple);</span><br><span class="line">        <span class="comment">//编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person</span></span><br><span class="line">        <span class="comment">//generateTest.show_1(person);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用这两个方法都可以成功</span></span><br><span class="line">        generateTest.show_2(apple);</span><br><span class="line">        generateTest.show_2(person);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用这两个方法也都可以成功</span></span><br><span class="line">        generateTest.show_3(apple);</span><br><span class="line">        generateTest.show_3(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-泛型方法与可变参数"><a href="#5-3-泛型方法与可变参数" class="headerlink" title="5.3 泛型方法与可变参数"></a>5.3 泛型方法与可变参数</h3><p>再看一个泛型方法和可变参数的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printMsg</span><span class="params">( T... args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(T t : args)&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"t is "</span> + t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printMsg(<span class="string">"111"</span>,<span class="number">222</span>,<span class="string">"aaaa"</span>,<span class="string">"2323.4"</span>,<span class="number">55.55</span>);</span><br></pre></td></tr></table></figure><h3 id="5-4-静态方法与泛型"><a href="#5-4-静态方法与泛型" class="headerlink" title="5.4 静态方法与泛型"></a>5.4 静态方法与泛型</h3><p>静态方法有一种情况需要注意一下，那就是在类中的静态方法使用泛型：<strong>静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。</strong></p><p>即：<strong>如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticGenerator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）</span></span><br><span class="line"><span class="comment">     * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。</span></span><br><span class="line"><span class="comment">     * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息：</span></span><br><span class="line"><span class="comment">          "StaticGenerator cannot be refrenced from static context"</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-泛型方法总结"><a href="#5-5-泛型方法总结" class="headerlink" title="5.5 泛型方法总结"></a>5.5 泛型方法总结</h3><p>泛型方法能使方法独立于类而产生变化，以下是一个基本的指导原则：</p><blockquote><p>无论何时，如果你能做到，你就该尽量使用泛型方法。也就是说，如果使用泛型方法将整个类泛型化，那么就应该使用泛型方法。另外对于一个static的方法，无法访问泛型类型的参数。所以如果static方法要使用泛型能力，就必须使其成为泛型方法。</p></blockquote><h2 id="六-泛型上下边界"><a href="#六-泛型上下边界" class="headerlink" title="六. 泛型上下边界"></a>六. 泛型上下边界</h2><p>在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。</p><p>为泛型添加上边界，即传入的类型实参必须是指定类型的子类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue1</span><span class="params">(Generic&lt;? extends Number&gt; obj)</span></span>&#123;</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Generic&lt;String&gt; generic1 = <span class="keyword">new</span> Generic&lt;String&gt;(<span class="string">"11111"</span>);</span><br><span class="line">Generic&lt;Integer&gt; generic2 = <span class="keyword">new</span> Generic&lt;Integer&gt;(<span class="number">2222</span>);</span><br><span class="line">Generic&lt;Float&gt; generic3 = <span class="keyword">new</span> Generic&lt;Float&gt;(<span class="number">2.4f</span>);</span><br><span class="line">Generic&lt;Double&gt; generic4 = <span class="keyword">new</span> Generic&lt;Double&gt;(<span class="number">2.56</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这一行代码编译器会提示错误，因为String类型并不是Number类型的子类</span></span><br><span class="line"><span class="comment">//showKeyValue1(generic1);</span></span><br><span class="line"></span><br><span class="line">showKeyValue1(generic2);</span><br><span class="line">showKeyValue1(generic3);</span><br><span class="line">showKeyValue1(generic4);</span><br></pre></td></tr></table></figure><p>如果我们把泛型类的定义也改一下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这一行代码也会报错，因为String不是Number的子类</span></span><br><span class="line">Generic&lt;String&gt; generic1 = <span class="keyword">new</span> Generic&lt;String&gt;(<span class="string">"11111"</span>);</span><br></pre></td></tr></table></figure><p>再来一个泛型方法的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在泛型方法中添加上下边界限制的时候，必须在权限声明与返回值之间的&lt;T&gt;上添加上下边界，即在泛型声明的时候添加</span></span><br><span class="line"><span class="comment">//public &lt;T&gt; T showKeyName(Generic&lt;T extends Number&gt; container)，编译器会报错："Unexpected bound"</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends Number&gt; <span class="function">T <span class="title">showKeyName</span><span class="params">(Generic&lt;T&gt; container)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"container key :"</span> + container.getKey());</span><br><span class="line">    T test = container.getKey();</span><br><span class="line">    <span class="keyword">return</span> test;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的两个例子可以看出：<strong>泛型的上下边界添加，必须与泛型的声明在一起</strong> 。要声明一个有界的类型参数，首先列出类型参数的名称，后跟extends关键字，最后紧跟它的上界。</p><p>有界的类型参数:可能有时候，你会想限制那些被允许传递到一个类型参数的类型种类范围。例如，一个操作数字的方法可能只希望接受Number或者Number子类的实例。这就是有界类型参数的目的。</p><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例 2"></a>实例 2</h3><p>下面的例子演示了”extends”如何使用在一般意义上的意思”extends”（类）或者”implements”（接口）。该例子中的泛型方法返回三个可比较对象的最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethodTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 比较三个值并返回最大值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function">T <span class="title">maximum</span><span class="params">(T x, T y, T z)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        T max = x; <span class="comment">// 假设x是初始最大值</span></span><br><span class="line">        <span class="keyword">if</span> ( y.compareTo( max ) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">            max = y; <span class="comment">//y 更大</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( z.compareTo( max ) &gt; <span class="number">0</span> )&#123;</span><br><span class="line">            max = z; <span class="comment">// 现在 z 更大</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max; <span class="comment">// 返回最大对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String args[] )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.printf( <span class="string">"%d, %d 和 %d 中最大的数为 %d\n"</span>,</span><br><span class="line">                <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, maximum( <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ) );</span><br><span class="line"></span><br><span class="line">        System.out.printf( <span class="string">"%.1f, %.1f 和 %.1f 中最大的数为 %.1f\n"</span>,</span><br><span class="line">                <span class="number">6.6</span>, <span class="number">8.8</span>, <span class="number">7.7</span>, maximum( <span class="number">6.6</span>, <span class="number">8.8</span>, <span class="number">7.7</span> ) );</span><br><span class="line"></span><br><span class="line">        System.out.printf( <span class="string">"%s, %s 和 %s 中最大的数为 %s\n"</span>,<span class="string">"pear"</span>,</span><br><span class="line">                <span class="string">"apple"</span>, <span class="string">"orange"</span>, maximum( <span class="string">"pear"</span>, <span class="string">"apple"</span>, <span class="string">"orange"</span> ) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">3</span>, <span class="number">4</span> 和 <span class="number">5</span> 中最大的数为 <span class="number">5</span></span><br><span class="line"><span class="number">6.6</span>, <span class="number">8.8</span> 和 <span class="number">7.7</span> 中最大的数为 <span class="number">8.8</span></span><br><span class="line">pear, apple 和 orange 中最大的数为 pear</span><br></pre></td></tr></table></figure><h2 id="七、关于泛型数组要提一下"><a href="#七、关于泛型数组要提一下" class="headerlink" title="七、关于泛型数组要提一下"></a>七、关于泛型数组要提一下</h2><p>看到了很多文章中都会提起泛型数组，经过查看sun的说明文档，在java中是<strong>”不能创建一个确切的泛型类型的数组”</strong>的。</p><p>也就是说下面的这个例子是不可以的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] ls = <span class="keyword">new</span> ArrayList&lt;String&gt;[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>而使用通配符创建泛型数组是可以的，如下面这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt;[] ls = <span class="keyword">new</span> ArrayList&lt;?&gt;[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>这样也是可以的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] ls = <span class="keyword">new</span> ArrayList[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>下面使用<a href="http://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html" target="_blank" rel="noopener">Sun</a><a href="http://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html" target="_blank" rel="noopener">的一篇文档</a>的一个例子来说明这个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] lsa = <span class="keyword">new</span> List&lt;String&gt;[<span class="number">10</span>]; <span class="comment">// Not really allowed.    </span></span><br><span class="line">Object o = lsa;    </span><br><span class="line">Object[] oa = (Object[]) o;    </span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();    </span><br><span class="line">li.add(<span class="keyword">new</span> Integer(<span class="number">3</span>));    </span><br><span class="line">oa[<span class="number">1</span>] = li; <span class="comment">// Unsound, but passes run time store check    </span></span><br><span class="line">String s = lsa[<span class="number">1</span>].get(<span class="number">0</span>); <span class="comment">// Run-time error: ClassCastException.</span></span><br></pre></td></tr></table></figure><blockquote><p>这种情况下，由于JVM泛型的擦除机制，在运行时JVM是不知道泛型信息的，所以可以给oa[1]赋上一个ArrayList而不会出现异常，但是在取出数据的时候却要做一次类型转换，所以就会出现ClassCastException，如果可以进行泛型数组的声明，上面说的这种情况在编译期将不会出现任何的警告和错误，只有在运行时才会出错。</p><p>而对泛型数组的声明进行限制，对于这样的情况，可以在编译期提示代码有类型安全问题，比没有任何提示要强很多。</p></blockquote><p>下面采用通配符的方式是被允许的:<strong>数组的类型不可以是类型变量，除非是采用通配符的方式</strong>，因为对于通配符的方式，最后取出数据是要做显式的类型转换的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt;[] lsa = <span class="keyword">new</span> List&lt;?&gt;[<span class="number">10</span>]; <span class="comment">// OK, array of unbounded wildcard type.    </span></span><br><span class="line">Object o = lsa;    </span><br><span class="line">Object[] oa = (Object[]) o;    </span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();    </span><br><span class="line">li.add(<span class="keyword">new</span> Integer(<span class="number">3</span>));    </span><br><span class="line">oa[<span class="number">1</span>] = li; <span class="comment">// Correct.    </span></span><br><span class="line">Integer i = (Integer) lsa[<span class="number">1</span>].get(<span class="number">0</span>); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><h2 id="八、特性：只在编译阶段有效"><a href="#八、特性：只在编译阶段有效" class="headerlink" title="八、特性：只在编译阶段有效"></a>八、特性：只在编译阶段有效</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringArrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; integerArrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">Class classStringArrayList = stringArrayList.getClass();</span><br><span class="line">Class classIntegerArrayList = integerArrayList.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(classStringArrayList.equals(classIntegerArrayList))&#123;</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"类型相同"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：D/泛型测试: 类型相同。</span><br></pre></td></tr></table></figure><p>通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p><p>JVM里没有泛型，对于所有的泛型对于虚拟机来讲都是属于普通类。</p><p>对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型</p><h2 id="九-最后"><a href="#九-最后" class="headerlink" title="九. 最后"></a>九. 最后</h2><p>本文中的例子主要是为了阐述泛型中的一些思想而简单举出的，并不一定有着实际的可用性。另外，一提到泛型，相信大家用到最多的就是在集合中，其实，在实际的编程过程中，自己可以使用泛型去简化开发，且能很好的保证代码质量。</p><hr><p>参考资料：<br>版权声明：本文为CSDN博主「VieLei」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/s10461/article/details/53941091" target="_blank" rel="noopener">https://blog.csdn.net/s10461/article/details/53941091</a></p><p><a href="https://www.runoob.com/java/java-generics.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-generics.html</a></p><p><a href="https://baike.baidu.com/item/java泛型/511821?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/java%E6%B3%9B%E5%9E%8B/511821?fr=aladdin</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 基础理解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合(容器)</title>
      <link href="/2019/12/09/Java%E9%9B%86%E5%90%88-%E5%8D%B3%E5%AE%B9%E5%99%A8/"/>
      <url>/2019/12/09/Java%E9%9B%86%E5%90%88-%E5%8D%B3%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一-集合类带来的好处"><a href="#一-集合类带来的好处" class="headerlink" title="一. 集合类带来的好处"></a>一. 集合类带来的好处</h2><ol><li><p>降低编程难度：在编程中会经常需要<a href="https://baike.baidu.com/item/链表/9794473" target="_blank" rel="noopener">链表</a>、<a href="https://baike.baidu.com/item/向量/20402530" target="_blank" rel="noopener">向量</a>等集合类，如果自己动手写代码实现这些类，需要花费较多的时间和精力。调用Java中提供的这些接口和类，可以很容易的处理数据。</p></li><li><p>提升程序的运行速度和质量：Java提供的集合类具有较高的质量，运行时速度也较快。使用这些集合类提供的数据结构，程序员可以从“重复造轮子”中解脱出来，将精力专注于提升程序的质量和性能。</p></li><li><p>无需再学习新的APl：借助<a href="https://baike.baidu.com/item/泛型/4475207" target="_blank" rel="noopener">泛型</a>，只要了解了这些类的使用方法，就可以将它们应用到很多数据类型中。如果知道了LinkedList<String>的使用方法，也会知道LinkedList<Double>怎么用，则无需为每一种数据类型学习不同的API。</p></li><li><p>增加代码重用性：也是借助泛型，就算对集合类中的元素类型进行了修改，集合类相关的代码也几乎不用修改。</p><blockquote><p>集合类的特点有三个：</p><ol><li>集合类这种框架是高性能的。对基本类集（动态数组，链接表，树和散列表）的实现是高效率的。一般人很少去改动这些已经很成熟并且高效的APl；</li><li>集合类允许不同类型的集合以相同的方式和高度互操作方式工作；</li><li>集合类容易扩展和修改，程序员可以很容易地稍加改造就能满足自己的数据结构需求。</li></ol></blockquote></li></ol><h2 id="二-集合架构"><a href="#二-集合架构" class="headerlink" title="二. 集合架构"></a>二. 集合架构</h2><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9pmpojefej30w60u0grb.jpg" alt=""></p><p>Java中的集合类可以分为两大类：<strong>一类是实现Collection接口；另一类是实现Map接口</strong>。</p><h2 id="三-实现Collection接口的集合区别"><a href="#三-实现Collection接口的集合区别" class="headerlink" title="三. 实现Collection接口的集合区别"></a>三. 实现Collection接口的集合区别</h2><p>所有Java集合类都位于Java.util包中，与Java数组不同，<strong>Java集合不能存放基本数据类型数据，而只能存放对象的引用</strong>。</p><h3 id="1-List集合：有序列表，允许存放重复的元素"><a href="#1-List集合：有序列表，允许存放重复的元素" class="headerlink" title="1. List集合：有序列表，允许存放重复的元素"></a>1. List集合：有序列表，允许存放重复的元素</h3><p>ArrayList和LinkedList在用法上没有区别，但是在功能上还是有区别的。</p><ul><li>ArrayList：数组实现，查询快，增删慢，轻量级；(线程不安全)，底层是Object数组，所以ArrayList具有数组的查询速度快的优点以及增删速度慢的缺点。</li><li>LinkedList：双向链表实现，增删快，查询慢 (线程不安全)，底层是一种双向循环链表。在此链表上每一个数据节点都由三部分组成：前指针（指向前面的节点的位置），数据，后指针（指向后面的节点的位置）。最后一个节点的后指针指向第一个节点的前指针，形成一个循环。双向循环链表的查询效率低但是增删效率高。利用LinkedList实现栈(stack)、队列(queue)、双向队列(double-ended queue )。 它具有方法addFirst()、addLast()、getFirst()、getLast()、removeFirst()、removeLast()等。</li><li>Vector：与ArrayList相似，区别是Vector是重量级的组件，使用使消耗的资源比较多。在考虑并发的情况下用Vector（保证线程的安全）,在不考虑并发的情况下用ArrayList（不能保证线程的安全）。</li></ul><h3 id="2-set集合：无序列表，不重复的数据"><a href="#2-set集合：无序列表，不重复的数据" class="headerlink" title="2. set集合：无序列表，不重复的数据"></a>2. set集合：无序列表，不重复的数据</h3><p>Set接口的特点是无序的，不重复的数据。对Set中任意的两个元素element1和element2都elementl.equals(element2)= false。另外，Set最多有一个null元素。此接口模仿了数学上的集合概念。检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。</p><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a><strong>HashSet</strong></h4><p>直接实现了Set接口，其底层其实是包装了一个HashMap去实现的。HashSet采用HashCode算法来存取集合中的元素，只不过生成一个HashSet的话，系统只提供key的访问； 如果有两个Key重复，那么会覆盖之前的；equals返回true，hashCode返回相同的整数；哈希表；存储的数据是无序的。因此具有比较好的读取和查找性能。线程非安全。HashSet元素值可以为NULL。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashSet常用方法：</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> ：如果set包含指定元素，返回<span class="keyword">true</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span>返回set中元素的迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object[] <span class="title">toArray</span><span class="params">()</span> ：返回包含set中所有元素的数组<span class="keyword">public</span> Object[] <span class="title">toArray</span><span class="params">(Object[] a)</span> ：返回包含set中所有元素的数组，返回数组的运行时类型是指定数组的运行时类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Object o)</span> ：如果set中不存在指定元素，则向set加入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> ：如果set中存在指定元素，则从set中删除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection c)</span> ：如果set包含指定集合，则从set中删除指定集合的所有元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection c)</span> ：如果set包含指定集合的所有元素，返回<span class="keyword">true</span>。如果指定集合也是一个set，只有是当前set的子集时，方法返回<span class="keyword">true</span></span></span><br></pre></td></tr></table></figure><p>HashSet的equals和HashCode：</p><blockquote><p>前面说过，Set集合是不允许重复元素的，否则将会引发各种奇怪的问题。那么HashSet如何判断元素重复呢？<br>HashSet需要同时通过equals和HashCode来判断两个元素是否相等，具体规则是，如果两个元素通过equals为true，并且两个元素的hashCode相等，则这两个元素相等（即重复）。<br>所以如果要重写保存在HashSet中的对象的equals方法，也要重写hashCode方法，重写前后hashCode返回的结果相等（即保证保存在同一个位置）。所有参与计算 hashCode() 返回值的关键属性，都应该用于作为 equals() 比较的标准。<br>试想如果重写了equals方法但不重写hashCode方法，即相同equals结果的两个对象将会被HashSet当作两个元素保存起来，这与我们设计HashSet的初衷不符（元素不重复）。<br>另外如果两个元素哈市Code相等但equals结果不为true，HashSet会将这两个元素保存在同一个位置，并将超过一个的元素以链表方式保存，这将影响HashSet的效率。<br>如果重写了equals方法但没有重写hashCode方法，则HashSet可能无法正常工作，比如下面的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tests</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tests</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Tests&#123;"</span> + <span class="string">"count="</span> + count + <span class="string">" # hashCode="</span> + <span class="keyword">this</span>.hashCode() + <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Tests r = (Tests) o;</span><br><span class="line">        <span class="keyword">return</span> count == r.count;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public int hashCode() &#123;</span></span><br><span class="line"><span class="comment">//        return Objects.hash(count);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set set = <span class="keyword">new</span> HashSet();</span><br><span class="line">        set.add(<span class="keyword">new</span> Tests(<span class="number">5</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> Tests(-<span class="number">3</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> Tests(<span class="number">9</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> Tests(-<span class="number">2</span>));</span><br><span class="line">        System.out.println(set.contains(<span class="keyword">new</span> Tests(-<span class="number">3</span>)));</span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注释掉hashCode方法，运行结果：</span><br><span class="line"><span class="keyword">false</span></span><br><span class="line">[Tests&#123;count=9 # hashCode=834600351&#125;, Tests&#123;count=-2 # hashCode=471910020&#125;, Tests&#123;count=-3 # hashCode=791452441&#125;, Tests&#123;count=5 # hashCode=321001045&#125;]</span><br><span class="line"></span><br><span class="line">取消注释，运行结果：</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line">[Tests&#123;count=5 # hashCode=36&#125;, Tests&#123;count=9 # hashCode=40&#125;, Tests&#123;count=-3 # hashCode=28&#125;, Tests&#123;count=-2 # hashCode=29&#125;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="如何达到不能存在重复元素的目的？"><a href="#如何达到不能存在重复元素的目的？" class="headerlink" title="如何达到不能存在重复元素的目的？"></a>如何达到不能存在重复元素的目的？</h6><p>“键”就是我们要存入的对象，“值”则是一个常量。这样可以确保，我们所需要的存储的信息是“键”。而“键”在Map中是不能重复的，这就保证了我们存入Set中的所有的元素都不重复。<br>HashSet如何过滤重复元素<br>调用元素HashCode获得哈希码—》判断哈希码是否相等，不相等则录入 —-》相等则判断equals()后是否相等，不相等在进行 hashcode录入，相等不录入</p></blockquote><h4 id="LinkedHashSet："><a href="#LinkedHashSet：" class="headerlink" title="LinkedHashSet："></a><strong>LinkedHashSet</strong>：</h4><p>是HashSet的一个子类，LinkedHashSet也根据HashCode的值来决定元素的存储位置，但同时它还用一个链表来维护元素的插入顺序，插入的时候即要计算hashCode又要维护链表，而遍历的时候只需要按链表来访问元素。此实现与HashSet的不同之外在于，后者维护着一个运行于所有条目的双重链接列表。存储的数据是有序的。查看LinkedHashSet的源码发现它是样的。</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2851667679971038690L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>JAVA8中， LinkedHashSet没有定义任何方法，只有四个构造函数，它的构造函数调用了父类（HashSet)的带三个参数的构造方法，父类的构造函数如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Constructs a new, empty linked hash set.  (This package private</span><br><span class="line">    * constructor is only used by LinkedHashSet.) The backing</span><br><span class="line">    * HashMap instance is a LinkedHashMap with the specified initial</span><br><span class="line">    * capacity and the specified load factor.</span><br><span class="line">    *</span><br><span class="line">    * @param      initialCapacity   the initial capacity of the hash map</span><br><span class="line">    * @param      loadFactor        the load factor of the hash map</span><br><span class="line">    * @param      dummy             ignored (distinguishes this</span><br><span class="line">    *             constructor from other int, float constructor.)</span><br><span class="line">    * @throws     IllegalArgumentException if the initial capacity is less</span><br><span class="line">    *             than zero, or if the load factor is nonpositive</span><br><span class="line">    */</span><br><span class="line">   HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;</span><br><span class="line">       map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>LinkedHashSet本质上也是从LinkedHashMap而来，LinkedHashSet的所有方法都继承自HashSet, 而它能维持元素的插入顺序的性质则继承自LinkedHashMap.</p><p><em>下面是一个LinkedHashSet维持元素插入顺序的例子</em>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedHashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tests</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set set = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">        set.add(<span class="string">"abc"</span>);</span><br><span class="line">        set.add(<span class="string">"efg"</span>);</span><br><span class="line">        set.add(<span class="string">"hjk"</span>);</span><br><span class="line">        System.out.println(set);</span><br><span class="line">        set.remove(<span class="keyword">new</span> String(<span class="string">"abc"</span>));</span><br><span class="line">        set.add(<span class="string">"abc"</span>);</span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">[abc, efg, hjk]</span><br><span class="line">[efg, hjk, abc]</span><br></pre></td></tr></table></figure></blockquote><h4 id="TreeSet类的特征"><a href="#TreeSet类的特征" class="headerlink" title="TreeSet类的特征"></a><strong>TreeSet类的特征</strong></h4><p>TreeSet实现了SortedSet接口，顾名思义这是一种排序的Set集合，查看jdk源码发现底层是用TreeMap实现的，本质上是一个红黑树原理。 正因为它是排序了的，所以相对HashSet来说，TreeSet提供了一些额外的按排序位置访问元素的方法，例如first(), last(), lower(), higher(), subSet(), headSet(), tailSet().</p><blockquote><p>TreeSet的排序分两种类型，一种是自然排序，另一种是定制排序。</p><p><strong>自然排序（在元素中写排序规则）</strong></p><p>TreeSet 会调用compareTo方法比较元素大小，然后按升序排序。所以自然排序中的元素对象，都必须实现了Comparable接口，否则会抛出异常。对于TreeSet判断元素是否重复的标准，也是调用元素从Comparable接口继承而来额compareTo方法，如果返回0则是重复元素（两个元素I相等）。Java的常见类都已经实现了Comparable接口，</p><p>下面举例说明没有实现Comparable存入TreeSet时引发异常的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSets</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set set = <span class="keyword">new</span> TreeSet();</span><br><span class="line">        set.add(<span class="keyword">new</span> Err());</span><br><span class="line">        set.add(<span class="keyword">new</span> Err());</span><br><span class="line">        set.add(<span class="keyword">new</span> Err());</span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Err</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行程序会抛出如下异常:</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.ClassCastException: clc.Err cannot be cast to java.lang.Comparable</span><br><span class="line">at java.util.TreeMap.compare(TreeMap.java:<span class="number">1294</span>)</span><br><span class="line">at java.util.TreeMap.put(TreeMap.java:<span class="number">538</span>)</span><br><span class="line">at java.util.TreeSet.add(TreeSet.java:<span class="number">255</span>)</span><br><span class="line">at clc.TestSets.main(TestSets.java:<span class="number">17</span>)</span><br></pre></td></tr></table></figure><p>将上面的Err类实现Comparable接口之后程序就能正常运行了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Err</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有个重要问题是，因为TreeSet会调用元素的compareTo方法，这就要求所有元素的类型都相同，否则也会发生异常。也就是说，TreeSet只允许存入同一类的元素。例如下面这个例子就会抛出类型转换异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Set set = <span class="keyword">new</span> TreeSet();</span><br><span class="line">  set.add(<span class="number">1</span>);</span><br><span class="line">  set.add(<span class="string">"2"</span>);</span><br><span class="line">  System.out.println(set);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果:</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.ClassCastException: java.lang.Integer cannot be cast to java.util.Date</span><br><span class="line">at java.util.Date.compareTo(Date.java:<span class="number">131</span>)</span><br><span class="line">at java.util.TreeMap.put(TreeMap.java:<span class="number">568</span>)</span><br><span class="line">at java.util.TreeSet.add(TreeSet.java:<span class="number">255</span>)</span><br><span class="line">at clc.TestSets.main(TestSets.java:<span class="number">19</span>)</span><br></pre></td></tr></table></figure><h6 id="定制排序（在集合中写排序规则）"><a href="#定制排序（在集合中写排序规则）" class="headerlink" title="定制排序（在集合中写排序规则）"></a>定制排序（在集合中写排序规则）</h6><p>TreeSet还有一种排序就是定制排序，定制排序时候，需要关联一个Comparator对象，由Comparator提供排序逻辑。下面就是一个使用Lambda表达式代替Comparator对象来提供定制排序的例子。下面是一个定制排序的列子：类似于C++容器sort()的参数bool cmp(){}函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tests</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set set = <span class="keyword">new</span> TreeSet(<span class="keyword">new</span> MyCommpare());</span><br><span class="line">        set.add(<span class="keyword">new</span> M(<span class="number">5</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> M(<span class="number">3</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> M(<span class="number">9</span>));</span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">M</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"age:"</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCommpare</span> <span class="keyword">implements</span> <span class="title">Comparator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">        M m1 = (M) o1;</span><br><span class="line">        M m2 = (M) o2;</span><br><span class="line">        <span class="keyword">return</span> m1.age &gt; m2.age ? <span class="number">1</span> : m1.age &lt; m2.age ? -<span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">[age:<span class="number">3</span>, age:<span class="number">5</span>, age:<span class="number">9</span>]</span><br></pre></td></tr></table></figure><p>当然将Comparator直接写入TreeSet初始化中也可以。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tests</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Set set = <span class="keyword">new</span> TreeSet(<span class="keyword">new</span> MyCommpare());</span><br><span class="line">        set.add(<span class="keyword">new</span> M(<span class="number">5</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> M(<span class="number">3</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> M(<span class="number">9</span>));</span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 将Comparator直接写入TreeSet初始化中1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set set = <span class="keyword">new</span> TreeSet(<span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">                M m1 = (M) o1;</span><br><span class="line">                M m2 = (M) o2;</span><br><span class="line">                <span class="keyword">return</span> m1.age &gt; m2.age ? <span class="number">1</span> : m1.age &lt; m2.age ? -<span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        set.add(<span class="keyword">new</span> M(<span class="number">5</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> M(<span class="number">3</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> M(<span class="number">9</span>));</span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Description: 将Comparator直接写入TreeSet初始化中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTreeSetLam</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set set = <span class="keyword">new</span> TreeSet((o1, o2) -&gt; &#123;</span><br><span class="line">            M m1 = (M) o1;</span><br><span class="line">            M m2 = (M) o2;</span><br><span class="line">            <span class="keyword">return</span> m1.age &gt; m2.age ? <span class="number">1</span> : m1.age &lt; m2.age ? -<span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        set.add(<span class="keyword">new</span> M(<span class="number">5</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> M(<span class="number">3</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> M(<span class="number">9</span>));</span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">M</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"age:"</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCommpare</span> <span class="keyword">implements</span> <span class="title">Comparator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">        M m1 = (M) o1;</span><br><span class="line">        M m2 = (M) o2;</span><br><span class="line">        <span class="keyword">return</span> m1.age &gt; m2.age ? <span class="number">1</span> : m1.age &lt; m2.age ? -<span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Err</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">[age:<span class="number">3</span>, age:<span class="number">5</span>, age:<span class="number">9</span>]</span><br></pre></td></tr></table></figure><p>TreeSet是一个有序集合，TreeSet中元素将按照升序排列，缺省是按照自然顺序进行排列，意味着TreeSet中元素要实现Comparable接口。我们可以在构造TreeSet对象时，传递实现了Comparator接口的比较器对象。</p><p><strong>Comparable和Comparator</strong><br>Comparable 接口以提供自然排序顺序。<br>对于那些没有自然顺序的类、或者当您想要一个不同于自然顺序的顺序时，您可以实现Comparator 接口来定义您自己的排序函数。可以将Comparator传递给Collections.sort或Arrays.sort。</p><p><strong>Comparator接口</strong><br>当一个类并未实现Comparable，或者不喜欢缺省的Comaparable行为。可以实现Comparator接口<br>直接实现Comparator的compare接口完成自定义比较类。<br>例：Arrays.sort(results, new Comparator<RepDataQueryResultVO>() 数组排序 RepDataQueryExecutor<br>例：Collections.sort(lst,new Comparator<TaskPrintSchemeVO>()</p></blockquote><ul><li><p><strong>EnumSet特征</strong><br>EnumSet顾名思义就是专为枚举类型设计的集合，因此集合元素必须是枚举类型，否则会抛出异常。 EnumSet集合也是有序的，其顺序就是Enum类内元素定义的顺序。 EnumSet存取的速度非常快，批量操作的速度也很快。EnumSet主要提供以下方法，allOf, complementOf, copyOf, noneOf, of, range等。注意到EnumSet并没有提供任何构造函数，要创建一个EnumSet集合对象，只需要调用allOf等方法，下面是一个EnumSet的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.EnumSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSets</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EnumSet es1 = EnumSet.allOf(Season<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(es1);</span><br><span class="line">        EnumSet es2 = EnumSet.noneOf(Season<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        es2.add(Season.WINTER);</span><br><span class="line">        es2.add(Season.SUMER);</span><br><span class="line">        System.out.println(es2);</span><br><span class="line">        EnumSet es3 = EnumSet.of(Season.WINTER, Season.SUMER);</span><br><span class="line">        System.out.println(es3);</span><br><span class="line">        EnumSet es4 = EnumSet.range(Season.SUMER,Season.WINTER );</span><br><span class="line">        System.out.println(es4);</span><br><span class="line">        EnumSet es5 = EnumSet.complementOf(es4);</span><br><span class="line">        System.out.println(es5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Season &#123;</span><br><span class="line">    SPRING, SUMER, FALL, WINTER</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line">[SPRING, SUMER, FALL, WINTER]</span><br><span class="line">[SUMER, WINTER]</span><br><span class="line">[SUMER, WINTER]</span><br><span class="line">[SUMER, FALL, WINTER]</span><br><span class="line">[SPRING]</span><br></pre></td></tr></table></figure></li></ul><h4 id="几种Set的比较："><a href="#几种Set的比较：" class="headerlink" title="几种Set的比较："></a><strong>几种Set的比较</strong>：</h4><ul><li>HashSet外部无序地遍历成员，成员可为任意Object子类的对象，但如果覆盖了equals方法，同时注意修改hashCode方法。HashSet是基于Hash算法实现的，其性能通常都优于TreeSet。我们通常都应该使用HashSet，在我们需要排序的功能时，我们才使用TreeSet。</li><li>TreeSet外部有序地遍历成员；附加实现了SortedSet, 支持子集等要求顺序的操作，成员要求实现Comparable接口，或者使用Comparator构造TreeSet。成员一般为同一类型。</li><li>LinkedHashSet外部按成员的插入顺序遍历成员，成员与HashSet成员类似。</li><li>HashSet的元素存放顺序和我们添加进去时候的顺序没有任何关系，而LinkedHashSet 则保持元素的添加顺序。TreeSet则是对我们的Set中的元素进行排序存放。</li><li>一般来说，当您要从集合中以有序的方式抽取元素时，TreeSet实现就会有用处。为了能顺利进行，添加到 TreeSet 的元素必须是可排序的。 而您同样需要对添加到TreeSet中的类对象实现 Comparable 接口的支持。一般说来，先把元素添加到 HashSet，再把集合转换为 TreeSet 来进行有序遍历会更快。</li></ul><h4 id="各种Set集合性能分析："><a href="#各种Set集合性能分析：" class="headerlink" title="各种Set集合性能分析："></a><strong>各种Set集合性能分析</strong>：</h4><ul><li>HashSet和TreeSet是Set集合中用得最多的I集合。HashSet总是比TreeSet集合性能好，因为HashSet不需要额维护元素的顺序。</li><li>LinkedHashSet需要用额外的链表维护元素的插入顺序，因此在插入时性能比HashSet低，但在迭代访问（遍历）时性能更高。因为插入的时候即要计算hashCode又要维护链表，而遍历的时候只需要按链表来访问元素。</li><li>EnumSet元素是所有Set元素中性能最好的，但是它只能保存Enum类型的元素</li></ul><h2 id="四-实现Map接口的集合区别"><a href="#四-实现Map接口的集合区别" class="headerlink" title="四. 实现Map接口的集合区别"></a>四. 实现Map接口的集合区别</h2><p>它提供了一组键值的映射。其中存储的每个对象都有一个相应的关键字(key)，关键字决定了对象在Map中的存储位置。<br>关键字应该是唯一的，每个key 只能映射一个value。实现类有HashMap、TreeMap、LinkedHashMap、Hashtable等</p><ul><li>HashMap：键值对，key不能重复，但是value可以重复；key的实现就是HashSet；value对应着放；允许null的键或值；</li><li>Hashtable：线程安全的，不允许null的键或值；</li><li>Properties:：key和value都是String类型，用来读配置文件；</li><li>TreeMap：对key排好序的Map; key 就是TreeSet, value对应每个key; key要实现Comparable接口或TreeMap有自己的构造器；</li><li>LinkedHashMap： 此实现与HashMap的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。存储的数据是有序的。</li></ul><h3 id="HashMap："><a href="#HashMap：" class="headerlink" title="HashMap："></a>HashMap：</h3><ul><li>Map 主要用于存储键(key)值(value)对，根据键得到值，因此键不允许重复,但允许值重复。</li><li>HashMap 是一个最常用的Map,它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度。</li><li>HashMap最多只允许一条记录的键为Null;允许多条记录的值为 Null;</li><li>HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步，可以用 Collections的synchronizedMap方法使HashMap具有同步的能力。</li></ul><blockquote><p> HashMap实现原理—-散列</p><p>Hash哈希算法的意义在于提供了一种快速存取数据的方法,它用一种算法建立键值与真实值之间的对应关系。散列表又称为哈希表。散列表算法的基本思想是：以结点的关键字为自变量，通过一定的函数关系（散列函数）计算出对应的函数值，以这个值作为该结点存储在散列表中地址。<br>当散列表中的元素存放太满，就必须进行再散列，将产生一个新的散列表，所有元素存放到新的散列表中，原先的散列表将被删除。在Java语言中，通过负载因子(load factor)来决定何时对散列表进行再散列。例如：如果负载因子0.75，当散列表中已经有75%位置已经放满，那么将进行再散列。<br>负载因子越高(越接近1.0)，内存的使用效率越高，元素的寻找时间越长。负载因子越低(越接近0.0)，元素的寻找时间越短，内存浪费越多。</p></blockquote><h3 id="何时需重写equals？"><a href="#何时需重写equals？" class="headerlink" title="何时需重写equals？"></a><strong>何时需重写</strong>equals？</h3><p>当一个类有自己特有的“逻辑相等”概念（不同于对象身份的概念）；<br>Object类仅仅提供了一个对引用的比较，如果两个引用不是同一个那就返回false，这是无法满足大多数对象比较的需要的，所以要覆盖；<br>使用==操作符检查实参是否为指向对象的引用”<br>使用instanceof操作符检查实参是否为正确的类型<br>把实参转换到正确的类型；<br>对于该类中每一个“关键”域，检查实参中的域与当前对象中对应的域值是否匹配。<strong>对于既不是float也不是double类型的基本类型的域，可以使用==操作符进行比较；对于对象引用类型的域，可以递归地调用所引用的对象的equals方法</strong>，对于float和double类型的域，先转换成int或long类型的值，然后使用==操作符比较；<br>当你编写完成了equals方法之后，应该问自己三个问题：它是否是对称的、传递的、一致的？ 如果答案是否定的，那么请找到 这些特性未能满足的原因，再修改equals方法的代码</p><h3 id="equals-和hashCode-同时覆写"><a href="#equals-和hashCode-同时覆写" class="headerlink" title="equals()和hashCode()同时覆写"></a><strong>equals</strong>()和hashCode()同时覆写</h3><p>尤其强调当一个对象被当作键值（或索引）来使用的时候要重写这两个方法；<br>覆写equals后，两个不同实例可能在逻辑上相等，但是根据Object.hashCode方法却产生不同的散列码，违反“相等的对象必须具有相等的散列码”。<br>导致，当你用其中的一个作为键保存到hashMap、hasoTable或hashSet中，再以“相等的”找另一个作为键值去查找他们的时候，则根本找不到。</p><p>不同类型的hashCode取值</p><ul><li>如果该域是布尔型的，计算（f ？0：1）</li><li>如果是char,short,byte或int，计算(int)f</li><li>如果是long类型，计算（int）(f^(f&gt;&gt;&gt;32))</li><li>如果是float类型，计算Float.floatToIntBits（f）</li><li>如果是double类型，计算Dobule.doubleToLongBits(f)</li><li>如果该域是一个对象引用，递归调用hashCode</li><li>如果该域是一个数组，则把每个元素当做单独的域来处理，对每个重要的元素计算一个散列码</li></ul><h3 id="Map集合比较："><a href="#Map集合比较：" class="headerlink" title="Map集合比较："></a><strong>Map集合比较：</strong></h3><ul><li>HashMap的存入顺序和输出顺序无关。</li><li>LinkedHashMap 则保留了键值对的存入顺序。</li><li>TreeMap则是对Map中的元素进行排序。</li><li>因为HashMap和LinkedHashMap 存储数据的速度比直接使用TreeMap 要快，存取效率要高。</li><li>当完成了所有的元素的存放后，我们再对整个的Map中的元素进行排序。这样可以提高整个程序的运行的效率，缩短执行时间。</li></ul><p>注意：TreeMap中是根据键（Key）进行排序的。而如果我们要使用TreeMap来进行正常的排序的话，Key 中存放的对象必须实现Comparable 接口。</p><h3 id="Map常用方法："><a href="#Map常用方法：" class="headerlink" title="Map常用方法："></a><strong>Map常用方法：</strong></h3><ul><li>Object put(Object key,Object value)：用来存放一个键-值对Map中</li><li>Object remove(Object key)：根据key(键)，移除键-值对，并将值返回</li><li>void putAll(Map mapping) ：将另外一个Map中的元素存入当前的Map中</li><li>void clear() ：清空当前Map中的元素</li><li>Object get(Object key) ：根据key(键)取得对应的值</li><li>boolean containsKey(Object key) ：判断Map中是否存在某键（key）</li><li>boolean containsValue(Object value):判断Map中是否存在某值(value)</li><li>public Set keySet() ：返回所有的键（key），并使用Set容器存放</li><li>public Collection values() ：返回所有的值（Value），并使用Collection存放</li><li>public Set entrySet() ：返回一个实现 Map.Entry 接口的元素 Set</li></ul><h3 id="遍历Map的四种方法"><a href="#遍历Map的四种方法" class="headerlink" title="遍历Map的四种方法"></a>遍历Map的四种方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Tests &#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</span><br><span class="line">        map.put(&quot;1&quot;, &quot;value1&quot;);</span><br><span class="line">        map.put(&quot;2&quot;, &quot;value2&quot;);</span><br><span class="line">        map.put(&quot;3&quot;, &quot;value3&quot;);</span><br><span class="line"></span><br><span class="line">        //第一种：普遍使用，keySet()返回所有的key值</span><br><span class="line">        for (String key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(&quot;key= &quot;+ key + &quot; and value= &quot; + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        //第二种 通过Map.entrySet使用iterator遍历key和value</span><br><span class="line">        Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line">        while (it.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;String, String&gt; entry = it.next();</span><br><span class="line">            System.out.println(&quot;key= &quot; + entry.getKey() + &quot; and value= &quot; + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        //第三种：推荐，尤其是容量大时 通过Map.entrySet遍历key和value</span><br><span class="line">        for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(&quot;key= &quot; + entry.getKey() + &quot; and value= &quot; + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        //第四种 通过Map.values()遍历所有的value，但不能遍历key</span><br><span class="line">        for (String v : map.values()) &#123;</span><br><span class="line">            System.out.println(&quot;value= &quot; + v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9pvbo86b6j313q0u018f.jpg" style="zoom:150%;" /></p><h3 id="HashMap和Hashtable的区别："><a href="#HashMap和Hashtable的区别：" class="headerlink" title="HashMap和Hashtable的区别："></a><strong>HashMap和Hashtable的区别：</strong></h3><p>HashMap和Hashtable都是java的集合类，都可以用来存放java对象，这是他们的相同点<br>以下是他们的区别：</p><ol><li>历史原因：<br>Hashtable是基于陈旧的Dictionary类的，HashMap是java 1.2引进的Map接口的一个现实。</li><li>同步性：<br>hashtable是同步的，这个类中的一些方法保证了Hashtable中的对象是线程安全的，而HashMap则是异步的，因此HashMap中的对象并不是线程安全的，因为同步的要求会影响执行的效率，所以如果你不需要线程安全的结合那么使用HashMap是一个很好的选择，这样可以避免由于同步带来的不必要的性能开销，从而提高效率，我们一般所编写的程序都是异步的，但如果是服务器端的代码除外。</li><li>值：<br>HashMap可以让你将空值作为一个表的条目的key或value<br>Hashtable是不能放入空值（null）的</li></ol><h3 id="ArrayList和Vector的区别："><a href="#ArrayList和Vector的区别：" class="headerlink" title="ArrayList和Vector的区别："></a><strong>ArrayList和Vector的区别</strong>：</h3><p>ArrayList与Vector都是java的集合类，都是用来存放java对象，这是他们的相同点，<br>区别：</p><ol><li>同步性： Vector是同步的，这个类的一些方法保证了Vector中的对象的线程安全的，而ArrayList则是异步的，因此ArrayList中的对象并不 是线程安全的，因为同步要求会影响执行的效率，所以你不需要线程安全的集合那么使用ArrayList是一个很好的选择，这样可以避免由于同步带来的不必 要的性能开销。</li><li>数据增长： 从内部实现的机制来讲，ArrayList和Vector都是使用数组（Array）来控制集合中的对象，当你向两种类型中增加元素的时候，如果元素的数目超过了内部数组目前的长度他们都需要扩展内部数组的长度，Vector缺省情况下自动增长原来一倍的数组长度，ArrayList是原来的50%，所以最后你获得的这个集合所占的空间总是比你实际需要的要大，所以如果你要在集合中保存大量的数据，那么使用Vector有一些优势，因为你可以通过设置集合的初始大小来避免不必要的资源开销。</li></ol><h3 id="线程安全总结："><a href="#线程安全总结：" class="headerlink" title="线程安全总结："></a><strong>线程安全总结：</strong></h3><ol><li>如果要求线程安全，使用Vector，Hashtable</li><li>如果不要求线程安全，使用ArrayList，LinkedList，HashMap</li><li>如果要求键值对，则使用HashMap，Hashtable</li><li>如果数据量很大，又要求线程安全考虑Vector</li></ol><h3 id="arraylist和linkedlist联系与区别"><a href="#arraylist和linkedlist联系与区别" class="headerlink" title="arraylist和linkedlist联系与区别"></a><strong>arraylist和linkedlist联系与区别</strong></h3><ol><li>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。</li><li>对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。</li><li>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。</li></ol><h3 id="HashMap与TreeMap联系与区别"><a href="#HashMap与TreeMap联系与区别" class="headerlink" title="HashMap与TreeMap联系与区别"></a><strong>HashMap与TreeMap联系与区别</strong></h3><ol><li>HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。</li><li>在Map 中插入、删除和定位元素，HashMap是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现。</li><li>两个map中的元素一样，但顺序不一样，导致hashCode()不一样。<br>同样做测试：<br>在HashMap中，同样的值的map,顺序不同，equals时，false;<br>而在treeMap中，同样的值的map,顺序不同，equals时，true，说明，treeMap在equals()时是整理了顺序了的。</li></ol><hr><p>参考资料：</p><ul><li><a href="https://www.cnblogs.com/chenglc/p/8073049.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenglc/p/8073049.html</a></li><li><a href="https://baike.baidu.com/item/java集合类/4758922?fr=aladdin#reference-[2]-7989307-wrap" target="_blank" rel="noopener">https://baike.baidu.com/item/java%E9%9B%86%E5%90%88%E7%B1%BB/4758922?fr=aladdin#reference-[2]-7989307-wrap</a></li><li><a href="https://www.runoob.com/java/java-collections.html" target="_blank" rel="noopener">https://www.runoob.com/java/java-collections.html</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 基础理解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>try_catch_finally关键字相关问题</title>
      <link href="/2019/12/08/try-catch-finally%E5%85%B3%E9%94%AE%E5%AD%97%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2019/12/08/try-catch-finally%E5%85%B3%E9%94%AE%E5%AD%97%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么时候用到finally呢-finally关键词在异常处理中如何使用"><a href="#1-什么时候用到finally呢-finally关键词在异常处理中如何使用" class="headerlink" title="1. 什么时候用到finally呢? finally关键词在异常处理中如何使用:"></a>1. 什么时候用到finally呢? finally关键词在异常处理中如何使用:</h3><p>不管异常会不会被捕捉或者处理都会执行的代码，某些事物（除内存外）在异常处理完后需要恢复到初始状态,如关闭IO操作, 关闭一些耗性能的资源，数据库的连接。</p><p>某些事物（除内存外）在异常在异常处理完后需要恢复到初始状态，如开启的文件，网络的连接等。</p><h3 id="2-try里有return，finally还执行么？inally语句在try或catch中的return语句执行之后，还是return返回之前执行呢？"><a href="#2-try里有return，finally还执行么？inally语句在try或catch中的return语句执行之后，还是return返回之前执行呢？" class="headerlink" title="2. try里有return，finally还执行么？inally语句在try或catch中的return语句执行之后，还是return返回之前执行呢？"></a>2. try里有return，finally还执行么？inally语句在try或catch中的return语句执行之后，还是return返回之前执行呢？</h3><p>这个题目也是考查异常相关的。对于这个题目，我们通过代码来验证我们的答案，因为有异议的知识点，代码是最有说服力的。这个问题是一个很经典的问题，经常被面试官问，如果自己不去实验一下，可能判断就会出错。我们结合代码来分析一下。下面我们通过4个demo来得出最终结论。</p><ul><li>test1</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test1():"</span> + test1());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"try..."</span>);</span><br><span class="line">            <span class="keyword">return</span> i += <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"catch..."</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">            System.out.println(<span class="string">"finally..."</span>);</span><br><span class="line">            System.out.println(<span class="string">"i="</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line"><span class="keyword">try</span>...</span><br><span class="line"><span class="keyword">finally</span>...</span><br><span class="line">i=<span class="number">12</span></span><br><span class="line">test1():<span class="number">11</span></span><br></pre></td></tr></table></figure><p>总结：finally代码块是在try代码块中的return语句执行之后，返回之前执行的。最外面的return i; 没有执行。无论finally代码块执行什么，返回值不变。</p><ul><li>test2</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"try..."</span>);</span><br><span class="line">            <span class="keyword">return</span> i += <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"catch..."</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">            System.out.println(<span class="string">"finally..."</span>);</span><br><span class="line">            System.out.println(<span class="string">"i="</span> + i);</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line"><span class="keyword">try</span>...</span><br><span class="line"><span class="keyword">finally</span>...</span><br><span class="line">i=<span class="number">12</span></span><br></pre></td></tr></table></figure><p>总结：finally代码块中的return语句覆盖try代码块中的return语句。</p><ul><li>test3</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = test3();</span><br><span class="line">        System.out.println(map.get(<span class="string">"KEY"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        map.put(<span class="string">"KEY"</span>, <span class="string">"INIT"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"try..."</span>);</span><br><span class="line">            map.put(<span class="string">"KEY"</span>, <span class="string">"TRY"</span>);</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"catch..."</span>);</span><br><span class="line">            map.put(<span class="string">"KEY"</span>, <span class="string">"CATCH"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"finally..."</span>);</span><br><span class="line">            map.put(<span class="string">"KEY"</span>, <span class="string">"FINALLY"</span>);</span><br><span class="line">            map = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">执行结果：</span><br><span class="line"><span class="keyword">try</span>...</span><br><span class="line"><span class="keyword">finally</span>...</span><br><span class="line">FINALLY</span><br></pre></td></tr></table></figure><p>总结： 如果finally语句中没有return语句覆盖返回值，那么原来的返回值可能因为finally里的修改而改变也可能不变。<strong>传值类型</strong>的返回值：不变；<strong>传址类型</strong>的返回值：会变。</p><blockquote><p>这里引入来一个新的问题，怎么判断一个变量是传值还是传址？</p><p>传值：8种基本数据类型及其包装类，字符常量。<em>不变</em></p><p>传址：数组和对象。<em>会变</em></p></blockquote><ul><li>test4</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test4返回："</span> + test4());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"try..."</span>);</span><br><span class="line">            i = i / <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> i += <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"catch..."</span>);</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">            System.out.println(<span class="string">"finally..."</span>);</span><br><span class="line">            System.out.println(<span class="string">"i="</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">执行结果：</span><br><span class="line"><span class="keyword">try</span>...</span><br><span class="line"><span class="keyword">catch</span>...</span><br><span class="line"><span class="keyword">finally</span>...</span><br><span class="line">i=<span class="number">2</span></span><br><span class="line">test4返回：<span class="number">1</span></span><br></pre></td></tr></table></figure><p>总结： try代码块中的return语句在异常的情况下不会被执行，这样具体返回哪个看情况；<strong>catch中的return执行情况与未发生异常时try中return的执行情况完全一样</strong>（如test4最后返回还是1）。</p><h3 id="3-如果执行finally代码块之前方法返回了结果，或者JVM退出了，finally块中的代码还会执行吗-在什么情况下，finally语句不会执行"><a href="#3-如果执行finally代码块之前方法返回了结果，或者JVM退出了，finally块中的代码还会执行吗-在什么情况下，finally语句不会执行" class="headerlink" title="3. 如果执行finally代码块之前方法返回了结果，或者JVM退出了，finally块中的代码还会执行吗? 在什么情况下，finally语句不会执行"></a>3. 如果执行finally代码块之前方法返回了结果，或者JVM退出了，finally块中的代码还会执行吗? 在什么情况下，finally语句不会执行</h3><ol><li>try语句没有被执行，如在try语句之前就返回了，这样finally语句就不会执行；因此说明了finally语句被执行的必要而非充分条件是：相应的try语句一定被执行到。</li><li>如果在try代码块中执行System.exit(0)语句;那么将终止Java虚拟机JVM，因此，finally语句也不会被执行到。</li><li>finally块的语句在try或catch中的<strong>return语句执行之后返回之前执行</strong>且finally里的修改语句可能影响也可能不影响try或catch中return已经确定的返回值，如果返回值类型为传址类型，则影响；传值类型，则不影响。</li><li>若finally里也有return语句则覆盖try或catch中的return语句直接返回。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的遍历和创建</title>
      <link href="/2019/12/06/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%92%8C%E5%88%9B%E5%BB%BA/"/>
      <url>/2019/12/06/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%92%8C%E5%88%9B%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="1-二叉树的遍历"><a href="#1-二叉树的遍历" class="headerlink" title="1. 二叉树的遍历"></a>1. 二叉树的遍历</h3><p>先序遍历、中序遍历、后序遍历，无论这三种遍历的哪一种，左子树一定先与右子树遍历；所谓的“先中后”是指访问根结点顺序在遍历中的位置。例外还有层次遍历，即广度优先遍历</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9ncg3d3gtj30py0eg3z4.jpg" style="zoom:40%;" /></p><ul><li><p>先序：<strong>根结点</strong>-&gt;&gt;左子树-&gt;&gt;右子树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(node* root)</span></span>&#123; <span class="comment">//先序遍历</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    preOrder(root-&gt;lchild);</span><br><span class="line">    preOrder(root-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>中序：左子树-&gt;&gt;<strong>根结点</strong>-&gt;&gt;右子树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(node* root)</span></span>&#123; <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inOrder(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,root-&gt;data);</span><br><span class="line">    inOrder(root-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>后序：左子树-&gt;&gt;右子树-&gt;&gt;<strong>根结点</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(node* root)</span></span>&#123; <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    postOrder(root-&gt;lchild);</span><br><span class="line">    postOrder(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,root-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>层次遍历（BFS遍历）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(node* root)</span></span>&#123;  <span class="comment">//层次遍历</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;node*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        node* now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,now-&gt;data);</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;lchild != <span class="literal">NULL</span>) q.push(now-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;rchild != <span class="literal">NULL</span>) q.push(now-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-创建二叉树"><a href="#2-创建二叉树" class="headerlink" title="2. 创建二叉树"></a>2. 创建二叉树</h3><p>中序序列可以与先序序列、后序序列、层序序列中的任意一个来构建唯一的二叉树，而后三者两两搭配或是三个一起上都无法构建唯一的二叉树。原因是先序、后序、层序均是提供根结点，功能是相同的，都必须由中序序列来区分出左右子树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    node* lchild;</span><br><span class="line">    node* rchild;</span><br><span class="line">    <span class="keyword">int</span> data;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; post;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; layer;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据中序和后序，创建二叉树</span></span><br><span class="line"><span class="function">node* <span class="title">createByPostAndIn</span><span class="params">(<span class="keyword">int</span> postL, <span class="keyword">int</span> postR, <span class="keyword">int</span> inL, <span class="keyword">int</span> inR)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(postL &gt; postR) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node* root = <span class="keyword">new</span> node;</span><br><span class="line">    root-&gt;data = post[postR];</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">for</span>(k = inL; k &lt;= inR; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[k] == post[postR])&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> numLeft = k - inL;  <span class="comment">//左子树的结点个数</span></span><br><span class="line">    root-&gt;lchild = createByPostAndIn(postL, postL + numLeft - <span class="number">1</span>, inL, k - <span class="number">1</span>);</span><br><span class="line">    root-&gt;rchild = createByPostAndIn(postL + numLeft, postR - <span class="number">1</span>, k + <span class="number">1</span>, inR);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据中序和前序，创建二叉树</span></span><br><span class="line"><span class="function">node* <span class="title">createByPreAndIn</span><span class="params">(<span class="keyword">int</span> preL, <span class="keyword">int</span> preR, <span class="keyword">int</span> inL, <span class="keyword">int</span> inR)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preL &gt; preR) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node* root = <span class="keyword">new</span> node;</span><br><span class="line">    root-&gt;data = pre[preL];</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">for</span>(k = inL; k &lt;= inR; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[k] == pre[preL])&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> numLeft = k - inL; <span class="comment">//左子树的结点个数</span></span><br><span class="line">    root-&gt;lchild = createByPreAndIn(preL + <span class="number">1</span>, preL + numLeft, inL, k - <span class="number">1</span>);</span><br><span class="line">    root-&gt;rchild = createByPreAndIn(preL + numLeft + <span class="number">1</span>, preR, k + <span class="number">1</span>, inR);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据中序和层序创建二叉树</span></span><br><span class="line"><span class="function">node* <span class="title">createByLayerAndIn</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; layer, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in, <span class="keyword">int</span> inL, <span class="keyword">int</span> inR)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(inL &gt; inR || layer.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    node* root = <span class="keyword">new</span> node;</span><br><span class="line">    root-&gt;data = layer[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">for</span>(pos = inL; pos &lt;= inR; pos++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[pos] == layer[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; layerLeft, layerRight; <span class="comment">//存放左、右子树的层序序列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; layer.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j = inL; j &lt; pos; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[j] == layer[i])&#123;</span><br><span class="line">                layerLeft.push_back(layer[i]); <span class="comment">//如果在pos前找到，插入左子树</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//超过pos，j==pos时即为在左子树中没有找到插入右子树（层序遍历保持左右子树层序遍历顺序的一致性）</span></span><br><span class="line">        <span class="keyword">if</span>(j == pos) layerRight.push_back(layer[i]); </span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;lchild = createByLayerAndIn(layerLeft, in, inL, pos - <span class="number">1</span>);</span><br><span class="line">    root-&gt;rchild = createByLayerAndIn(layerRight, in, pos + <span class="number">1</span>, inR);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(node* root)</span></span>&#123;  <span class="comment">//层次遍历</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;node*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        node* now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,now-&gt;data);</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; n)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;lchild != <span class="literal">NULL</span>) q.push(now-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;rchild != <span class="literal">NULL</span>) q.push(now-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(node* root)</span></span>&#123; <span class="comment">//先序遍历</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,root-&gt;data);</span><br><span class="line">    num++;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; n)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    preOrder(root-&gt;lchild);</span><br><span class="line">    preOrder(root-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(node* root)</span></span>&#123; <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inOrder(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,root-&gt;data);</span><br><span class="line">    num++;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; n)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    inOrder(root-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(node* root)</span></span>&#123; <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    postOrder(root-&gt;lchild);</span><br><span class="line">    postOrder(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,root-&gt;data);</span><br><span class="line">    num++;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; n)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">        in.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*测试数据：中后</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">1 2 3 4 5 6 7</span></span><br><span class="line"><span class="comment">2 3 1 5 7 6 4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">        post.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    node* root = createByPostAndIn(<span class="number">0</span>, n <span class="number">-1</span>, <span class="number">0</span>, n <span class="number">-1</span>);</span><br><span class="line"><span class="comment">/*测试数据：中前</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">1 2 3 4 5 6 7</span></span><br><span class="line"><span class="comment">4 1 3 2 6 5 7</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="comment">// for(int i = 0; i &lt; n; i++)&#123;</span></span><br><span class="line">    <span class="comment">//     scanf("%d",&amp;temp);</span></span><br><span class="line">    <span class="comment">//     pre.push_back(temp);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// node* root = createByPreAndIn(0, n -1, 0, n -1);</span></span><br><span class="line"><span class="comment">/*测试数据：中层</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">1 2 3 4 5 6 7</span></span><br><span class="line"><span class="comment">4 1 6 3 5 7 2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="comment">// for(int i = 0; i &lt; n; i++)&#123;</span></span><br><span class="line">    <span class="comment">//     scanf("%d",&amp;temp);</span></span><br><span class="line">    <span class="comment">//     layer.push_back(temp);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// node* root = createByLayerAndIn(layer, in, 0, n -1);</span></span><br><span class="line">    BFS(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/2019/12/05/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/12/05/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="快速排序思路："><a href="#快速排序思路：" class="headerlink" title="快速排序思路："></a>快速排序思路：</h3><p>快速排序时间最好情况下的复杂度为<script type="math/tex">O(\log_2 n)</script>，待排序序列越无序，本算法效率越高。最坏情况下的时间复杂度为<script type="math/tex">O(n^2)</script>，平均复杂度为$O(\log_2 n)$，</p><ul><li>对一个序列A[1]、A[2]、… 、A[n]，调整序列中元素的位置，一趟排序后，使得A[1]的左侧所有元素都不超过A[1]、右侧所有元素都大于A[1].</li><li>然后，以A[1]位置分割左右两部分递归快速排序</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一趟关键元素（主原）排序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = A[left];</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; A[right] &gt; temp) right--;</span><br><span class="line">        A[left] = A[right];</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; A[left] &lt;= temp ) left++;</span><br><span class="line">        A[right] = A[left];</span><br><span class="line">    &#125;</span><br><span class="line">    A[left] = temp;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化主原没有把区间[left,right]分成两个近似的子区间:随机的选择主原</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">randPartition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> randNum = (round(<span class="number">1.0</span>*rand()/RAND_MAX*(right - left) + left));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"randNum: %d\n"</span>,randNum);</span><br><span class="line">    swap(A[randNum],A[left]);</span><br><span class="line">    <span class="keyword">int</span> temp = A[left];</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; A[right] &gt; temp) right--;</span><br><span class="line">        A[left] = A[right];</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; A[left] &lt;= temp) left++;</span><br><span class="line">        A[right] = A[left]; </span><br><span class="line">    &#125;</span><br><span class="line">    A[left] = temp;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="comment">//int pos = partition(A,left,right);</span></span><br><span class="line">        <span class="keyword">int</span> pos = randPartition(A,left,right);</span><br><span class="line">        quickSort(A,left,pos - <span class="number">1</span>);</span><br><span class="line">        quickSort(A,pos + <span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A[] = &#123;<span class="number">35</span>,<span class="number">18</span>,<span class="number">16</span>,<span class="number">72</span>,<span class="number">24</span>,<span class="number">65</span>,<span class="number">12</span>,<span class="number">88</span>,<span class="number">46</span>,<span class="number">28</span>,<span class="number">100</span>,<span class="number">66</span>,<span class="number">866</span>&#125;;</span><br><span class="line">    quickSort(A,<span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,A[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/2019/12/05/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/12/05/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="二路归并排序思路："><a href="#二路归并排序思路：" class="headerlink" title="二路归并排序思路："></a>二路归并排序思路：</h3><p>将原始序列看作N个只包含一个元素的有序子序列，然后每次迭代归并两个相邻的有序子序列，直到最后只剩下一个有序的序列。时间复杂度为<script type="math/tex">O(\log_2 n)</script></p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将数组A的[L1,R1]与[L2,R2]区间合并为有序的区间</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> L1, <span class="keyword">int</span> R1, <span class="keyword">int</span> L2, <span class="keyword">int</span> R2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=L1, j=L2;</span><br><span class="line">    <span class="keyword">int</span> temp[maxn], index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; R1 &amp;&amp; j &lt; R2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &lt;= A[j])&#123;</span><br><span class="line">            temp[index++] = A[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp[index++] = A[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; R1) temp[index++] = A[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt; R2) temp[index++] = A[j++];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">        A[L1 + <span class="number">1</span>] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2路归并归并排序: 递归实现</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        mergeSort(A, left, mid);</span><br><span class="line">        mergeSort(A, mid+<span class="number">1</span>, right);</span><br><span class="line">        merge(A, left, mid, mid + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2路归并归并排序：非递归实现</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> A[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">step</span> = <span class="number">2</span>; <span class="built_in">step</span> / <span class="number">2</span> &lt;= n; <span class="built_in">step</span> *= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="built_in">step</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = i + <span class="built_in">step</span> / <span class="number">2</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid + <span class="number">1</span> &lt;= n)&#123;</span><br><span class="line">                merge(A, i, mid, mid + <span class="number">1</span>, <span class="built_in">min</span>(i + <span class="built_in">step</span> - <span class="number">1</span>,n));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插入排序</title>
      <link href="/2019/12/05/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/12/05/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="直接插入思路："><a href="#直接插入思路：" class="headerlink" title="直接插入思路："></a>直接插入思路：</h3><p>每趟将一个待排序的关键字按照其值的大小，插入到有序序列中的正确的位置，直到全部序列有序。其时间复杂度为<script type="math/tex">O(n^2)</script>, 待排序的元素超过<script type="math/tex">10^5</script>的规模时是无法承受的。</p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">getArrayLen</span>(<span class="title">T</span>&amp;<span class="title">array</span>)&#123;</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">sizeof</span>(<span class="built_in">array</span>) / <span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入排序的代码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;= n; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> temp = A[i], j = i;</span><br><span class="line"><span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; temp &lt; A[j - <span class="number">1</span>])&#123;</span><br><span class="line">A[j] = A[j - <span class="number">1</span>];</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">A[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[] = &#123;<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n = getArrayLen(A);</span><br><span class="line">insertSort(A,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,A[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>two pointers编程思想</title>
      <link href="/2019/12/05/two-pointers%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/"/>
      <url>/2019/12/05/two-pointers%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是two-pointers"><a href="#什么是two-pointers" class="headerlink" title="什么是two pointers"></a>什么是two pointers</h3><p>two pointers是算法编程中一种非常重要的思想，或者说是一种编程技巧。它非常简洁和高效。</p><ul><li><p>以一个例子引入：给定一个递增的正整数序列和一个正整数M，求序列中的两个不同位置的数a和b,使得它们的和恰好为M，输出所有满足条件的方案。如给定序列{1,2,3,4,5,6}和正好是M=8，就存在2+6=8与3+5=8成立。</p><p>直观的想法是使用二重循环枚举序列中的a和b，判断和是否为M</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i] + a[j] == M)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, a[i], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，这种做法时间复杂度为<script type="math/tex">O(n^2)</script>，对n在<script type="math/tex">10^5</script>的规模时是无法承受的。</p><p>two pointers实现方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">  <span class="keyword">if</span>(a[i] + a[j] == M)&#123;</span><br><span class="line">    i++;</span><br><span class="line">    j--;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i] + a[j] &lt; M)&#123;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    j--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n)，two pointers思想充分利用了序列递增的性质，以很浅显的思想降低了复杂度。</p></li><li><p>再来看一个序列合并的问题：假如两个非递减序列A和B，要求将它们合并为一个非递减序列C。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> B[], <span class="keyword">int</span> C[], <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123; <span class="comment">//n,m分别为A，B的序列长度</span></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i &lt; n &amp;&amp; j &lt; m)&#123;</span><br><span class="line">    <span class="keyword">if</span>(A[i] &lt;= B[j])&#123;</span><br><span class="line">      C[index++] = A[i++];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      C[index++] = B[j++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(i &lt; n) C[index++] = A[i++];</span><br><span class="line">  <span class="keyword">while</span>(j &lt; m) C[index++] = B[j++];</span><br><span class="line">  <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Two pointers 利用问题本身与序列的特性，使用两个下标i,j对序列进行扫描（可以同向扫描，也可以反响扫描），以较低的复杂度（一般是O(n)的复杂度）解决问题。</p></li></ul><h3 id="例子B1030-A1085-完美数列：-two-pointers实现"><a href="#例子B1030-A1085-完美数列：-two-pointers实现" class="headerlink" title="例子B1030/A1085 完美数列：  two pointers实现"></a>例子B1030/A1085 完美数列：  two pointers实现</h3><p>给定一个正整数数列，和正整数 <em>p</em>，设这个数列中的最大值是 <em>M</em>，最小值是 <em>m</em>，如果 <em>M</em>≤<em>m**p</em>，则称这个数列是完美数列。</p><p>现在给定参数 <em>p</em> 和一些正整数，请你从中选择尽可能多的数构成一个完美数列。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出两个正整数 <em>N</em> 和 <em>p</em>，其中 <em>N</em>（≤105）是输入的正整数的个数，<em>p</em>（≤109）是给定的参数。第二行给出 <em>N</em> 个正整数，每个数不超过 109。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10 8</span><br><span class="line">2 3 20 4 5 1 6 7 8 9</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n,p,num[maxn];</span><br><span class="line"><span class="comment">//two pointers实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(num, num + n);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n &amp;&amp; j &lt; n)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; n &amp;&amp; num[j] &lt;= (<span class="keyword">long</span> <span class="keyword">long</span>)num[i] * p)&#123;</span><br><span class="line">            count = <span class="built_in">max</span>(count, j - i + <span class="number">1</span>);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lower_bound和upper_bound函数应用</title>
      <link href="/2019/12/05/lower-bound%E5%92%8Cupper-bound%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8/"/>
      <url>/2019/12/05/lower-bound%E5%92%8Cupper-bound%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="二分查找的应用-lower-bound-和upper-bound"><a href="#二分查找的应用-lower-bound-和upper-bound" class="headerlink" title="二分查找的应用 lower_bound( )和upper_bound( )"></a>二分查找的应用 lower_bound( )和upper_bound( )</h4><ul><li>使用时需要引用c++标准库中<algorithm>  </li></ul><p>在从小到大的排序数组中:</p><ul><li>lower_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于或等于num的数字,找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</li><li>upper_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个大于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</li></ul><p>在从大到小的排序数组中:</p><ul><li>lower_bound( begin,end,num,greater<type>() ):从数组的begin位置到end-1位置二分查找第一个小于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</li><li>upper_bound( begin,end,num,greater<type>() ):从数组的begin位置到end-1位置二分查找第一个小于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</li></ul><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">2</span>*<span class="keyword">int</span>(<span class="number">1e9</span>)+<span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">6</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">15</span>,<span class="number">34</span>&#125;; </span><br><span class="line">sort(num,num+<span class="number">6</span>);                           <span class="comment">//按从小到大排序 </span></span><br><span class="line"><span class="keyword">int</span> pos1=lower_bound(num,num+<span class="number">6</span>,<span class="number">7</span>)-num;    <span class="comment">//返回数组中第一个大于或等于被查数的值 </span></span><br><span class="line"><span class="keyword">int</span> pos2=upper_bound(num,num+<span class="number">6</span>,<span class="number">7</span>)-num;    <span class="comment">//返回数组中第一个大于被查数的值</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;pos1&lt;&lt;<span class="string">" "</span>&lt;&lt;num[pos1]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;pos2&lt;&lt;<span class="string">" "</span>&lt;&lt;num[pos2]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">sort(num,num+<span class="number">6</span>,cmd);                      <span class="comment">//按从大到小排序</span></span><br><span class="line"><span class="keyword">int</span> pos3=lower_bound(num,num+<span class="number">6</span>,<span class="number">7</span>,greater&lt;<span class="keyword">int</span>&gt;())-num;  <span class="comment">//返回数组中第一个小于或等于被查数的值 </span></span><br><span class="line"><span class="keyword">int</span> pos4=upper_bound(num,num+<span class="number">6</span>,<span class="number">7</span>,greater&lt;<span class="keyword">int</span>&gt;())-num;  <span class="comment">//返回数组中第一个小于被查数的值 </span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;pos3&lt;&lt;<span class="string">" "</span>&lt;&lt;num[pos3]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;pos4&lt;&lt;<span class="string">" "</span>&lt;&lt;num[pos4]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"><span class="number">3</span> <span class="number">7</span></span><br><span class="line"><span class="number">4</span> <span class="number">15</span></span><br><span class="line"><span class="number">2</span> <span class="number">7</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><ul><li>lower_bound和upper_bound的代码，</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> cmpX)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">       mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[mid] &gt;= cmpX)</span><br><span class="line">        &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> cmpX)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">       mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[mid] &gt; cmpX)</span><br><span class="line">        &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以作为解决“寻找有序序列第一个满足某一条件的元素的位置”问题的固定模版。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">二分区间[left,right]为左闭右闭，初值要必须覆盖</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(条件成立)&#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><p>给定一个正整数数列，和正整数 <em>p</em>，设这个数列中的最大值是 <em>M</em>，最小值是 <em>m</em>，如果 <em>M</em>≤<em>m**p</em>，则称这个数列是完美数列。</p><p>现在给定参数 <em>p</em> 和一些正整数，请你从中选择尽可能多的数构成一个完美数列。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出两个正整数 <em>N</em> 和 <em>p</em>，其中 <em>N</em>（≤105）是输入的正整数的个数，<em>p</em>（≤109）是给定的参数。第二行给出 <em>N</em> 个正整数，每个数不超过 109。</p><h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10 8</span><br><span class="line">2 3 20 4 5 1 6 7 8 9</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><p>代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n,p,num[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num[n - <span class="number">1</span>] &lt;= x) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> l = i + <span class="number">1</span>, r = n - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(num[mid] &lt;= x)&#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// int main()&#123;</span></span><br><span class="line"><span class="comment">//     scanf("%d %d",&amp;n,&amp;p);</span></span><br><span class="line"><span class="comment">//     for(int i = 0; i &lt; n; i++)&#123;</span></span><br><span class="line"><span class="comment">//         scanf("%d",&amp;num[i]);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     sort(num,num + n,cmp);</span></span><br><span class="line"><span class="comment">//     int ans = 1;</span></span><br><span class="line"><span class="comment">//     for(int i = 0; i &lt; n; i++)&#123;</span></span><br><span class="line"><span class="comment">//         int j = binarySearch(i,(long long)num[i]*p);</span></span><br><span class="line"><span class="comment">//         ans = max(ans,j - i);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     printf("%d\n",ans);</span></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;p);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(num, num + n);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> j = upper_bound(num + i + <span class="number">1</span>, num + n, (<span class="keyword">long</span> <span class="keyword">long</span>)num[i]*p) - num;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, j - i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法</title>
      <link href="/2019/12/04/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
      <url>/2019/12/04/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><p>贪心是用来解决一类最优化问题，一般就是问最多，最少，最大值，最小值，最短，最长，只要这个题考最。。。。或者问怎么才能使。。。。。我们就可以考虑贪心算法。</p><h2 id="1-简单贪心"><a href="#1-简单贪心" class="headerlink" title="1. 简单贪心"></a>1. 简单贪心</h2><p>求解一类最优化问题的方法，它总是考虑在当前状态下局部最优（或较优）的策略，来使全局的结果达到最优（或较优）。而要获得最优结果，则要求中间的每步策略都是最优的，因此在严谨的使用贪心法求解最优问题，需要对采取的策略进行证明。证明的一般思路是使用反正法及数学归纳法。</p><h3 id="下面两个使用贪心的小例子："><a href="#下面两个使用贪心的小例子：" class="headerlink" title="下面两个使用贪心的小例子："></a>下面两个使用贪心的小例子：</h3><h4 id="1-求最大收益"><a href="#1-求最大收益" class="headerlink" title="1.  求最大收益"></a>1.  求最大收益</h4><p>月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。</p><p>注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有 3 种月饼，其库存量分别为 18、15、10 万吨，总售价分别为 75、72、45 亿元。如果市场的最大需求量只有 20 万吨，那么我们最大收益策略应该是卖出全部 15 万吨第 2 种月饼、以及 5 万吨第 3 种月饼，获得 72 + 45/2 = 94.5（亿元）。</p><h4 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h4><p>每个输入包含一个测试用例。每个测试用例先给出一个不超过 1000 的正整数 <em>N</em> 表示月饼的种类数、以及不超过 500（以万吨为单位）的正整数 <em>D</em> 表示市场最大需求量。随后一行给出 <em>N</em> 个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出 <em>N</em> 个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。</p><h4 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h4><p>对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后 2 位。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3 20</span><br><span class="line">18 15 10</span><br><span class="line">75 72 45</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">94.50</span><br></pre></td></tr></table></figure><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Goods</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> store;</span><br><span class="line">    <span class="keyword">double</span> sell;</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">&#125;goods[<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Goods a,Goods b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.price &gt; b.price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">double</span> d,total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%lf"</span>,&amp;n,&amp;d);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;goods[i].store);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;       <span class="comment">//求局部最优</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;goods[i].sell);</span><br><span class="line">        goods[i].price = goods[i].sell / goods[i].store;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(goods,goods + n,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(d &gt;= goods[j].store)&#123;</span><br><span class="line">            total = total + goods[j].sell;</span><br><span class="line">            d = d - goods[j].store;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            total = total + d * goods[j].price;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2f\n"</span>,total);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-求最小组成的数"><a href="#2-求最小组成的数" class="headerlink" title="2. 求最小组成的数"></a>2. 求最小组成的数</h3><p>给定数字 0-9 各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意 0 不能做首位）。例如：给定两个 0，两个 1，三个 5，一个 8，我们得到的最小的数就是 10015558。</p><p>现给定数字，请编写程序输出能够组成的最小的数。</p><h4 id="输入格式：-1"><a href="#输入格式：-1" class="headerlink" title="输入格式："></a>输入格式：</h4><p>输入在一行中给出 10 个非负整数，顺序表示我们拥有数字 0、数字 1、……数字 9 的个数。整数间用一个空格分隔。10 个数字的总个数不超过 50，且至少拥有 1 个非 0 的数字。</p><h4 id="输出格式：-1"><a href="#输出格式：-1" class="headerlink" title="输出格式："></a>输出格式：</h4><p>在一行中输出能够组成的最小的数。</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 2 0 0 0 3 0 0 1 0</span><br></pre></td></tr></table></figure><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10015558</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;count[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)&#123; <span class="comment">//局部最小值1</span></span><br><span class="line">        <span class="keyword">if</span>(count[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,i);</span><br><span class="line">            count[i]--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;count[i]; j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-区间贪心"><a href="#2-区间贪心" class="headerlink" title="2. 区间贪心"></a>2. 区间贪心</h2><p>区间不相交问题：给出N个开区间(x, y)，从中选择尽可能多的开区间，使得这些开区间两两没有交集。</p><p>看到区间比大小，我们第一个应该想起这个题，应该就是这个题的本质，根据端点去判断，这就是区间题的突破口。</p><p>图a, <strong>区间包含</strong>，应该选择I1,这样的话就可以给其他区间腾出很多的空闲位置；</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9m1vn8vosj30fq09w0t1.jpg" style="zoom:50%;" /></p><p>图b,<strong>区间重叠</strong>，总是选择左端点最大的区间，即I1</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1g9m1w15efxj30vo0ee763.jpg" style="zoom:50%;" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*区间贪心</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Inteval</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;I[<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//以左端点作为端点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpLeft</span><span class="params">(Inteval a,Inteval b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x != b.x)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.x &gt; b.x; <span class="comment">//左端点不同的，从大到小排序</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.y &lt; b.y; <span class="comment">//左端点相同的，从小到大排序 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以右端点作为端点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpRight</span><span class="params">(Inteval a,Inteval b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.y != b.y)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.y &lt; b.y;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.x &gt; b.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n), n != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;I[i].x, &amp;I[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(I, I + n, cmpLeft);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>, lastX = I[<span class="number">0</span>].x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(I[i].y &lt;= lastX)&#123;</span><br><span class="line">                lastX = I[i].x;</span><br><span class="line">                ans ++; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,<span class="string">"=========================="</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">        sort(I, I + n, cmpRight);</span><br><span class="line">        <span class="keyword">int</span> ansr = <span class="number">1</span>, lastRX = I[<span class="number">0</span>].y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(I[i].x &lt;= lastRX)&#123;</span><br><span class="line">                lastRX = I[i].y;</span><br><span class="line">                ansr ++; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ansr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> 数据结构和算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL视图的使用</title>
      <link href="/2019/11/29/SQL%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/11/29/SQL%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="1-视图作用"><a href="#1-视图作用" class="headerlink" title="1.视图作用"></a>1.视图作用</h3><p>试图是虚拟的表。与包含数据的表不一样，试图只包含使用时动态的检索数据的查询。 可以用与表基本相同的方式使用它们。对视图执行select操作，过滤和排序数据，将视图联结到其他视图或表，甚至添加和更新数据（添加和更新数据有某些限制） </p><ul><li>简化复杂的SQL操作，过滤信息，计算字段等。编写查询后，可以方便的重用它而不必知道其基本查询细节</li><li>使用表的一部分而不是整个表。</li><li>保护数据。可以授予用户访问表的特定部分的权限，而不是整个表的访问权限</li><li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li></ul><h3 id="2-视图的规则和限制"><a href="#2-视图的规则和限制" class="headerlink" title="2.视图的规则和限制"></a>2.视图的规则和限制</h3><ul><li>与表一样，视图命名必须唯一。视图的数目没有限制。</li><li>要有创建视图的权限。</li><li>视图可以嵌套，可以利用从其他视图中检索数据的查询来构造视图。（嵌套视图可能会严重降低查询性能，在生产环境中使用之前，应该对其进行全面的测试）</li><li>许多DBMS（Microsoft在SQL Server）禁止在视图查询中使用ORDER BY子句</li><li>有些DBMS要求对返回的所有列进行命名，如果列是计算字段，需要使用别名。</li><li>有些DBMS把视图作为自渎的查询。不能将数据写回底层表。</li></ul><h3 id="3-创建视图"><a href="#3-创建视图" class="headerlink" title="3.创建视图"></a>3.创建视图</h3><h4 id="3-1-利用视图极大简化了复杂的联结"><a href="#3-1-利用视图极大简化了复杂的联结" class="headerlink" title="3.1 利用视图极大简化了复杂的联结"></a>3.1 利用视图极大简化了复杂的联结</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.cust_name,c.cust_contact</span><br><span class="line"><span class="keyword">FROM</span> Customers c, Orders o, OrderItems i</span><br><span class="line"><span class="keyword">WHERE</span> c.cust_id = o.cust_id</span><br><span class="line"><span class="keyword">AND</span> i.order_num = o.order_num</span><br><span class="line"><span class="keyword">AND</span> i.prod_id = <span class="string">'RGAN01'</span>;</span><br></pre></td></tr></table></figure><p>创建：我想把上面这条查询包装成为一个名为ProductCustomers的虚拟表（视图）：<strong>创建视图时尽量不绑定特定数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> ProductCustomers <span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> c.cust_name,c.cust_contact</span><br><span class="line"><span class="keyword">FROM</span> Customers c, Orders o, OrderItems i</span><br><span class="line"><span class="keyword">WHERE</span> c.cust_id = o.cust_id</span><br><span class="line"><span class="keyword">AND</span> i.order_num = o.order_num;</span><br></pre></td></tr></table></figure><p>查询：可以通过下面语句检索相同数据,<strong>利用视图极大简化了复杂的联结</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name,cust_contact</span><br><span class="line"><span class="keyword">FROM</span> ProductCustomers</span><br><span class="line"><span class="keyword">WHERE</span> prod_id = <span class="string">'RGAN01'</span>;</span><br></pre></td></tr></table></figure><p>删除：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> ProductCustomers;</span><br></pre></td></tr></table></figure><h4 id="3-2-利用视图格式化检索出的数据"><a href="#3-2-利用视图格式化检索出的数据" class="headerlink" title="3.2 利用视图格式化检索出的数据"></a>3.2 利用视图格式化检索出的数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(<span class="keyword">RTRIM</span>(vend_name),<span class="string">"("</span>,<span class="keyword">RTRIM</span>(vend_country),<span class="string">")"</span> )</span><br><span class="line"><span class="keyword">AS</span> vend_title</span><br><span class="line"><span class="keyword">FROM</span> Vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Vend_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">RTRIM</span>(vend_name) + <span class="string">'('</span> + <span class="keyword">RTRIM</span>(vend_country) + <span class="string">')'</span></span><br><span class="line"><span class="keyword">AS</span> vend_title</span><br><span class="line"><span class="keyword">FROM</span> Vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">RTRIM</span>(vend_name) || <span class="string">'('</span> || <span class="keyword">RTRIM</span>(vend_country) || <span class="string">')'</span></span><br><span class="line"><span class="keyword">AS</span> vend_title</span><br><span class="line"><span class="keyword">FROM</span> Vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br><span class="line"></span><br><span class="line">上面3条语句执行结果相同</span><br></pre></td></tr></table></figure><p>假设经常使用这个格式的结果，不用在每次需要时执行这样的拼接，而是创建一个视图：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> VendorLocations <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">RTRIM</span>(vend_name) + <span class="string">'('</span> + <span class="keyword">RTRIM</span>(vend_country) + <span class="string">')'</span></span><br><span class="line"><span class="keyword">AS</span> vend_title</span><br><span class="line"><span class="keyword">FROM</span> Vendors;</span><br><span class="line"></span><br><span class="line">查询时执行：</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> VendorLocations;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>视图为虚拟的表。它们包含的不是数据而是根据需要检索数据的查询。提供一套封装select语句的层次，可用来简化数据处理，重新格式化或保护基础数据。</p>]]></content>
      
      
      
        <tags>
            
            <tag> sql </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部署Hexo博客到阿里云centOS7</title>
      <link href="/2019/11/23/%E9%83%A8%E7%BD%B2Hexo%E5%8D%9A%E5%AE%A2%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91centOS7/"/>
      <url>/2019/11/23/%E9%83%A8%E7%BD%B2Hexo%E5%8D%9A%E5%AE%A2%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91centOS7/</url>
      
        <content type="html"><![CDATA[<h3 id="1、博客的架构"><a href="#1、博客的架构" class="headerlink" title="1、博客的架构"></a>1、博客的架构</h3><p>先搞明白Hexo博客从搭建到自动发布的架构，才能更好的理解我们每一步进行的操作。<br>不然只跟着步骤过了一遍，却不知道为什么这么做。</p><p>首先看这张架构图：<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g97sxjyakcj31dt0u0qab.jpg" alt=""></p><h3 id="2、整个搭建流程"><a href="#2、整个搭建流程" class="headerlink" title="2、整个搭建流程"></a>2、整个搭建流程</h3><p>第一部分: 服务器环境搭建，包括安装 Git 、Nginx配置 、创建 git 用户 。</p><p>第二部分: 本地Hexo初始化， 包括安装 NodeJS 、hexo-cli, 生成本地静态网站</p><p>第三部分: 使用Git自动化部署发布博客</p><h3 id="3、服务器环境搭建"><a href="#3、服务器环境搭建" class="headerlink" title="3、服务器环境搭建"></a>3、服务器环境搭建</h3><h4 id="3-1-安装Git和NodeJS-CentOS-环境"><a href="#3-1-安装Git和NodeJS-CentOS-环境" class="headerlink" title="3-1.安装Git和NodeJS (CentOS 环境)"></a>3-1.安装Git和NodeJS (CentOS 环境)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install git</span><br><span class="line">#安装NodeJS</span><br><span class="line">curl --silent --location https://rpm.nodesource.com/setup_5.x | bash -</span><br></pre></td></tr></table></figure><h4 id="3-2-创建git普通用户"><a href="#3-2-创建git普通用户" class="headerlink" title="3-2. 创建git普通用户"></a>3-2. 创建git普通用户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adduser git      </span><br><span class="line">sudo passwd git  #设置git用户的密码</span><br></pre></td></tr></table></figure><p>在本地电脑执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub git@SERVER</span><br></pre></td></tr></table></figure><br>如果你之前没有生成过公钥，则可能就没有 id_rsa.pub 文件，具体的生成方法，可以<br><a href="https://help.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent" target="_blank" rel="noopener">参考这里</a></p><p>切换至git用户， 可以看到~/.ssh/authorized_keys 文件里已经有了本地电脑的公钥拷贝，这样就建立了ssh信任<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">su git</span><br><span class="line">mkdir ~/.ssh</span><br><span class="line">cat ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><br>然后在本地就可以执行ssh 命令测试是否可以免密登录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -v git@SERVER</span><br></pre></td></tr></table></figure><br>为了安全起见禁用git用户的 shell 登录权限，从而只能用git clone,git push等登录，执行如下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/shells  #查看`git-shell`是否在登录方式里面，有则跳过</span><br><span class="line">which git-shell  #查看是否安装</span><br><span class="line">vi /etc/shells  #添加上显示出来的路劲，通常在/usr/bin/git-shell</span><br><span class="line">vi /etc/passwd</span><br><span class="line">    把 git:x:1000:1000::/home/git:/bin/bash</span><br><span class="line">    修改为 git:x:1000:1000::/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure><br>至此，gituser用户添加完成</p><h4 id="3-3-nginx安装和配置"><a href="#3-3-nginx安装和配置" class="headerlink" title="3-3. nginx安装和配置"></a>3-3. nginx安装和配置</h4><p>注意：新买到阿里云centOS7是没有开通80端口的，添加端口<a href="https://blog.csdn.net/moyanxiaoq/article/details/85221262" target="_blank" rel="noopener">：参考这里</a>  </p><p>安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y git nginx</span><br></pre></td></tr></table></figure><br>配置 找到nginx的配置文件，修改配置如下：vim /etc/nginx/nginx.conf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line"> listen 80;</span><br><span class="line">    #listen [::]:80;</span><br><span class="line">    server_name localhost;</span><br><span class="line">    index index.html index.htm index.php default.html default.htm default.php;</span><br><span class="line">    #这里要改成网站的根目录</span><br><span class="line">    root  /home/git/projects/repos/blog/;</span><br><span class="line"></span><br><span class="line">    #include other.conf;</span><br><span class="line">    #error_page   404   /404.html;</span><br><span class="line">    location ~ .*\.(ico|gif|jpg|jpeg|png|bmp|swf)$</span><br><span class="line">    &#123;</span><br><span class="line">        access_log   off;</span><br><span class="line">        expires      1d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ .*\.(js|css|txt|xml)?$</span><br><span class="line">    &#123;</span><br><span class="line">        access_log   off;</span><br><span class="line">        expires      12h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        try_files $uri $uri/ =404;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>nginx -s reload  //刷新配置<br>如果报如下错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nginx: [error] open() &quot;/run/nginx.pid&quot; failed (2: No such file or directory)</span><br><span class="line"></span><br><span class="line">执行可解决：</span><br><span class="line">/usr/sbin/nginx -c /etc/nginx/nginx.conf   #使用指定nginx.conf文件的方式重启nginx</span><br></pre></td></tr></table></figure><br>启动: 输入：nginx<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">如果发现如下报错：</span><br><span class="line">nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)</span><br><span class="line">nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)</span><br><span class="line">nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)</span><br><span class="line">nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)</span><br><span class="line">nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)</span><br><span class="line">nginx: [emerg] still could not bind()</span><br><span class="line">说明80端口被占用，杀掉这个进程：</span><br><span class="line"></span><br><span class="line">killall -9 nginx</span><br><span class="line">再次启动nginx</span><br><span class="line"></span><br><span class="line">查看是否启动：</span><br><span class="line">ps aux|grep nginx</span><br><span class="line"></span><br><span class="line">root      2484  0.0  0.2 120832  2104 ?        Ss   18:04   0:00 nginx: master process nginx</span><br><span class="line">root      2485  0.0  0.3 121228  3128 ?        S    18:04   0:00 nginx: worker process</span><br><span class="line">root      2494  0.0  0.0 112676   980 pts/7    R+   18:08   0:00 grep --color=auto nginx</span><br><span class="line"></span><br><span class="line">启动成功。</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">centOS7访问nginx失败解决-.0:80 failed (98: Address already in use)解决</span><br><span class="line"></span><br><span class="line">以防万一，先安装好iptables服务（不管你装没装，先执行，免得后面添乱）</span><br><span class="line">[root@localhost ~]# yum install iptables-services</span><br><span class="line">[root@localhost ~]# systemctl mask firewalld.service</span><br><span class="line">[root@localhost ~]# systemctl enable iptables.service</span><br><span class="line">[root@localhost ~]# systemctl enable ip6tables.service</span><br><span class="line">进入iptables配置80端口，因为nginx默认是由80端口访问</span><br><span class="line">[root@localhost ~]# vim /etc/sysconfig/iptables</span><br><span class="line">这是配置信息：</span><br><span class="line"># Generated by iptables-save v1.4.21 on Fri May 12 21:28:29 2017</span><br><span class="line">*filter</span><br><span class="line">:INPUT ACCEPT [0:0]</span><br><span class="line">:FORWARD ACCEPT [0:0]</span><br><span class="line">:OUTPUT ACCEPT [6:696]</span><br><span class="line">-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">-A INPUT -p icmp -j ACCEPT</span><br><span class="line">-A INPUT -i lo -j ACCEPT</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 21 -j ACCEPT（我给vsftpd配置的端口）</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT（给nginx配置的端口，原样输入就行了）</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 30000:30999 -j ACCEPT</span><br><span class="line">-A INPUT -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line">-A FORWARD -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line">COMMIT</span><br><span class="line"># Completed on Fri May 12 21:28:29 2017</span><br><span class="line">然后:wq，保存退出就行了</span><br><span class="line">重启iptables，配置才生效</span><br><span class="line">[root@localhost ~]# systemctl restart iptables.service</span><br><span class="line">开启防火墙，不管你开没有，再开一遍：</span><br><span class="line">[root@localhost ~]# systemctl start firewalld</span><br><span class="line">开启http访问</span><br><span class="line">[root@localhost ~]# firewall-cmd --permanent --add-service=http</span><br><span class="line">加入80端口</span><br><span class="line">[root@localhost ~]# firewall-cmd --permanent --zone=trusted --add-port=80/tcp</span><br><span class="line">启动nginx！！！！（重点来了！！！）</span><br><span class="line">centOS7的nginx启动与其他的有区别！！！注意：我是装的nginx1.80，在centOS6.X系列中，是通过</span><br><span class="line">cd /usr/local/nginx/sbin/</span><br></pre></td></tr></table></figure><h3 id="4-本地Hexo程序"><a href="#4-本地Hexo程序" class="headerlink" title="4. 本地Hexo程序"></a>4. 本地Hexo程序</h3><h4 id="4-1：初始化Hexo博客"><a href="#4-1：初始化Hexo博客" class="headerlink" title="4-1：初始化Hexo博客"></a>4-1：初始化Hexo博客</h4><p>首先要安装 hexo-cli，安装hexo-cli 需要 root 权限，使用 sudo 运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure><br>然后初始化Hexo程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure><br>等执行成功以后安装两个插件， hexo-deployer-git 和 hexo-server ,这俩插件的作用分别是使用Git自动部署，和本地简单的服务器。<br><a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git帮助文档</a><br><a href="https://hexo.io/zh-cn/docs/server.html" target="_blank" rel="noopener">hexo-server帮助文档</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd blog</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hero -server</span><br></pre></td></tr></table></figure></p><h4 id="4-2-生成自己的第一篇文章-hello-world"><a href="#4-2-生成自己的第一篇文章-hello-world" class="headerlink" title="4-2. 生成自己的第一篇文章 hello world !"></a>4-2. 生成自己的第一篇文章 hello world !</h4><p>使用 hexo new &lt;文章名称&gt; 来新建文章，该命令会成成一个 .md文件放置在 sources/_posts文件夹。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;hello Hexo&quot;</span><br><span class="line">vim sources/_posts/hello-hexo.md</span><br></pre></td></tr></table></figure><br>编辑完毕以后， 使用hexo g将 .md文件渲染成静态文件，然后启动hexo s：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><br>打开浏览器访问 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 来查看我们的博客了！</p><h3 id="5-自动化部署"><a href="#5-自动化部署" class="headerlink" title="5. 自动化部署"></a>5. 自动化部署</h3><h4 id="5-1：服务器上建立git裸库"><a href="#5-1：服务器上建立git裸库" class="headerlink" title="5-1：服务器上建立git裸库"></a>5-1：服务器上建立git裸库</h4><p>创建一个裸仓库，裸仓库就是只保存git信息的Repository, 首先切换到gituser用户确保gituser用户拥有仓库所有权<br>一定要加 —bare，这样才是一个裸库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">su git</span><br><span class="line">cd ~</span><br><span class="line">mkdir -p projects/blog</span><br><span class="line">mkdir repos &amp;&amp; cd repos</span><br><span class="line">git init --bare blog.git</span><br></pre></td></tr></table></figure></p><h4 id="5-2-使用-git-hooks-同步网站根目录"><a href="#5-2-使用-git-hooks-同步网站根目录" class="headerlink" title="5-2. 使用 git-hooks 同步网站根目录"></a>5-2. 使用 git-hooks 同步网站根目录</h4><p>在这里我们使用的是 post-receive这个钩子，当git有收发的时候就会调用这个钩子。 在 ~/blog.git 裸库的 hooks文件夹中，<br>新建post-receive文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim ./blog.git/hooks/post-receive</span><br><span class="line"></span><br><span class="line">#!/bin/sh</span><br><span class="line">git --work-tree=/home/git/projects/blog --git-dir=/home/git/repos/blog.git checkout -f</span><br></pre></td></tr></table></figure><br>保存后，要赋予这个文件可执行权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ./blog.git/hooks/post-receive</span><br><span class="line">cd ~</span><br><span class="line">chown -R git:git /home/git/repos/blog.git/   #添加权限</span><br></pre></td></tr></table></figure></p><h4 id="5-3-配置-config-yml-完成自动化部署"><a href="#5-3-配置-config-yml-完成自动化部署" class="headerlink" title="5-3. 配置_config.yml,完成自动化部署"></a>5-3. 配置_config.yml,完成自动化部署</h4><p>然后打开 _config.yml, 找到 deploy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo: git@SERVER:/home/git/blog.git    //&lt;repository url&gt;</span><br><span class="line">    branch: master            //这里填写分支   [branch]</span><br><span class="line">    message: 提交的信息         //自定义提交信息 (默认为 Site updated: &#123;&#123; now(&apos;YYYY-MM-DD HH:mm:ss&apos;) &#125;&#125;)</span><br></pre></td></tr></table></figure><br>保存后，尝试将我们刚才写的”hello hexo”部署到服务器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate --deploy</span><br></pre></td></tr></table></figure><br>访问服务器地址，就可以看到我们写的文章”Hello hexo”,以后写文章只需要：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;Blog article name&quot;</span><br><span class="line">···写文章</span><br><span class="line">hexo clean &amp;&amp; hexo generate --deploy</span><br></pre></td></tr></table></figure></p><p>参考文档：</p><ol><li><a href="https://blog.csdn.net/moyanxiaoq/article/details/85221262" target="_blank" rel="noopener">https://blog.csdn.net/moyanxiaoq/article/details/85221262</a></li><li><a href="https://segmentfault.com/a/1190000005723321" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005723321</a></li><li><a href="http://www.swiftyper.com/2016/04/17/deploy-hexo-with-git-hook/" target="_blank" rel="noopener">http://www.swiftyper.com/2016/04/17/deploy-hexo-with-git-hook/</a></li><li><a href="https://help.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent" target="_blank" rel="noopener">https://help.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent</a></li><li><a href="https://www.bilibili.com/video/av50025574?from=search&amp;seid=11458733547652119175" target="_blank" rel="noopener">https://www.bilibili.com/video/av50025574?from=search&amp;seid=11458733547652119175</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 操作记录 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java关键字之static</title>
      <link href="/2019/11/22/Java%E5%85%B3%E9%94%AE%E5%AD%97%E4%B9%8Bstatic/"/>
      <url>/2019/11/22/Java%E5%85%B3%E9%94%AE%E5%AD%97%E4%B9%8Bstatic/</url>
      
        <content type="html"><![CDATA[<h4 id="一-什么是static关键字"><a href="#一-什么是static关键字" class="headerlink" title="一. 什么是static关键字"></a>一. 什么是static关键字</h4><ul><li>我们可以基于一个类创建多个该类的对象，每个对象都拥有自己的成员，互相独立。然而在某些时候，我们更希望该类所有的对象共享同一个成员。此时就是 static 大显身手的时候了！！</li><li>Java 中被 static修饰的成员称为静态成员或类成员。它属于整个类所有，而不是某个对象所有，即被==类的所有对象==所共享。</li><li>方便在没有创建对象的情况下进行调用（变量或方法）。</li><li>静态成员可以使用类名直接访问，也可以使用对象名进行访问。</li></ul><h4 id="二-静态变量"><a href="#二-静态变量" class="headerlink" title="二. 静态变量"></a>二. 静态变量</h4><p>使用 static 可以修饰变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// static修饰的变量为静态变量，所有类的对象共享hobby</span></span><br><span class="line">    <span class="keyword">static</span> String hobby = <span class="string">"Tedu"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 静态变量可以直接使用类名来访问，无需创建对象</span></span><br><span class="line">        System.out.println(<span class="string">"通过类名访问hobby："</span> + Test1.hobby);</span><br><span class="line">        <span class="comment">// 创建类的对象</span></span><br><span class="line">        Test1 t1 = <span class="keyword">new</span> Test1();</span><br><span class="line">        <span class="comment">// 使用对象名访问静态变量</span></span><br><span class="line">        System.out.println(<span class="string">"使用对象名访hobby:"</span> + t1.hobby);</span><br><span class="line">        <span class="comment">// 使用对象名的形式修改静态变量的值</span></span><br><span class="line">        t1.hobby = <span class="string">"cjj"</span>;</span><br><span class="line">        <span class="comment">// 再次使用类名访问静态白变量，值已经被修改</span></span><br><span class="line">        System.out.println(<span class="string">"通过类名访问hobby："</span> + Test1.hobby);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通过类名访问hobby：Tedu</span><br><span class="line">使用对象名访hobby:Tedu</span><br><span class="line">通过类名访问hobby：cjj</span><br></pre></td></tr></table></figure></p><h4 id="三-static-使用之静态方法"><a href="#三-static-使用之静态方法" class="headerlink" title="三. static 使用之静态方法"></a>三. static 使用之静态方法</h4><p>使用 static 修饰方法，称为静态方法或类方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用static关键字声明静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"欢迎你：Cjj!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//直接使用类名调用静态方法</span></span><br><span class="line">        Test01.print();</span><br><span class="line">        <span class="comment">//也可以通过对象名调用，当然更推荐使用类名调用</span></span><br><span class="line">        Test01 t1 = <span class="keyword">new</span> Test01();</span><br><span class="line">        t1.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">欢迎你：Cjj!</span><br><span class="line">欢迎你：Cjj!</span><br></pre></td></tr></table></figure><br>3.static 使用之静态初始化块<br>Java 中可以通过初始化块进行数据赋值。如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p><strong>注意：</strong>  </p><ol><li>静态成员属于整个类，当系统第一次使用该类时，就会为其分配内存空间直到该类被卸载才会进行资源回收！~~ </li><li>静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态成员。如：<br><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g94qojv9thj30x4096jsf.jpg" alt=""><br>如果希望在静态方法中调用非静态变量，可以通过创建类的对象，然后通过对象来访问非静态变量。如：<br><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g94qpd5dvhj30x20cmabh.jpg" alt=""></li><li>在普通成员方法中，则可以直接访问同类的非静态变量和静态变量，如：<br><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g94qqy58fnj30x60a8t9s.jpg" alt=""></li><li>静态方法中不能直接调用非静态方法，需要通过对象来访问非静态方法。如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    String name = <span class="string">"Cjj"</span>; <span class="comment">//非静态成员变量</span></span><br><span class="line">    <span class="keyword">static</span> String hobby = <span class="string">"study"</span>; <span class="comment">//静态成员变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//普通成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"普通成员方法~~~"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//静态成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"静态成员方法~~~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//普通成员方法必须通过对象来调用</span></span><br><span class="line">        Test01 t1 = <span class="keyword">new</span> Test01();</span><br><span class="line">        t1.print1();</span><br><span class="line">        <span class="comment">//可以直接调用静态方法</span></span><br><span class="line">        print2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四-static-使用之静态初始化块"><a href="#四-static-使用之静态初始化块" class="headerlink" title="四.static 使用之静态初始化块"></a>四.static 使用之静态初始化块</h4>Java 中可以通过初始化块进行数据赋值。如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    String name = <span class="string">"chenyw"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过初始化块为成员变量赋值</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = <span class="string">"cjj"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test01 test01 = <span class="keyword">new</span> Test01();</span><br><span class="line">        System.out.println(<span class="string">"name="</span>+test01.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>运行结果：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=cjj</span><br></pre></td></tr></table></figure></li></ol><p><strong>注意：</strong></p><p>静态初始化块只在类加载时执行，且只会执行一次，同时静态初始化块只能给静态变量赋值，不能初始化普通的成员变量。</p><p>我们来看一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1;</span><br><span class="line">    <span class="keyword">int</span> num2;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num3;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test02</span><span class="params">()</span> </span>&#123;<span class="comment">// 构造方法</span></span><br><span class="line">        num1 = <span class="number">11</span>;</span><br><span class="line">        System.out.println(<span class="string">"通过构造方法为变量num1赋值"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// 初始化块</span></span><br><span class="line">        num2 = <span class="number">22</span>;</span><br><span class="line">        System.out.println(<span class="string">"通过初始化块为变量num2赋值"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;<span class="comment">// 静态初始化块</span></span><br><span class="line">        num3 = <span class="number">33</span>;</span><br><span class="line">        System.out.println(<span class="string">"通过静态初始化块为静态变量num3赋值"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test02 t1 = <span class="keyword">new</span> Test02(); <span class="comment">//创建对象</span></span><br><span class="line">        System.out.println(<span class="string">"num1:"</span> + t1.num1);</span><br><span class="line">        System.out.println(<span class="string">"num2:"</span> + t1.num2);</span><br><span class="line">        System.out.println(<span class="string">"num3:"</span> + num3);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">通过静态初始化块为静态变量num3赋值</span><br><span class="line">通过初始化块为变量num2赋值</span><br><span class="line">通过构造方法为变量num1赋值</span><br><span class="line">num1:11</span><br><span class="line">num2:22</span><br><span class="line">num3:33</span><br></pre></td></tr></table></figure><br><em>通过输出结果，我们可以看到，程序运行时静态初始化块最先被执行，然后执行普通初始化块，最后才执行构造方法。由于静态初始化块只在类加载时执行一次，所以当再次创建对象 hello2 时并未执行静态初始化块。类是在第一次使用的时候才加载，加载之后就不会移除</em></p><p>内容来源：<a href="https://www.cnblogs.com/chuijingjing/p/9452893.html" target="_blank" rel="noopener">https://www.cnblogs.com/chuijingjing/p/9452893.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 基础理解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建自己的Hexo博客</title>
      <link href="/2019/11/22/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/11/22/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h4 id="1-安装node-js"><a href="#1-安装node-js" class="headerlink" title="1.安装node.js"></a>1.安装node.js</h4><p>Hexo需用通过npm安装，而npm需要node，现在只要安装node 就自带 npm了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行命令查看是否安装成功:</span><br><span class="line"></span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">安装nmp阿里的命令：</span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org </span><br><span class="line"></span><br><span class="line">检查是否安装成功：</span><br><span class="line">cnpm -v</span><br><span class="line"></span><br><span class="line">cnpm安装软件时会比较快</span><br></pre></td></tr></table></figure><h4 id="2-安装git"><a href="#2-安装git" class="headerlink" title="2.安装git"></a>2.安装git</h4><p>首先查看电脑是否安装Git，终端输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git</span><br></pre></td></tr></table></figure><br>查看是否出现下图内容：<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9636b15nhj30zi0sawli.jpg" alt=""></p><p>安装git：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure><br>如果之前未安装homebrew，需安装homebrew，在终端输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure></p><h4 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3.安装hexo"></a>3.安装hexo</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo su 进入root用户，执行下列命令安装：</span><br><span class="line"></span><br><span class="line">cnpm install hexo-cli -g</span><br><span class="line">    或者：</span><br><span class="line">npm install hexo-cli -g</span><br><span class="line"></span><br><span class="line">查看是否安装成功：</span><br><span class="line">hexo -v</span><br></pre></td></tr></table></figure><h4 id="4-搭建hexo"><a href="#4-搭建hexo" class="headerlink" title="4.搭建hexo"></a>4.搭建hexo</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog  //初始化</span><br><span class="line">cd blog         //进入文件夹blog</span><br><span class="line">npm install    //安装</span><br><span class="line">运行：==hexo s== (浏览器里输入地址 localhost:4000 即可看到效果)</span><br></pre></td></tr></table></figure><h4 id="5-部署到GitHub"><a href="#5-部署到GitHub" class="headerlink" title="5.部署到GitHub"></a>5.部署到GitHub</h4><ul><li><p>创建一个xxx.github.io的public仓库</p></li><li><p>安装一个Git的插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure></li><li><p>修改站点配置文件(_config.yml)，修改 depoly ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/chenyawei1227/chenyawei1227.github.io.git  &lt;所建仓库地址&gt;</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">修改主题后启动如果报如下错误：</span><br><span class="line">extends includes/layout.pug block content include includes/recent-posts.pug include includes/partial</span><br><span class="line"></span><br><span class="line">则执行如下命令可解决：</span><br><span class="line">npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</span><br><span class="line"></span><br><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></li><li><p>部署</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo clean  <span class="comment">//清理</span></span><br><span class="line">hexo g      <span class="comment">//生产页面</span></span><br><span class="line">hexo d      <span class="comment">//部署到GitHub</span></span><br><span class="line"></span><br><span class="line">浏览器访问：https:<span class="comment">//chenyawei1227.github.io 查看到效果。</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="6-更改主题"><a href="#6-更改主题" class="headerlink" title="6.更改主题"></a>6.更改主题</h4><p>hexo的主题很多，官网的主题：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a><br>这里以Cxo主题为例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#进入到themes文件夹下，下载主题：</span><br><span class="line">git clone https://github.com/Longlongyu/hexo-theme-Cxo Cxo</span><br><span class="line"></span><br><span class="line"># 修改 _config.yml 配置</span><br><span class="line">theme: Cxo</span><br><span class="line"></span><br><span class="line">执行:</span><br><span class="line">hexo clean</span><br><span class="line">hexo deploy</span><br><span class="line"></span><br><span class="line">浏览器访问：https://chenyawei.github1227.io 查看到效果。</span><br></pre></td></tr></table></figure></p><h4 id="7-创建新文章"><a href="#7-创建新文章" class="headerlink" title="7.创建新文章"></a>7.创建新文章</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo new &apos;文章名&apos;</span><br><span class="line"></span><br><span class="line">就可以在blog的source文件夹里看到</span><br></pre></td></tr></table></figure><h4 id="常用指令："><a href="#常用指令：" class="headerlink" title="常用指令："></a>常用指令：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g </span><br><span class="line">hexo init </span><br><span class="line">npm install</span><br><span class="line">hexo s</span><br><span class="line">hexo new "postName"          #新建文章</span><br><span class="line">hexo new page "pageName"     #新建页面</span><br><span class="line">hexo generate                #生成静态页面至public目录</span><br><span class="line">hexo server     #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span><br><span class="line">hexo deploy     #部署到GitHub</span><br><span class="line">hexo help       #查看帮助</span><br><span class="line">hexo version    #查看Hexo的版本</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 操作记录 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-Theme-Snail</title>
      <link href="/2019/11/01/Hexo-Theme-Snail/"/>
      <url>/2019/11/01/Hexo-Theme-Snail/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo-theme-snail"><a href="#hexo-theme-snail" class="headerlink" title="hexo-theme-snail"></a>hexo-theme-snail</h1><p><a href="https://github.com/chenyawei1227/hexo-theme-snail" target="_blank" rel="noopener">View Hexo-Theme-Snail Sources On Github &#10174; </a></p><p><a href="https://www.bytenote.cn" target="_blank" rel="noopener">View Live Super Snail Blog &#10174;</a></p><p><img src="snail.png" alt="hexo-theme-snail"></p><p>Hexo-theme-snail is a succinct hexo theme. It has two colors, light and star, that can be set according to your own preferences in the settings, and also has the functions of sharing and commenting. More features are under development.</p><h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ul><li>light color theme and star theme</li><li>diversified comment system</li><li>notice tips</li><li>share to other platforms (under development)</li><li>picture sharing (under development)</li></ul><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Install-Hexo"><a href="#Install-Hexo" class="headerlink" title="Install Hexo"></a>Install Hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h3 id="Setup-your-blog"><a href="#Setup-your-blog" class="headerlink" title="Setup your blog"></a>Setup your blog</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init blog</span><br></pre></td></tr></table></figure><h3 id="Installation-Theme"><a href="#Installation-Theme" class="headerlink" title="Installation Theme"></a>Installation Theme</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ rm -rf <span class="built_in">source</span></span><br><span class="line">$ rm _config.yml package.json README.md LICENSE</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/chenyawei1227/hexo-theme-snail.git</span><br><span class="line">$ mv ./hexo-theme-snail/snail ./themes</span><br><span class="line">$ mv ./hexo-theme-snail/* ./</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><h3 id="Set-Theme"><a href="#Set-Theme" class="headerlink" title="Set Theme"></a>Set Theme</h3><p>Modify the value of <code>theme:</code> in <code>_config.yml</code><br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">snail</span></span><br></pre></td></tr></table></figure></p><h3 id="Start-the-Server"><a href="#Start-the-Server" class="headerlink" title="Start the Server"></a>Start the Server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><h3 id="Site"><a href="#Site" class="headerlink" title="Site"></a>Site</h3><p>Replace the following information with your own.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> </span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">At</span> <span class="string">the</span> <span class="string">bottom</span> <span class="string">of</span> <span class="string">the</span> <span class="string">well,</span> <span class="string">it</span> <span class="string">is</span> <span class="string">destined</span> <span class="string">to</span> <span class="string">see</span> <span class="string">only</span> <span class="string">the</span> <span class="string">sky</span> <span class="string">at</span> <span class="string">the</span> <span class="string">wellhead.</span> </span><br><span class="line">          <span class="string">However,</span> <span class="string">the</span> <span class="string">starting</span> <span class="string">point</span> <span class="string">only</span> <span class="string">affects</span> <span class="string">the</span> <span class="string">process</span> <span class="string">of</span> <span class="string">reaching</span> <span class="string">your</span> <span class="string">peak</span> <span class="string">and</span> <span class="string">does</span> <span class="string">not</span> <span class="string">determine</span> <span class="string">the</span> <span class="string">height</span> <span class="string">you</span> <span class="string">reach.</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Dusign</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">en</span></span><br><span class="line"><span class="attr">timezone:</span></span><br></pre></td></tr></table></figure></p><h3 id="Site-Settings"><a href="#Site-Settings" class="headerlink" title="Site Settings"></a>Site Settings</h3><p>Put customized pictures in <code>img</code> directory.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site settings</span></span><br><span class="line"><span class="attr">SEOTitle:</span> <span class="string">Hexo-theme-snail</span></span><br><span class="line"><span class="attr">email:</span> <span class="string">hexo-theme-snail@mail.com</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">"A hexo theme"</span></span><br><span class="line"><span class="attr">keyword:</span> <span class="string">"dusign, hexo-theme-snail"</span></span><br><span class="line"><span class="attr">header-img:</span> <span class="string">img/header_img/home-bg-1-dark.jpg</span></span><br><span class="line"><span class="attr">signature:</span> <span class="literal">true</span> <span class="comment">#show signature</span></span><br><span class="line"><span class="attr">signature-img:</span> <span class="string">img/signature/Just-do-it-white.png</span></span><br></pre></td></tr></table></figure></p><h3 id="SNS-Settings"><a href="#SNS-Settings" class="headerlink" title="SNS Settings"></a>SNS Settings</h3><p>If you don’t want to display it, you can delete it directly.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SNS settings</span></span><br><span class="line"><span class="attr">github_username:</span>    <span class="string">dusign</span></span><br><span class="line"><span class="attr">twitter_username:</span>   <span class="string">dusignr</span></span><br><span class="line"><span class="attr">facebook_username:</span>  <span class="string">Gang</span> <span class="string">Du</span></span><br><span class="line"><span class="attr">zhihu_username:</span> <span class="string">dusignr</span></span><br></pre></td></tr></table></figure></p><h3 id="Sidebar-Settings"><a href="#Sidebar-Settings" class="headerlink" title="Sidebar Settings"></a>Sidebar Settings</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sidebar Settings</span></span><br><span class="line"><span class="attr">sidebar:</span> <span class="literal">true</span>                      <span class="comment"># whether or not using Sidebar.</span></span><br><span class="line"><span class="attr">sidebar-about-description:</span> <span class="string">"Welcome to visit, I'm Dusign!"</span></span><br><span class="line"><span class="attr">sidebar-avatar:</span> <span class="string">img/ironman-draw.png</span>      <span class="comment"># use absolute URL, seeing it's used in both `/` and `/about/`</span></span><br><span class="line"><span class="attr">widgets:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">featured-tags</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">short-about</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">recent-posts</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">friends-blog</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">archive</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">category</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># widget behavior</span></span><br><span class="line"><span class="comment">## Archive</span></span><br><span class="line"><span class="attr">archive_type:</span> <span class="string">'monthly'</span></span><br><span class="line"><span class="attr">show_count:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## Featured Tags</span></span><br><span class="line"><span class="attr">featured-tags:</span> <span class="literal">true</span>                     <span class="comment"># whether or not using Feature-Tags</span></span><br><span class="line"><span class="attr">featured-condition-size:</span> <span class="number">1</span>              <span class="comment"># A tag will be featured if the size of it is more than this condition value</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## Friends</span></span><br><span class="line"><span class="attr">friends:</span> <span class="string">[</span></span><br><span class="line">    <span class="string">&#123;</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">"Dusign's Blog"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span> <span class="string">"https://www.jianshu.com/u/78b636e8a217"</span></span><br><span class="line">    <span class="string">&#125;,&#123;</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">"Dusign's Web"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span> <span class="string">"#"</span></span><br><span class="line">    <span class="string">&#125;,&#123;</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">"Dusign's Github"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span> <span class="string">"https://github.com/chenyawei1227"</span></span><br><span class="line">    <span class="string">&#125;,&#123;</span></span><br><span class="line">        <span class="attr">title:</span> <span class="string">"Other"</span><span class="string">,</span></span><br><span class="line">        <span class="attr">href:</span> <span class="string">"#"</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="string">]</span></span><br></pre></td></tr></table></figure><h3 id="Theme"><a href="#Theme" class="headerlink" title="Theme"></a>Theme</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">snail</span></span><br></pre></td></tr></table></figure><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">      <span class="attr">github:</span> <span class="string">github.repository.address</span></span><br><span class="line">      <span class="attr">coding:</span> <span class="string">coding.repository.address</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><h3 id="Comment"><a href="#Comment" class="headerlink" title="Comment"></a>Comment</h3><p>See httpymls://github.com/imsun/gitment for detailed configuration method.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Comment</span></span><br><span class="line"><span class="comment">## This comment system is gitment</span></span><br><span class="line"><span class="comment">## gitment url: https://github.com/imsun/gitment</span></span><br><span class="line"><span class="attr">comment:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">owner:</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">  <span class="attr">client_id:</span></span><br><span class="line">  <span class="attr">client_secret:</span></span><br></pre></td></tr></table></figure></p><h3 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Tip</span></span><br><span class="line"><span class="attr">tip:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">content:</span> <span class="string">欢迎访问</span> <span class="string">&lt;a</span> <span class="string">href="https://www.bytenote.cn"</span> <span class="string">target="dusign"&gt;dusign&lt;/a&gt;</span> <span class="string">的博客，博客系统一键分享的功能还在完善中，请大家耐心等待。</span></span><br><span class="line">          <span class="string">若有问题或者有好的建议欢迎留言，笔者看到之后会及时回复。</span></span><br><span class="line">          <span class="string">评论点赞需要github账号登录，如果没有账号的话请点击</span> </span><br><span class="line">          <span class="string">&lt;a</span> <span class="string">href="https://github.com"</span> <span class="string">target="view_window"</span> <span class="string">&gt;</span> <span class="string">github</span> <span class="string">&lt;/a&gt;</span> <span class="string">注册，</span> <span class="string">谢谢</span> <span class="string">!</span></span><br></pre></td></tr></table></figure><h3 id="Color-Sheme"><a href="#Color-Sheme" class="headerlink" title="Color Sheme"></a>Color Sheme</h3><p>Set the <code>enable</code> value of the desired color sheme to <code>true</code>. If the value of <code>bg_effects.star.enable</code> is <code>true</code>, please modify the value of <code>highlight_theme</code> in <code>./themes/snail/_config.yml</code> to <code>night</code>.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Color Sheme</span></span><br><span class="line"><span class="comment">## If there is no effect after modification, please empty the cache and try again.</span></span><br><span class="line"><span class="comment">## ⚠️ The following special effects will take up a lot of cpu resorces, please open it carefully.</span></span><br><span class="line"><span class="attr">bg_effects:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">line:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">color:</span> <span class="number">129</span><span class="string">,200,61</span></span><br><span class="line">    <span class="attr">pointColor:</span> <span class="number">129</span><span class="string">,200,61</span></span><br><span class="line">    <span class="attr">opacity:</span> <span class="number">0.7</span></span><br><span class="line">    <span class="attr">zIndex:</span> <span class="number">-9</span></span><br><span class="line">    <span class="attr">count:</span> <span class="number">99</span></span><br><span class="line">  <span class="attr">mouse_click:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">content:</span> <span class="string">'"🌱","just do it","🌾","🍀","don'</span><span class="string">'t give up","🍂","🌻","try it again","🍃","never say die","🌵","🌿","🌴"'</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">'"rgb(121,93,179)"</span></span><br><span class="line"><span class="string">          ,"rgb(76,180,231)"</span></span><br><span class="line"><span class="string">          ,"rgb(184,90,154)"</span></span><br><span class="line"><span class="string">          ,"rgb(157,211,250)"</span></span><br><span class="line"><span class="string">          ,"rgb(255,0,0)"</span></span><br><span class="line"><span class="string">          ,"rgb(242,153,29)"</span></span><br><span class="line"><span class="string">          ,"rgb(23,204,16)"</span></span><br><span class="line"><span class="string">          ,"rgb(222,0,0)"</span></span><br><span class="line"><span class="string">          ,"rgb(22,36,92)"</span></span><br><span class="line"><span class="string">          ,"rgb(127,24,116)"</span></span><br><span class="line"><span class="string">          ,"rgb(119,195,79)"</span></span><br><span class="line"><span class="string">          ,"rgb(4,77,34)"</span></span><br><span class="line"><span class="string">          ,"rgb(122,2,60)"'</span></span><br><span class="line">  <span class="attr">star:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><h2 id="Releases"><a href="#Releases" class="headerlink" title="Releases"></a>Releases</h2><p>V1.0</p><ul><li>fix the bugs</li><li>add comment system</li><li>add notice tips</li><li>add star sheme</li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>Apache License 2.0 Copyright(c) 2018-2020 <a href="https://github.com/chenyawei1227" target="_blank" rel="noopener">Dusign</a>   </p><p><a href="https://github.com/chenyawei1227/hexo-theme-snail" target="_blank" rel="noopener">hexo-theme-snail</a> is derived from <a href="https://github.com/Huxpro/huxpro.github.io" target="_blank" rel="noopener">Huxpro</a> Apache License 2.0. Copyright (c) 2015-2020 Huxpro</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作记录 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
